// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: thread_telemetry.proto

#include "thread_telemetry.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace threadnetwork {
PROTOBUF_CONSTEXPR TelemetryData_Duration::TelemetryData_Duration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seconds_)*/int64_t{0}
  , /*decltype(_impl_.nanos_)*/0} {}
struct TelemetryData_DurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_DurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_DurationDefaultTypeInternal() {}
  union {
    TelemetryData_Duration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_DurationDefaultTypeInternal _TelemetryData_Duration_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_WpanStats::TelemetryData_WpanStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phy_rx_)*/0
  , /*decltype(_impl_.phy_tx_)*/0
  , /*decltype(_impl_.mac_unicast_rx_)*/0
  , /*decltype(_impl_.mac_unicast_tx_)*/0
  , /*decltype(_impl_.mac_broadcast_rx_)*/0
  , /*decltype(_impl_.mac_broadcast_tx_)*/0
  , /*decltype(_impl_.mac_tx_ack_req_)*/0
  , /*decltype(_impl_.mac_tx_no_ack_req_)*/0
  , /*decltype(_impl_.mac_tx_acked_)*/0
  , /*decltype(_impl_.mac_tx_data_)*/0
  , /*decltype(_impl_.mac_tx_data_poll_)*/0
  , /*decltype(_impl_.mac_tx_beacon_)*/0
  , /*decltype(_impl_.mac_tx_beacon_req_)*/0
  , /*decltype(_impl_.mac_tx_other_pkt_)*/0
  , /*decltype(_impl_.mac_tx_retry_)*/0
  , /*decltype(_impl_.mac_rx_data_)*/0
  , /*decltype(_impl_.mac_rx_data_poll_)*/0
  , /*decltype(_impl_.mac_rx_beacon_)*/0
  , /*decltype(_impl_.mac_rx_beacon_req_)*/0
  , /*decltype(_impl_.mac_rx_other_pkt_)*/0
  , /*decltype(_impl_.mac_rx_filter_whitelist_)*/0
  , /*decltype(_impl_.mac_rx_filter_dest_addr_)*/0
  , /*decltype(_impl_.mac_tx_fail_cca_)*/0
  , /*decltype(_impl_.mac_rx_fail_decrypt_)*/0
  , /*decltype(_impl_.mac_rx_fail_no_frame_)*/0
  , /*decltype(_impl_.mac_rx_fail_unknown_neighbor_)*/0
  , /*decltype(_impl_.mac_rx_fail_invalid_src_addr_)*/0
  , /*decltype(_impl_.mac_rx_fail_fcs_)*/0
  , /*decltype(_impl_.mac_rx_fail_other_)*/0
  , /*decltype(_impl_.ip_tx_success_)*/0
  , /*decltype(_impl_.ip_rx_success_)*/0
  , /*decltype(_impl_.ip_tx_failure_)*/0
  , /*decltype(_impl_.ip_rx_failure_)*/0
  , /*decltype(_impl_.node_type_)*/0u
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_.radio_tx_power_)*/0
  , /*decltype(_impl_.mac_cca_fail_rate_)*/0} {}
struct TelemetryData_WpanStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_WpanStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_WpanStatsDefaultTypeInternal() {}
  union {
    TelemetryData_WpanStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_WpanStatsDefaultTypeInternal _TelemetryData_WpanStats_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_WpanTopoFull::TelemetryData_WpanTopoFull(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.leader_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.network_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stable_network_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rloc16_)*/0u
  , /*decltype(_impl_.router_id_)*/0u
  , /*decltype(_impl_.leader_router_id_)*/0u
  , /*decltype(_impl_.leader_weight_)*/0u
  , /*decltype(_impl_.leader_local_weight_)*/0u
  , /*decltype(_impl_.network_data_version_)*/0u
  , /*decltype(_impl_.stable_network_data_version_)*/0u
  , /*decltype(_impl_.preferred_router_id_)*/0u
  , /*decltype(_impl_.partition_id_)*/0u
  , /*decltype(_impl_.child_table_size_)*/0u
  , /*decltype(_impl_.neighbor_table_size_)*/0u
  , /*decltype(_impl_.instant_rssi_)*/0
  , /*decltype(_impl_.extended_pan_id_)*/uint64_t{0u}} {}
struct TelemetryData_WpanTopoFullDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_WpanTopoFullDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_WpanTopoFullDefaultTypeInternal() {}
  union {
    TelemetryData_WpanTopoFull _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_WpanTopoFullDefaultTypeInternal _TelemetryData_WpanTopoFull_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_TopoEntry::TelemetryData_TopoEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.age_)*/nullptr
  , /*decltype(_impl_.timeout_)*/nullptr
  , /*decltype(_impl_.rloc16_)*/0u
  , /*decltype(_impl_.link_quality_in_)*/0u
  , /*decltype(_impl_.average_rssi_)*/0
  , /*decltype(_impl_.rx_on_when_idle_)*/false
  , /*decltype(_impl_.full_function_)*/false
  , /*decltype(_impl_.secure_data_request_)*/false
  , /*decltype(_impl_.full_network_data_)*/false
  , /*decltype(_impl_.last_rssi_)*/0
  , /*decltype(_impl_.link_frame_counter_)*/0u
  , /*decltype(_impl_.mle_frame_counter_)*/0u
  , /*decltype(_impl_.is_child_)*/false
  , /*decltype(_impl_.network_data_version_)*/0u
  , /*decltype(_impl_.mac_frame_error_rate_)*/0
  , /*decltype(_impl_.ip_message_error_rate_)*/0
  , /*decltype(_impl_.version_)*/0} {}
struct TelemetryData_TopoEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_TopoEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_TopoEntryDefaultTypeInternal() {}
  union {
    TelemetryData_TopoEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_TopoEntryDefaultTypeInternal _TelemetryData_TopoEntry_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_PacketsAndBytes::TelemetryData_PacketsAndBytes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.packet_count_)*/int64_t{0}
  , /*decltype(_impl_.byte_count_)*/int64_t{0}} {}
struct TelemetryData_PacketsAndBytesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_PacketsAndBytesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_PacketsAndBytesDefaultTypeInternal() {}
  union {
    TelemetryData_PacketsAndBytes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_PacketsAndBytesDefaultTypeInternal _TelemetryData_PacketsAndBytes_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_Nat64TrafficCounters::TelemetryData_Nat64TrafficCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipv4_to_ipv6_packets_)*/int64_t{0}
  , /*decltype(_impl_.ipv4_to_ipv6_bytes_)*/int64_t{0}
  , /*decltype(_impl_.ipv6_to_ipv4_packets_)*/int64_t{0}
  , /*decltype(_impl_.ipv6_to_ipv4_bytes_)*/int64_t{0}} {}
struct TelemetryData_Nat64TrafficCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_Nat64TrafficCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_Nat64TrafficCountersDefaultTypeInternal() {}
  union {
    TelemetryData_Nat64TrafficCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_Nat64TrafficCountersDefaultTypeInternal _TelemetryData_Nat64TrafficCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_Nat64ProtocolCounters::TelemetryData_Nat64ProtocolCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tcp_)*/nullptr
  , /*decltype(_impl_.udp_)*/nullptr
  , /*decltype(_impl_.icmp_)*/nullptr} {}
struct TelemetryData_Nat64ProtocolCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_Nat64ProtocolCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_Nat64ProtocolCountersDefaultTypeInternal() {}
  union {
    TelemetryData_Nat64ProtocolCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_Nat64ProtocolCountersDefaultTypeInternal _TelemetryData_Nat64ProtocolCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_Nat64PacketCounters::TelemetryData_Nat64PacketCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipv4_to_ipv6_packets_)*/int64_t{0}
  , /*decltype(_impl_.ipv6_to_ipv4_packets_)*/int64_t{0}} {}
struct TelemetryData_Nat64PacketCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_Nat64PacketCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_Nat64PacketCountersDefaultTypeInternal() {}
  union {
    TelemetryData_Nat64PacketCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_Nat64PacketCountersDefaultTypeInternal _TelemetryData_Nat64PacketCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_Nat64ErrorCounters::TelemetryData_Nat64ErrorCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unknown_)*/nullptr
  , /*decltype(_impl_.illegal_packet_)*/nullptr
  , /*decltype(_impl_.unsupported_protocol_)*/nullptr
  , /*decltype(_impl_.no_mapping_)*/nullptr} {}
struct TelemetryData_Nat64ErrorCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_Nat64ErrorCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_Nat64ErrorCountersDefaultTypeInternal() {}
  union {
    TelemetryData_Nat64ErrorCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_Nat64ErrorCountersDefaultTypeInternal _TelemetryData_Nat64ErrorCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingCounters::TelemetryData_BorderRoutingCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.inbound_unicast_)*/nullptr
  , /*decltype(_impl_.inbound_multicast_)*/nullptr
  , /*decltype(_impl_.outbound_unicast_)*/nullptr
  , /*decltype(_impl_.outbound_multicast_)*/nullptr
  , /*decltype(_impl_.nat64_protocol_counters_)*/nullptr
  , /*decltype(_impl_.nat64_error_counters_)*/nullptr
  , /*decltype(_impl_.inbound_internet_)*/nullptr
  , /*decltype(_impl_.outbound_internet_)*/nullptr
  , /*decltype(_impl_.ra_rx_)*/int64_t{0}
  , /*decltype(_impl_.ra_tx_success_)*/int64_t{0}
  , /*decltype(_impl_.ra_tx_failure_)*/int64_t{0}
  , /*decltype(_impl_.rs_rx_)*/int64_t{0}
  , /*decltype(_impl_.rs_tx_success_)*/int64_t{0}
  , /*decltype(_impl_.rs_tx_failure_)*/int64_t{0}} {}
struct TelemetryData_BorderRoutingCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_BorderRoutingCountersDefaultTypeInternal() {}
  union {
    TelemetryData_BorderRoutingCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_BorderRoutingCountersDefaultTypeInternal _TelemetryData_BorderRoutingCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_PdProcessedRaInfo::TelemetryData_PdProcessedRaInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.num_platform_ra_received_)*/0u
  , /*decltype(_impl_.num_platform_pio_processed_)*/0u
  , /*decltype(_impl_.last_platform_ra_msec_)*/0u} {}
struct TelemetryData_PdProcessedRaInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_PdProcessedRaInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_PdProcessedRaInfoDefaultTypeInternal() {}
  union {
    TelemetryData_PdProcessedRaInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_PdProcessedRaInfoDefaultTypeInternal _TelemetryData_PdProcessedRaInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_SrpServerRegistrationInfo::TelemetryData_SrpServerRegistrationInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fresh_count_)*/0u
  , /*decltype(_impl_.deleted_count_)*/0u
  , /*decltype(_impl_.lease_time_total_ms_)*/uint64_t{0u}
  , /*decltype(_impl_.key_lease_time_total_ms_)*/uint64_t{0u}
  , /*decltype(_impl_.remaining_lease_time_total_ms_)*/uint64_t{0u}
  , /*decltype(_impl_.remaining_key_lease_time_total_ms_)*/uint64_t{0u}} {}
struct TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal() {}
  union {
    TelemetryData_SrpServerRegistrationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal _TelemetryData_SrpServerRegistrationInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_SrpServerResponseCounters::TelemetryData_SrpServerResponseCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_count_)*/0u
  , /*decltype(_impl_.server_failure_count_)*/0u
  , /*decltype(_impl_.format_error_count_)*/0u
  , /*decltype(_impl_.name_exists_count_)*/0u
  , /*decltype(_impl_.refused_count_)*/0u
  , /*decltype(_impl_.other_count_)*/0u} {}
struct TelemetryData_SrpServerResponseCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_SrpServerResponseCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_SrpServerResponseCountersDefaultTypeInternal() {}
  union {
    TelemetryData_SrpServerResponseCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_SrpServerResponseCountersDefaultTypeInternal _TelemetryData_SrpServerResponseCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_SrpServerInfo::TelemetryData_SrpServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hosts_)*/nullptr
  , /*decltype(_impl_.services_)*/nullptr
  , /*decltype(_impl_.response_counters_)*/nullptr
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_.address_mode_)*/0} {}
struct TelemetryData_SrpServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_SrpServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_SrpServerInfoDefaultTypeInternal() {}
  union {
    TelemetryData_SrpServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_SrpServerInfoDefaultTypeInternal _TelemetryData_SrpServerInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_TrelPacketCounters::TelemetryData_TrelPacketCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trel_tx_packets_)*/uint64_t{0u}
  , /*decltype(_impl_.trel_tx_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.trel_tx_packets_failed_)*/uint64_t{0u}
  , /*decltype(_impl_.tre_rx_packets_)*/uint64_t{0u}
  , /*decltype(_impl_.trel_rx_bytes_)*/uint64_t{0u}} {}
struct TelemetryData_TrelPacketCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_TrelPacketCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_TrelPacketCountersDefaultTypeInternal() {}
  union {
    TelemetryData_TrelPacketCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_TrelPacketCountersDefaultTypeInternal _TelemetryData_TrelPacketCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_TrelInfo::TelemetryData_TrelInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.counters_)*/nullptr
  , /*decltype(_impl_.is_trel_enabled_)*/false
  , /*decltype(_impl_.num_trel_peers_)*/0u} {}
struct TelemetryData_TrelInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_TrelInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_TrelInfoDefaultTypeInternal() {}
  union {
    TelemetryData_TrelInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_TrelInfoDefaultTypeInternal _TelemetryData_TrelInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_DnsServerResponseCounters::TelemetryData_DnsServerResponseCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_count_)*/0u
  , /*decltype(_impl_.server_failure_count_)*/0u
  , /*decltype(_impl_.format_error_count_)*/0u
  , /*decltype(_impl_.name_error_count_)*/0u
  , /*decltype(_impl_.not_implemented_count_)*/0u
  , /*decltype(_impl_.other_count_)*/0u
  , /*decltype(_impl_.upstream_dns_queries_)*/0u
  , /*decltype(_impl_.upstream_dns_responses_)*/0u
  , /*decltype(_impl_.upstream_dns_failures_)*/0u} {}
struct TelemetryData_DnsServerResponseCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_DnsServerResponseCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_DnsServerResponseCountersDefaultTypeInternal() {}
  union {
    TelemetryData_DnsServerResponseCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_DnsServerResponseCountersDefaultTypeInternal _TelemetryData_DnsServerResponseCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_DnsServerInfo::TelemetryData_DnsServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_counters_)*/nullptr
  , /*decltype(_impl_.resolved_by_local_srp_count_)*/0u
  , /*decltype(_impl_.upstream_dns_query_state_)*/0} {}
struct TelemetryData_DnsServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_DnsServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_DnsServerInfoDefaultTypeInternal() {}
  union {
    TelemetryData_DnsServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_DnsServerInfoDefaultTypeInternal _TelemetryData_DnsServerInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_MdnsResponseCounters::TelemetryData_MdnsResponseCounters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_count_)*/0u
  , /*decltype(_impl_.not_found_count_)*/0u
  , /*decltype(_impl_.invalid_args_count_)*/0u
  , /*decltype(_impl_.duplicated_count_)*/0u
  , /*decltype(_impl_.not_implemented_count_)*/0u
  , /*decltype(_impl_.unknown_error_count_)*/0u
  , /*decltype(_impl_.aborted_count_)*/0u
  , /*decltype(_impl_.invalid_state_count_)*/0u} {}
struct TelemetryData_MdnsResponseCountersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_MdnsResponseCountersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_MdnsResponseCountersDefaultTypeInternal() {}
  union {
    TelemetryData_MdnsResponseCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_MdnsResponseCountersDefaultTypeInternal _TelemetryData_MdnsResponseCounters_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_MdnsInfo::TelemetryData_MdnsInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.host_registration_responses_)*/nullptr
  , /*decltype(_impl_.service_registration_responses_)*/nullptr
  , /*decltype(_impl_.host_resolution_responses_)*/nullptr
  , /*decltype(_impl_.service_resolution_responses_)*/nullptr
  , /*decltype(_impl_.host_registration_ema_latency_ms_)*/0u
  , /*decltype(_impl_.service_registration_ema_latency_ms_)*/0u
  , /*decltype(_impl_.host_resolution_ema_latency_ms_)*/0u
  , /*decltype(_impl_.service_resolution_ema_latency_ms_)*/0u} {}
struct TelemetryData_MdnsInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_MdnsInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_MdnsInfoDefaultTypeInternal() {}
  union {
    TelemetryData_MdnsInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_MdnsInfoDefaultTypeInternal _TelemetryData_MdnsInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingNat64State::TelemetryData_BorderRoutingNat64State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prefix_manager_state_)*/0
  , /*decltype(_impl_.translator_state_)*/0} {}
struct TelemetryData_BorderRoutingNat64StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingNat64StateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_BorderRoutingNat64StateDefaultTypeInternal() {}
  union {
    TelemetryData_BorderRoutingNat64State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_BorderRoutingNat64StateDefaultTypeInternal _TelemetryData_BorderRoutingNat64State_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_Nat64Mapping::TelemetryData_Nat64Mapping(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hashed_ipv6_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.counters_)*/nullptr
  , /*decltype(_impl_.mapping_id_)*/uint64_t{0u}} {}
struct TelemetryData_Nat64MappingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_Nat64MappingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_Nat64MappingDefaultTypeInternal() {}
  union {
    TelemetryData_Nat64Mapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_Nat64MappingDefaultTypeInternal _TelemetryData_Nat64Mapping_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_InfraLinkInfo::TelemetryData_InfraLinkInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_up_)*/false
  , /*decltype(_impl_.is_running_)*/false
  , /*decltype(_impl_.is_multicast_)*/false
  , /*decltype(_impl_.link_local_address_count_)*/0u
  , /*decltype(_impl_.unique_local_address_count_)*/0u
  , /*decltype(_impl_.global_unicast_address_count_)*/0u} {}
struct TelemetryData_InfraLinkInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_InfraLinkInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_InfraLinkInfoDefaultTypeInternal() {}
  union {
    TelemetryData_InfraLinkInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_InfraLinkInfoDefaultTypeInternal _TelemetryData_InfraLinkInfo_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_WpanBorderRouter::TelemetryData_WpanBorderRouter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nat64_mappings_)*/{}
  , /*decltype(_impl_.hashed_pd_prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.border_routing_counters_)*/nullptr
  , /*decltype(_impl_.srp_server_)*/nullptr
  , /*decltype(_impl_.dns_server_)*/nullptr
  , /*decltype(_impl_.mdns_)*/nullptr
  , /*decltype(_impl_.nat64_state_)*/nullptr
  , /*decltype(_impl_.pd_processed_ra_info_)*/nullptr
  , /*decltype(_impl_.trel_info_)*/nullptr
  , /*decltype(_impl_.infra_link_info_)*/nullptr
  , /*decltype(_impl_.dhcp6_pd_state_)*/0} {}
struct TelemetryData_WpanBorderRouterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_WpanBorderRouterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_WpanBorderRouterDefaultTypeInternal() {}
  union {
    TelemetryData_WpanBorderRouter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_WpanBorderRouterDefaultTypeInternal _TelemetryData_WpanBorderRouter_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_RcpStabilityStatistics::TelemetryData_RcpStabilityStatistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rcp_timeout_count_)*/0u
  , /*decltype(_impl_.rcp_reset_count_)*/0u
  , /*decltype(_impl_.rcp_restoration_count_)*/0u
  , /*decltype(_impl_.spinel_parse_error_count_)*/0u
  , /*decltype(_impl_.rcp_firmware_update_count_)*/0
  , /*decltype(_impl_.thread_stack_uptime_)*/0u} {}
struct TelemetryData_RcpStabilityStatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_RcpStabilityStatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_RcpStabilityStatisticsDefaultTypeInternal() {}
  union {
    TelemetryData_RcpStabilityStatistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_RcpStabilityStatisticsDefaultTypeInternal _TelemetryData_RcpStabilityStatistics_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_RcpInterfaceStatistics::TelemetryData_RcpInterfaceStatistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transferred_frames_count_)*/uint64_t{0u}
  , /*decltype(_impl_.transferred_valid_frames_count_)*/uint64_t{0u}
  , /*decltype(_impl_.transferred_garbage_frames_count_)*/uint64_t{0u}
  , /*decltype(_impl_.rx_frames_count_)*/uint64_t{0u}
  , /*decltype(_impl_.rx_bytes_count_)*/uint64_t{0u}
  , /*decltype(_impl_.tx_frames_count_)*/uint64_t{0u}
  , /*decltype(_impl_.tx_bytes_count_)*/uint64_t{0u}
  , /*decltype(_impl_.rcp_interface_type_)*/0u} {}
struct TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal() {}
  union {
    TelemetryData_RcpInterfaceStatistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal _TelemetryData_RcpInterfaceStatistics_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_WpanRcp::TelemetryData_WpanRcp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rcp_stability_statistics_)*/nullptr
  , /*decltype(_impl_.rcp_interface_statistics_)*/nullptr} {}
struct TelemetryData_WpanRcpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_WpanRcpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_WpanRcpDefaultTypeInternal() {}
  union {
    TelemetryData_WpanRcp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_WpanRcpDefaultTypeInternal _TelemetryData_WpanRcp_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_CoexMetrics::TelemetryData_CoexMetrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.count_tx_request_)*/0u
  , /*decltype(_impl_.count_tx_grant_immediate_)*/0u
  , /*decltype(_impl_.count_tx_grant_wait_)*/0u
  , /*decltype(_impl_.count_tx_grant_wait_activated_)*/0u
  , /*decltype(_impl_.count_tx_grant_wait_timeout_)*/0u
  , /*decltype(_impl_.count_tx_grant_deactivated_during_request_)*/0u
  , /*decltype(_impl_.tx_average_request_to_grant_time_us_)*/0u
  , /*decltype(_impl_.count_rx_request_)*/0u
  , /*decltype(_impl_.count_rx_grant_immediate_)*/0u
  , /*decltype(_impl_.count_rx_grant_wait_)*/0u
  , /*decltype(_impl_.count_rx_grant_wait_activated_)*/0u
  , /*decltype(_impl_.count_rx_grant_wait_timeout_)*/0u
  , /*decltype(_impl_.count_rx_grant_deactivated_during_request_)*/0u
  , /*decltype(_impl_.count_rx_grant_none_)*/0u
  , /*decltype(_impl_.rx_average_request_to_grant_time_us_)*/0u} {}
struct TelemetryData_CoexMetricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_CoexMetricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_CoexMetricsDefaultTypeInternal() {}
  union {
    TelemetryData_CoexMetrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_CoexMetricsDefaultTypeInternal _TelemetryData_CoexMetrics_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_LinkMetricsEntry::TelemetryData_LinkMetricsEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.link_margin_)*/0
  , /*decltype(_impl_.rssi_)*/0} {}
struct TelemetryData_LinkMetricsEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_LinkMetricsEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_LinkMetricsEntryDefaultTypeInternal() {}
  union {
    TelemetryData_LinkMetricsEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_LinkMetricsEntryDefaultTypeInternal _TelemetryData_LinkMetricsEntry_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData_LowPowerMetrics::TelemetryData_LowPowerMetrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.link_metrics_entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TelemetryData_LowPowerMetricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryData_LowPowerMetricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryData_LowPowerMetricsDefaultTypeInternal() {}
  union {
    TelemetryData_LowPowerMetrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryData_LowPowerMetricsDefaultTypeInternal _TelemetryData_LowPowerMetrics_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData::TelemetryData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.topo_entries_)*/{}
  , /*decltype(_impl_.wpan_stats_)*/nullptr
  , /*decltype(_impl_.wpan_topo_full_)*/nullptr
  , /*decltype(_impl_.wpan_border_router_)*/nullptr
  , /*decltype(_impl_.wpan_rcp_)*/nullptr
  , /*decltype(_impl_.coex_metrics_)*/nullptr
  , /*decltype(_impl_.low_power_metrics_)*/nullptr} {}
struct TelemetryDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TelemetryDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TelemetryDataDefaultTypeInternal() {}
  union {
    TelemetryData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryDataDefaultTypeInternal _TelemetryData_default_instance_;
}  // namespace threadnetwork
namespace threadnetwork {
bool TelemetryData_NodeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_NodeType_strings[11] = {};

static const char TelemetryData_NodeType_names[] =
  "NODE_TYPE_COMMISSIONER"
  "NODE_TYPE_DETACHED"
  "NODE_TYPE_DISABLED"
  "NODE_TYPE_END"
  "NODE_TYPE_LEADER"
  "NODE_TYPE_MINIMAL_END"
  "NODE_TYPE_NL_LURKER"
  "NODE_TYPE_OFFLINE"
  "NODE_TYPE_ROUTER"
  "NODE_TYPE_SLEEPY_END"
  "NODE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_NodeType_entries[] = {
  { {TelemetryData_NodeType_names + 0, 22}, 32 },
  { {TelemetryData_NodeType_names + 22, 18}, 7 },
  { {TelemetryData_NodeType_names + 40, 18}, 6 },
  { {TelemetryData_NodeType_names + 58, 13}, 2 },
  { {TelemetryData_NodeType_names + 71, 16}, 64 },
  { {TelemetryData_NodeType_names + 87, 21}, 4 },
  { {TelemetryData_NodeType_names + 108, 19}, 16 },
  { {TelemetryData_NodeType_names + 127, 17}, 5 },
  { {TelemetryData_NodeType_names + 144, 16}, 1 },
  { {TelemetryData_NodeType_names + 160, 20}, 3 },
  { {TelemetryData_NodeType_names + 180, 21}, 0 },
};

static const int TelemetryData_NodeType_entries_by_number[] = {
  10, // 0 -> NODE_TYPE_UNSPECIFIED
  8, // 1 -> NODE_TYPE_ROUTER
  3, // 2 -> NODE_TYPE_END
  9, // 3 -> NODE_TYPE_SLEEPY_END
  5, // 4 -> NODE_TYPE_MINIMAL_END
  7, // 5 -> NODE_TYPE_OFFLINE
  2, // 6 -> NODE_TYPE_DISABLED
  1, // 7 -> NODE_TYPE_DETACHED
  6, // 16 -> NODE_TYPE_NL_LURKER
  0, // 32 -> NODE_TYPE_COMMISSIONER
  4, // 64 -> NODE_TYPE_LEADER
};

const std::string& TelemetryData_NodeType_Name(
    TelemetryData_NodeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_NodeType_entries,
          TelemetryData_NodeType_entries_by_number,
          11, TelemetryData_NodeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_NodeType_entries,
      TelemetryData_NodeType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_NodeType_strings[idx].get();
}
bool TelemetryData_NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_NodeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_NodeType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_NodeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_UNSPECIFIED;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_ROUTER;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_END;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_SLEEPY_END;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_MINIMAL_END;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_OFFLINE;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_DISABLED;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_DETACHED;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_NL_LURKER;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_COMMISSIONER;
constexpr TelemetryData_NodeType TelemetryData::NODE_TYPE_LEADER;
constexpr TelemetryData_NodeType TelemetryData::NodeType_MIN;
constexpr TelemetryData_NodeType TelemetryData::NodeType_MAX;
constexpr int TelemetryData::NodeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TelemetryData_Dhcp6PdState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_Dhcp6PdState_strings[4] = {};

static const char TelemetryData_Dhcp6PdState_names[] =
  "DHCP6_PD_STATE_DISABLED"
  "DHCP6_PD_STATE_RUNNING"
  "DHCP6_PD_STATE_STOPPED"
  "DHCP6_PD_STATE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_Dhcp6PdState_entries[] = {
  { {TelemetryData_Dhcp6PdState_names + 0, 23}, 1 },
  { {TelemetryData_Dhcp6PdState_names + 23, 22}, 3 },
  { {TelemetryData_Dhcp6PdState_names + 45, 22}, 2 },
  { {TelemetryData_Dhcp6PdState_names + 67, 26}, 0 },
};

static const int TelemetryData_Dhcp6PdState_entries_by_number[] = {
  3, // 0 -> DHCP6_PD_STATE_UNSPECIFIED
  0, // 1 -> DHCP6_PD_STATE_DISABLED
  2, // 2 -> DHCP6_PD_STATE_STOPPED
  1, // 3 -> DHCP6_PD_STATE_RUNNING
};

const std::string& TelemetryData_Dhcp6PdState_Name(
    TelemetryData_Dhcp6PdState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_Dhcp6PdState_entries,
          TelemetryData_Dhcp6PdState_entries_by_number,
          4, TelemetryData_Dhcp6PdState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_Dhcp6PdState_entries,
      TelemetryData_Dhcp6PdState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_Dhcp6PdState_strings[idx].get();
}
bool TelemetryData_Dhcp6PdState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_Dhcp6PdState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_Dhcp6PdState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_Dhcp6PdState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_Dhcp6PdState TelemetryData::DHCP6_PD_STATE_UNSPECIFIED;
constexpr TelemetryData_Dhcp6PdState TelemetryData::DHCP6_PD_STATE_DISABLED;
constexpr TelemetryData_Dhcp6PdState TelemetryData::DHCP6_PD_STATE_STOPPED;
constexpr TelemetryData_Dhcp6PdState TelemetryData::DHCP6_PD_STATE_RUNNING;
constexpr TelemetryData_Dhcp6PdState TelemetryData::Dhcp6PdState_MIN;
constexpr TelemetryData_Dhcp6PdState TelemetryData::Dhcp6PdState_MAX;
constexpr int TelemetryData::Dhcp6PdState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TelemetryData_SrpServerState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_SrpServerState_strings[4] = {};

static const char TelemetryData_SrpServerState_names[] =
  "SRP_SERVER_STATE_DISABLED"
  "SRP_SERVER_STATE_RUNNING"
  "SRP_SERVER_STATE_STOPPED"
  "SRP_SERVER_STATE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_SrpServerState_entries[] = {
  { {TelemetryData_SrpServerState_names + 0, 25}, 1 },
  { {TelemetryData_SrpServerState_names + 25, 24}, 2 },
  { {TelemetryData_SrpServerState_names + 49, 24}, 3 },
  { {TelemetryData_SrpServerState_names + 73, 28}, 0 },
};

static const int TelemetryData_SrpServerState_entries_by_number[] = {
  3, // 0 -> SRP_SERVER_STATE_UNSPECIFIED
  0, // 1 -> SRP_SERVER_STATE_DISABLED
  1, // 2 -> SRP_SERVER_STATE_RUNNING
  2, // 3 -> SRP_SERVER_STATE_STOPPED
};

const std::string& TelemetryData_SrpServerState_Name(
    TelemetryData_SrpServerState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_SrpServerState_entries,
          TelemetryData_SrpServerState_entries_by_number,
          4, TelemetryData_SrpServerState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_SrpServerState_entries,
      TelemetryData_SrpServerState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_SrpServerState_strings[idx].get();
}
bool TelemetryData_SrpServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_SrpServerState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_SrpServerState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_SrpServerState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_SrpServerState TelemetryData::SRP_SERVER_STATE_UNSPECIFIED;
constexpr TelemetryData_SrpServerState TelemetryData::SRP_SERVER_STATE_DISABLED;
constexpr TelemetryData_SrpServerState TelemetryData::SRP_SERVER_STATE_RUNNING;
constexpr TelemetryData_SrpServerState TelemetryData::SRP_SERVER_STATE_STOPPED;
constexpr TelemetryData_SrpServerState TelemetryData::SrpServerState_MIN;
constexpr TelemetryData_SrpServerState TelemetryData::SrpServerState_MAX;
constexpr int TelemetryData::SrpServerState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TelemetryData_SrpServerAddressMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_SrpServerAddressMode_strings[3] = {};

static const char TelemetryData_SrpServerAddressMode_names[] =
  "SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST"
  "SRP_SERVER_ADDRESS_MODE_UNICAST"
  "SRP_SERVER_ADDRESS_MODE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_SrpServerAddressMode_entries[] = {
  { {TelemetryData_SrpServerAddressMode_names + 0, 37}, 2 },
  { {TelemetryData_SrpServerAddressMode_names + 37, 31}, 1 },
  { {TelemetryData_SrpServerAddressMode_names + 68, 35}, 0 },
};

static const int TelemetryData_SrpServerAddressMode_entries_by_number[] = {
  2, // 0 -> SRP_SERVER_ADDRESS_MODE_UNSPECIFIED
  1, // 1 -> SRP_SERVER_ADDRESS_MODE_UNICAST
  0, // 2 -> SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST
};

const std::string& TelemetryData_SrpServerAddressMode_Name(
    TelemetryData_SrpServerAddressMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_SrpServerAddressMode_entries,
          TelemetryData_SrpServerAddressMode_entries_by_number,
          3, TelemetryData_SrpServerAddressMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_SrpServerAddressMode_entries,
      TelemetryData_SrpServerAddressMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_SrpServerAddressMode_strings[idx].get();
}
bool TelemetryData_SrpServerAddressMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_SrpServerAddressMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_SrpServerAddressMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_SrpServerAddressMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_SrpServerAddressMode TelemetryData::SRP_SERVER_ADDRESS_MODE_UNSPECIFIED;
constexpr TelemetryData_SrpServerAddressMode TelemetryData::SRP_SERVER_ADDRESS_MODE_UNICAST;
constexpr TelemetryData_SrpServerAddressMode TelemetryData::SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST;
constexpr TelemetryData_SrpServerAddressMode TelemetryData::SrpServerAddressMode_MIN;
constexpr TelemetryData_SrpServerAddressMode TelemetryData::SrpServerAddressMode_MAX;
constexpr int TelemetryData::SrpServerAddressMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TelemetryData_UpstreamDnsQueryState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_UpstreamDnsQueryState_strings[3] = {};

static const char TelemetryData_UpstreamDnsQueryState_names[] =
  "UPSTREAMDNS_QUERY_STATE_DISABLED"
  "UPSTREAMDNS_QUERY_STATE_ENABLED"
  "UPSTREAMDNS_QUERY_STATE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_UpstreamDnsQueryState_entries[] = {
  { {TelemetryData_UpstreamDnsQueryState_names + 0, 32}, 2 },
  { {TelemetryData_UpstreamDnsQueryState_names + 32, 31}, 1 },
  { {TelemetryData_UpstreamDnsQueryState_names + 63, 35}, 0 },
};

static const int TelemetryData_UpstreamDnsQueryState_entries_by_number[] = {
  2, // 0 -> UPSTREAMDNS_QUERY_STATE_UNSPECIFIED
  1, // 1 -> UPSTREAMDNS_QUERY_STATE_ENABLED
  0, // 2 -> UPSTREAMDNS_QUERY_STATE_DISABLED
};

const std::string& TelemetryData_UpstreamDnsQueryState_Name(
    TelemetryData_UpstreamDnsQueryState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_UpstreamDnsQueryState_entries,
          TelemetryData_UpstreamDnsQueryState_entries_by_number,
          3, TelemetryData_UpstreamDnsQueryState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_UpstreamDnsQueryState_entries,
      TelemetryData_UpstreamDnsQueryState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_UpstreamDnsQueryState_strings[idx].get();
}
bool TelemetryData_UpstreamDnsQueryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_UpstreamDnsQueryState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_UpstreamDnsQueryState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_UpstreamDnsQueryState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData::UPSTREAMDNS_QUERY_STATE_UNSPECIFIED;
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData::UPSTREAMDNS_QUERY_STATE_ENABLED;
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData::UPSTREAMDNS_QUERY_STATE_DISABLED;
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData::UpstreamDnsQueryState_MIN;
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData::UpstreamDnsQueryState_MAX;
constexpr int TelemetryData::UpstreamDnsQueryState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TelemetryData_Nat64State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TelemetryData_Nat64State_strings[5] = {};

static const char TelemetryData_Nat64State_names[] =
  "NAT64_STATE_ACTIVE"
  "NAT64_STATE_DISABLED"
  "NAT64_STATE_IDLE"
  "NAT64_STATE_NOT_RUNNING"
  "NAT64_STATE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TelemetryData_Nat64State_entries[] = {
  { {TelemetryData_Nat64State_names + 0, 18}, 4 },
  { {TelemetryData_Nat64State_names + 18, 20}, 1 },
  { {TelemetryData_Nat64State_names + 38, 16}, 3 },
  { {TelemetryData_Nat64State_names + 54, 23}, 2 },
  { {TelemetryData_Nat64State_names + 77, 23}, 0 },
};

static const int TelemetryData_Nat64State_entries_by_number[] = {
  4, // 0 -> NAT64_STATE_UNSPECIFIED
  1, // 1 -> NAT64_STATE_DISABLED
  3, // 2 -> NAT64_STATE_NOT_RUNNING
  2, // 3 -> NAT64_STATE_IDLE
  0, // 4 -> NAT64_STATE_ACTIVE
};

const std::string& TelemetryData_Nat64State_Name(
    TelemetryData_Nat64State value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TelemetryData_Nat64State_entries,
          TelemetryData_Nat64State_entries_by_number,
          5, TelemetryData_Nat64State_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TelemetryData_Nat64State_entries,
      TelemetryData_Nat64State_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TelemetryData_Nat64State_strings[idx].get();
}
bool TelemetryData_Nat64State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_Nat64State* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TelemetryData_Nat64State_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TelemetryData_Nat64State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TelemetryData_Nat64State TelemetryData::NAT64_STATE_UNSPECIFIED;
constexpr TelemetryData_Nat64State TelemetryData::NAT64_STATE_DISABLED;
constexpr TelemetryData_Nat64State TelemetryData::NAT64_STATE_NOT_RUNNING;
constexpr TelemetryData_Nat64State TelemetryData::NAT64_STATE_IDLE;
constexpr TelemetryData_Nat64State TelemetryData::NAT64_STATE_ACTIVE;
constexpr TelemetryData_Nat64State TelemetryData::Nat64State_MIN;
constexpr TelemetryData_Nat64State TelemetryData::Nat64State_MAX;
constexpr int TelemetryData::Nat64State_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class TelemetryData_Duration::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Duration>()._impl_._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TelemetryData_Duration::TelemetryData_Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Duration)
}
TelemetryData_Duration::TelemetryData_Duration(const TelemetryData_Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Duration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){}
    , decltype(_impl_.nanos_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Duration)
}

inline void TelemetryData_Duration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){int64_t{0}}
    , decltype(_impl_.nanos_){0}
  };
}

TelemetryData_Duration::~TelemetryData_Duration() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Duration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Duration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_Duration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Duration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nanos_) -
        reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Duration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Duration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Duration)
  return target;
}

size_t TelemetryData_Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Duration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Duration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Duration*>(
      &from));
}

void TelemetryData_Duration::MergeFrom(const TelemetryData_Duration& from) {
  TelemetryData_Duration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Duration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.seconds_ = from._impl_.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nanos_ = from._impl_.nanos_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Duration::CopyFrom(const TelemetryData_Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Duration::IsInitialized() const {
  return true;
}

void TelemetryData_Duration::InternalSwap(TelemetryData_Duration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Duration, _impl_.nanos_)
      + sizeof(TelemetryData_Duration::_impl_.nanos_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Duration, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string TelemetryData_Duration::GetTypeName() const {
  return "threadnetwork.TelemetryData.Duration";
}


// ===================================================================

class TelemetryData_WpanStats::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_WpanStats>()._impl_._has_bits_);
  static void set_has_phy_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_phy_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mac_unicast_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mac_unicast_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mac_broadcast_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mac_broadcast_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mac_tx_ack_req(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mac_tx_no_ack_req(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_mac_tx_acked(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mac_tx_data(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mac_tx_data_poll(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mac_tx_beacon(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_mac_tx_beacon_req(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_mac_tx_other_pkt(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_mac_tx_retry(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_mac_rx_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_mac_rx_data_poll(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_mac_rx_beacon(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_mac_rx_beacon_req(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_mac_rx_other_pkt(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_mac_rx_filter_whitelist(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_mac_rx_filter_dest_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_mac_tx_fail_cca(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_mac_rx_fail_decrypt(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_mac_rx_fail_no_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_mac_rx_fail_unknown_neighbor(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_mac_rx_fail_invalid_src_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_mac_rx_fail_fcs(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_mac_rx_fail_other(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_ip_tx_success(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_ip_rx_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_ip_tx_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_ip_rx_failure(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_node_type(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_radio_tx_power(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_mac_cca_fail_rate(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
};

TelemetryData_WpanStats::TelemetryData_WpanStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.WpanStats)
}
TelemetryData_WpanStats::TelemetryData_WpanStats(const TelemetryData_WpanStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_WpanStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phy_rx_){}
    , decltype(_impl_.phy_tx_){}
    , decltype(_impl_.mac_unicast_rx_){}
    , decltype(_impl_.mac_unicast_tx_){}
    , decltype(_impl_.mac_broadcast_rx_){}
    , decltype(_impl_.mac_broadcast_tx_){}
    , decltype(_impl_.mac_tx_ack_req_){}
    , decltype(_impl_.mac_tx_no_ack_req_){}
    , decltype(_impl_.mac_tx_acked_){}
    , decltype(_impl_.mac_tx_data_){}
    , decltype(_impl_.mac_tx_data_poll_){}
    , decltype(_impl_.mac_tx_beacon_){}
    , decltype(_impl_.mac_tx_beacon_req_){}
    , decltype(_impl_.mac_tx_other_pkt_){}
    , decltype(_impl_.mac_tx_retry_){}
    , decltype(_impl_.mac_rx_data_){}
    , decltype(_impl_.mac_rx_data_poll_){}
    , decltype(_impl_.mac_rx_beacon_){}
    , decltype(_impl_.mac_rx_beacon_req_){}
    , decltype(_impl_.mac_rx_other_pkt_){}
    , decltype(_impl_.mac_rx_filter_whitelist_){}
    , decltype(_impl_.mac_rx_filter_dest_addr_){}
    , decltype(_impl_.mac_tx_fail_cca_){}
    , decltype(_impl_.mac_rx_fail_decrypt_){}
    , decltype(_impl_.mac_rx_fail_no_frame_){}
    , decltype(_impl_.mac_rx_fail_unknown_neighbor_){}
    , decltype(_impl_.mac_rx_fail_invalid_src_addr_){}
    , decltype(_impl_.mac_rx_fail_fcs_){}
    , decltype(_impl_.mac_rx_fail_other_){}
    , decltype(_impl_.ip_tx_success_){}
    , decltype(_impl_.ip_rx_success_){}
    , decltype(_impl_.ip_tx_failure_){}
    , decltype(_impl_.ip_rx_failure_){}
    , decltype(_impl_.node_type_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.radio_tx_power_){}
    , decltype(_impl_.mac_cca_fail_rate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.phy_rx_, &from._impl_.phy_rx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mac_cca_fail_rate_) -
    reinterpret_cast<char*>(&_impl_.phy_rx_)) + sizeof(_impl_.mac_cca_fail_rate_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.WpanStats)
}

inline void TelemetryData_WpanStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phy_rx_){0}
    , decltype(_impl_.phy_tx_){0}
    , decltype(_impl_.mac_unicast_rx_){0}
    , decltype(_impl_.mac_unicast_tx_){0}
    , decltype(_impl_.mac_broadcast_rx_){0}
    , decltype(_impl_.mac_broadcast_tx_){0}
    , decltype(_impl_.mac_tx_ack_req_){0}
    , decltype(_impl_.mac_tx_no_ack_req_){0}
    , decltype(_impl_.mac_tx_acked_){0}
    , decltype(_impl_.mac_tx_data_){0}
    , decltype(_impl_.mac_tx_data_poll_){0}
    , decltype(_impl_.mac_tx_beacon_){0}
    , decltype(_impl_.mac_tx_beacon_req_){0}
    , decltype(_impl_.mac_tx_other_pkt_){0}
    , decltype(_impl_.mac_tx_retry_){0}
    , decltype(_impl_.mac_rx_data_){0}
    , decltype(_impl_.mac_rx_data_poll_){0}
    , decltype(_impl_.mac_rx_beacon_){0}
    , decltype(_impl_.mac_rx_beacon_req_){0}
    , decltype(_impl_.mac_rx_other_pkt_){0}
    , decltype(_impl_.mac_rx_filter_whitelist_){0}
    , decltype(_impl_.mac_rx_filter_dest_addr_){0}
    , decltype(_impl_.mac_tx_fail_cca_){0}
    , decltype(_impl_.mac_rx_fail_decrypt_){0}
    , decltype(_impl_.mac_rx_fail_no_frame_){0}
    , decltype(_impl_.mac_rx_fail_unknown_neighbor_){0}
    , decltype(_impl_.mac_rx_fail_invalid_src_addr_){0}
    , decltype(_impl_.mac_rx_fail_fcs_){0}
    , decltype(_impl_.mac_rx_fail_other_){0}
    , decltype(_impl_.ip_tx_success_){0}
    , decltype(_impl_.ip_rx_success_){0}
    , decltype(_impl_.ip_tx_failure_){0}
    , decltype(_impl_.ip_rx_failure_){0}
    , decltype(_impl_.node_type_){0u}
    , decltype(_impl_.channel_){0u}
    , decltype(_impl_.radio_tx_power_){0}
    , decltype(_impl_.mac_cca_fail_rate_){0}
  };
}

TelemetryData_WpanStats::~TelemetryData_WpanStats() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.WpanStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_WpanStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_WpanStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_WpanStats::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.WpanStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.phy_rx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mac_tx_no_ack_req_) -
        reinterpret_cast<char*>(&_impl_.phy_rx_)) + sizeof(_impl_.mac_tx_no_ack_req_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.mac_tx_acked_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mac_rx_data_) -
        reinterpret_cast<char*>(&_impl_.mac_tx_acked_)) + sizeof(_impl_.mac_rx_data_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.mac_rx_data_poll_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mac_rx_fail_decrypt_) -
        reinterpret_cast<char*>(&_impl_.mac_rx_data_poll_)) + sizeof(_impl_.mac_rx_fail_decrypt_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.mac_rx_fail_no_frame_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ip_tx_failure_) -
        reinterpret_cast<char*>(&_impl_.mac_rx_fail_no_frame_)) + sizeof(_impl_.ip_tx_failure_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.ip_rx_failure_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mac_cca_fail_rate_) -
        reinterpret_cast<char*>(&_impl_.ip_rx_failure_)) + sizeof(_impl_.mac_cca_fail_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_WpanStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 phy_rx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_phy_rx(&_impl_._has_bits_);
          _impl_.phy_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 phy_tx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_phy_tx(&_impl_._has_bits_);
          _impl_.phy_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_unicast_rx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mac_unicast_rx(&_impl_._has_bits_);
          _impl_.mac_unicast_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_unicast_tx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mac_unicast_tx(&_impl_._has_bits_);
          _impl_.mac_unicast_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_broadcast_rx = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mac_broadcast_rx(&_impl_._has_bits_);
          _impl_.mac_broadcast_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_broadcast_tx = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mac_broadcast_tx(&_impl_._has_bits_);
          _impl_.mac_broadcast_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_ack_req = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mac_tx_ack_req(&_impl_._has_bits_);
          _impl_.mac_tx_ack_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_no_ack_req = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_mac_tx_no_ack_req(&_impl_._has_bits_);
          _impl_.mac_tx_no_ack_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_acked = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_mac_tx_acked(&_impl_._has_bits_);
          _impl_.mac_tx_acked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_data = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_mac_tx_data(&_impl_._has_bits_);
          _impl_.mac_tx_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_data_poll = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_mac_tx_data_poll(&_impl_._has_bits_);
          _impl_.mac_tx_data_poll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_beacon = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mac_tx_beacon(&_impl_._has_bits_);
          _impl_.mac_tx_beacon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_beacon_req = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_mac_tx_beacon_req(&_impl_._has_bits_);
          _impl_.mac_tx_beacon_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_other_pkt = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_mac_tx_other_pkt(&_impl_._has_bits_);
          _impl_.mac_tx_other_pkt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_retry = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_mac_tx_retry(&_impl_._has_bits_);
          _impl_.mac_tx_retry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_data = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_mac_rx_data(&_impl_._has_bits_);
          _impl_.mac_rx_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_data_poll = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_mac_rx_data_poll(&_impl_._has_bits_);
          _impl_.mac_rx_data_poll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_beacon = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_mac_rx_beacon(&_impl_._has_bits_);
          _impl_.mac_rx_beacon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_beacon_req = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_mac_rx_beacon_req(&_impl_._has_bits_);
          _impl_.mac_rx_beacon_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_other_pkt = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_mac_rx_other_pkt(&_impl_._has_bits_);
          _impl_.mac_rx_other_pkt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_filter_whitelist = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_mac_rx_filter_whitelist(&_impl_._has_bits_);
          _impl_.mac_rx_filter_whitelist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_filter_dest_addr = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_mac_rx_filter_dest_addr(&_impl_._has_bits_);
          _impl_.mac_rx_filter_dest_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_tx_fail_cca = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_mac_tx_fail_cca(&_impl_._has_bits_);
          _impl_.mac_tx_fail_cca_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_decrypt = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_mac_rx_fail_decrypt(&_impl_._has_bits_);
          _impl_.mac_rx_fail_decrypt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_no_frame = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_mac_rx_fail_no_frame(&_impl_._has_bits_);
          _impl_.mac_rx_fail_no_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_unknown_neighbor = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_mac_rx_fail_unknown_neighbor(&_impl_._has_bits_);
          _impl_.mac_rx_fail_unknown_neighbor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_invalid_src_addr = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_mac_rx_fail_invalid_src_addr(&_impl_._has_bits_);
          _impl_.mac_rx_fail_invalid_src_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_fcs = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_mac_rx_fail_fcs(&_impl_._has_bits_);
          _impl_.mac_rx_fail_fcs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mac_rx_fail_other = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_mac_rx_fail_other(&_impl_._has_bits_);
          _impl_.mac_rx_fail_other_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ip_tx_success = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_ip_tx_success(&_impl_._has_bits_);
          _impl_.ip_tx_success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ip_rx_success = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_ip_rx_success(&_impl_._has_bits_);
          _impl_.ip_rx_success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ip_tx_failure = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_ip_tx_failure(&_impl_._has_bits_);
          _impl_.ip_tx_failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ip_rx_failure = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ip_rx_failure(&_impl_._has_bits_);
          _impl_.ip_rx_failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_type = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_type(&_impl_._has_bits_);
          _impl_.node_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 channel = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_channel(&_impl_._has_bits_);
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 radio_tx_power = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_radio_tx_power(&_impl_._has_bits_);
          _impl_.radio_tx_power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float mac_cca_fail_rate = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_mac_cca_fail_rate(&_impl_._has_bits_);
          _impl_.mac_cca_fail_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_WpanStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.WpanStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 phy_rx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_phy_rx(), target);
  }

  // optional int32 phy_tx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_phy_tx(), target);
  }

  // optional int32 mac_unicast_rx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mac_unicast_rx(), target);
  }

  // optional int32 mac_unicast_tx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_mac_unicast_tx(), target);
  }

  // optional int32 mac_broadcast_rx = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mac_broadcast_rx(), target);
  }

  // optional int32 mac_broadcast_tx = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_mac_broadcast_tx(), target);
  }

  // optional int32 mac_tx_ack_req = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_mac_tx_ack_req(), target);
  }

  // optional int32 mac_tx_no_ack_req = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_mac_tx_no_ack_req(), target);
  }

  // optional int32 mac_tx_acked = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_mac_tx_acked(), target);
  }

  // optional int32 mac_tx_data = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_mac_tx_data(), target);
  }

  // optional int32 mac_tx_data_poll = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_mac_tx_data_poll(), target);
  }

  // optional int32 mac_tx_beacon = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_mac_tx_beacon(), target);
  }

  // optional int32 mac_tx_beacon_req = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_mac_tx_beacon_req(), target);
  }

  // optional int32 mac_tx_other_pkt = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_mac_tx_other_pkt(), target);
  }

  // optional int32 mac_tx_retry = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_mac_tx_retry(), target);
  }

  // optional int32 mac_rx_data = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_mac_rx_data(), target);
  }

  // optional int32 mac_rx_data_poll = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_mac_rx_data_poll(), target);
  }

  // optional int32 mac_rx_beacon = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_mac_rx_beacon(), target);
  }

  // optional int32 mac_rx_beacon_req = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_mac_rx_beacon_req(), target);
  }

  // optional int32 mac_rx_other_pkt = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_mac_rx_other_pkt(), target);
  }

  // optional int32 mac_rx_filter_whitelist = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_mac_rx_filter_whitelist(), target);
  }

  // optional int32 mac_rx_filter_dest_addr = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(22, this->_internal_mac_rx_filter_dest_addr(), target);
  }

  // optional int32 mac_tx_fail_cca = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(23, this->_internal_mac_tx_fail_cca(), target);
  }

  // optional int32 mac_rx_fail_decrypt = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_mac_rx_fail_decrypt(), target);
  }

  // optional int32 mac_rx_fail_no_frame = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_mac_rx_fail_no_frame(), target);
  }

  // optional int32 mac_rx_fail_unknown_neighbor = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_mac_rx_fail_unknown_neighbor(), target);
  }

  // optional int32 mac_rx_fail_invalid_src_addr = 27;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(27, this->_internal_mac_rx_fail_invalid_src_addr(), target);
  }

  // optional int32 mac_rx_fail_fcs = 28;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(28, this->_internal_mac_rx_fail_fcs(), target);
  }

  // optional int32 mac_rx_fail_other = 29;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_mac_rx_fail_other(), target);
  }

  // optional int32 ip_tx_success = 30;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_ip_tx_success(), target);
  }

  // optional int32 ip_rx_success = 31;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(31, this->_internal_ip_rx_success(), target);
  }

  // optional int32 ip_tx_failure = 32;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(32, this->_internal_ip_tx_failure(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 ip_rx_failure = 33;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(33, this->_internal_ip_rx_failure(), target);
  }

  // optional uint32 node_type = 34;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_node_type(), target);
  }

  // optional uint32 channel = 35;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_channel(), target);
  }

  // optional int32 radio_tx_power = 36;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(36, this->_internal_radio_tx_power(), target);
  }

  // optional float mac_cca_fail_rate = 37;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_mac_cca_fail_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.WpanStats)
  return target;
}

size_t TelemetryData_WpanStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.WpanStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 phy_rx = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_phy_rx());
    }

    // optional int32 phy_tx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_phy_tx());
    }

    // optional int32 mac_unicast_rx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_unicast_rx());
    }

    // optional int32 mac_unicast_tx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_unicast_tx());
    }

    // optional int32 mac_broadcast_rx = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_broadcast_rx());
    }

    // optional int32 mac_broadcast_tx = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_broadcast_tx());
    }

    // optional int32 mac_tx_ack_req = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_ack_req());
    }

    // optional int32 mac_tx_no_ack_req = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_no_ack_req());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 mac_tx_acked = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_acked());
    }

    // optional int32 mac_tx_data = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_data());
    }

    // optional int32 mac_tx_data_poll = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_data_poll());
    }

    // optional int32 mac_tx_beacon = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_beacon());
    }

    // optional int32 mac_tx_beacon_req = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_beacon_req());
    }

    // optional int32 mac_tx_other_pkt = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_other_pkt());
    }

    // optional int32 mac_tx_retry = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mac_tx_retry());
    }

    // optional int32 mac_rx_data = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_data());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 mac_rx_data_poll = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_data_poll());
    }

    // optional int32 mac_rx_beacon = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_beacon());
    }

    // optional int32 mac_rx_beacon_req = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_beacon_req());
    }

    // optional int32 mac_rx_other_pkt = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_other_pkt());
    }

    // optional int32 mac_rx_filter_whitelist = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_filter_whitelist());
    }

    // optional int32 mac_rx_filter_dest_addr = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_filter_dest_addr());
    }

    // optional int32 mac_tx_fail_cca = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_tx_fail_cca());
    }

    // optional int32 mac_rx_fail_decrypt = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_decrypt());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 mac_rx_fail_no_frame = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_no_frame());
    }

    // optional int32 mac_rx_fail_unknown_neighbor = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_unknown_neighbor());
    }

    // optional int32 mac_rx_fail_invalid_src_addr = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_invalid_src_addr());
    }

    // optional int32 mac_rx_fail_fcs = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_fcs());
    }

    // optional int32 mac_rx_fail_other = 29;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mac_rx_fail_other());
    }

    // optional int32 ip_tx_success = 30;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ip_tx_success());
    }

    // optional int32 ip_rx_success = 31;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ip_rx_success());
    }

    // optional int32 ip_tx_failure = 32;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ip_tx_failure());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 ip_rx_failure = 33;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ip_rx_failure());
    }

    // optional uint32 node_type = 34;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_node_type());
    }

    // optional uint32 channel = 35;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_channel());
    }

    // optional int32 radio_tx_power = 36;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_radio_tx_power());
    }

    // optional float mac_cca_fail_rate = 37;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_WpanStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_WpanStats*>(
      &from));
}

void TelemetryData_WpanStats::MergeFrom(const TelemetryData_WpanStats& from) {
  TelemetryData_WpanStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.WpanStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.phy_rx_ = from._impl_.phy_rx_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.phy_tx_ = from._impl_.phy_tx_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mac_unicast_rx_ = from._impl_.mac_unicast_rx_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mac_unicast_tx_ = from._impl_.mac_unicast_tx_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mac_broadcast_rx_ = from._impl_.mac_broadcast_rx_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mac_broadcast_tx_ = from._impl_.mac_broadcast_tx_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mac_tx_ack_req_ = from._impl_.mac_tx_ack_req_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.mac_tx_no_ack_req_ = from._impl_.mac_tx_no_ack_req_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.mac_tx_acked_ = from._impl_.mac_tx_acked_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.mac_tx_data_ = from._impl_.mac_tx_data_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.mac_tx_data_poll_ = from._impl_.mac_tx_data_poll_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.mac_tx_beacon_ = from._impl_.mac_tx_beacon_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.mac_tx_beacon_req_ = from._impl_.mac_tx_beacon_req_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.mac_tx_other_pkt_ = from._impl_.mac_tx_other_pkt_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.mac_tx_retry_ = from._impl_.mac_tx_retry_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.mac_rx_data_ = from._impl_.mac_rx_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.mac_rx_data_poll_ = from._impl_.mac_rx_data_poll_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.mac_rx_beacon_ = from._impl_.mac_rx_beacon_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.mac_rx_beacon_req_ = from._impl_.mac_rx_beacon_req_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.mac_rx_other_pkt_ = from._impl_.mac_rx_other_pkt_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.mac_rx_filter_whitelist_ = from._impl_.mac_rx_filter_whitelist_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.mac_rx_filter_dest_addr_ = from._impl_.mac_rx_filter_dest_addr_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.mac_tx_fail_cca_ = from._impl_.mac_tx_fail_cca_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.mac_rx_fail_decrypt_ = from._impl_.mac_rx_fail_decrypt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.mac_rx_fail_no_frame_ = from._impl_.mac_rx_fail_no_frame_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.mac_rx_fail_unknown_neighbor_ = from._impl_.mac_rx_fail_unknown_neighbor_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.mac_rx_fail_invalid_src_addr_ = from._impl_.mac_rx_fail_invalid_src_addr_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.mac_rx_fail_fcs_ = from._impl_.mac_rx_fail_fcs_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.mac_rx_fail_other_ = from._impl_.mac_rx_fail_other_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.ip_tx_success_ = from._impl_.ip_tx_success_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.ip_rx_success_ = from._impl_.ip_rx_success_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.ip_tx_failure_ = from._impl_.ip_tx_failure_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ip_rx_failure_ = from._impl_.ip_rx_failure_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_type_ = from._impl_.node_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.channel_ = from._impl_.channel_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.radio_tx_power_ = from._impl_.radio_tx_power_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mac_cca_fail_rate_ = from._impl_.mac_cca_fail_rate_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_WpanStats::CopyFrom(const TelemetryData_WpanStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.WpanStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_WpanStats::IsInitialized() const {
  return true;
}

void TelemetryData_WpanStats::InternalSwap(TelemetryData_WpanStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_WpanStats, _impl_.mac_cca_fail_rate_)
      + sizeof(TelemetryData_WpanStats::_impl_.mac_cca_fail_rate_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_WpanStats, _impl_.phy_rx_)>(
          reinterpret_cast<char*>(&_impl_.phy_rx_),
          reinterpret_cast<char*>(&other->_impl_.phy_rx_));
}

std::string TelemetryData_WpanStats::GetTypeName() const {
  return "threadnetwork.TelemetryData.WpanStats";
}


// ===================================================================

class TelemetryData_WpanTopoFull::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_WpanTopoFull>()._impl_._has_bits_);
  static void set_has_rloc16(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_router_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_leader_router_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leader_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leader_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_leader_local_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_network_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_data_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_stable_network_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stable_network_data_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_preferred_router_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_partition_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_child_table_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_neighbor_table_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_instant_rssi(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_extended_pan_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

TelemetryData_WpanTopoFull::TelemetryData_WpanTopoFull(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.WpanTopoFull)
}
TelemetryData_WpanTopoFull::TelemetryData_WpanTopoFull(const TelemetryData_WpanTopoFull& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_WpanTopoFull* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leader_address_){}
    , decltype(_impl_.network_data_){}
    , decltype(_impl_.stable_network_data_){}
    , decltype(_impl_.rloc16_){}
    , decltype(_impl_.router_id_){}
    , decltype(_impl_.leader_router_id_){}
    , decltype(_impl_.leader_weight_){}
    , decltype(_impl_.leader_local_weight_){}
    , decltype(_impl_.network_data_version_){}
    , decltype(_impl_.stable_network_data_version_){}
    , decltype(_impl_.preferred_router_id_){}
    , decltype(_impl_.partition_id_){}
    , decltype(_impl_.child_table_size_){}
    , decltype(_impl_.neighbor_table_size_){}
    , decltype(_impl_.instant_rssi_){}
    , decltype(_impl_.extended_pan_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.leader_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.leader_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_leader_address()) {
    _this->_impl_.leader_address_.Set(from._internal_leader_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.network_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_network_data()) {
    _this->_impl_.network_data_.Set(from._internal_network_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.stable_network_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stable_network_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stable_network_data()) {
    _this->_impl_.stable_network_data_.Set(from._internal_stable_network_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.rloc16_, &from._impl_.rloc16_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.extended_pan_id_) -
    reinterpret_cast<char*>(&_impl_.rloc16_)) + sizeof(_impl_.extended_pan_id_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.WpanTopoFull)
}

inline void TelemetryData_WpanTopoFull::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leader_address_){}
    , decltype(_impl_.network_data_){}
    , decltype(_impl_.stable_network_data_){}
    , decltype(_impl_.rloc16_){0u}
    , decltype(_impl_.router_id_){0u}
    , decltype(_impl_.leader_router_id_){0u}
    , decltype(_impl_.leader_weight_){0u}
    , decltype(_impl_.leader_local_weight_){0u}
    , decltype(_impl_.network_data_version_){0u}
    , decltype(_impl_.stable_network_data_version_){0u}
    , decltype(_impl_.preferred_router_id_){0u}
    , decltype(_impl_.partition_id_){0u}
    , decltype(_impl_.child_table_size_){0u}
    , decltype(_impl_.neighbor_table_size_){0u}
    , decltype(_impl_.instant_rssi_){0}
    , decltype(_impl_.extended_pan_id_){uint64_t{0u}}
  };
  _impl_.leader_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.leader_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.network_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stable_network_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stable_network_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TelemetryData_WpanTopoFull::~TelemetryData_WpanTopoFull() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.WpanTopoFull)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_WpanTopoFull::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.leader_address_.Destroy();
  _impl_.network_data_.Destroy();
  _impl_.stable_network_data_.Destroy();
}

void TelemetryData_WpanTopoFull::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_WpanTopoFull::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.WpanTopoFull)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.leader_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.network_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.stable_network_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.rloc16_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.leader_local_weight_) -
        reinterpret_cast<char*>(&_impl_.rloc16_)) + sizeof(_impl_.leader_local_weight_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.network_data_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.extended_pan_id_) -
        reinterpret_cast<char*>(&_impl_.network_data_version_)) + sizeof(_impl_.extended_pan_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_WpanTopoFull::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rloc16 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rloc16(&has_bits);
          _impl_.rloc16_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 router_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_router_id(&has_bits);
          _impl_.router_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leader_router_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_leader_router_id(&has_bits);
          _impl_.leader_router_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes leader_address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_leader_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leader_weight = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_leader_weight(&has_bits);
          _impl_.leader_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leader_local_weight = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_leader_local_weight(&has_bits);
          _impl_.leader_local_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes network_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_network_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 network_data_version = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_network_data_version(&has_bits);
          _impl_.network_data_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes stable_network_data = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_stable_network_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stable_network_data_version = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_stable_network_data_version(&has_bits);
          _impl_.stable_network_data_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preferred_router_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_preferred_router_id(&has_bits);
          _impl_.preferred_router_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partition_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_partition_id(&has_bits);
          _impl_.partition_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 child_table_size = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_child_table_size(&has_bits);
          _impl_.child_table_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 neighbor_table_size = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_neighbor_table_size(&has_bits);
          _impl_.neighbor_table_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 instant_rssi = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_instant_rssi(&has_bits);
          _impl_.instant_rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 extended_pan_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_extended_pan_id(&has_bits);
          _impl_.extended_pan_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_WpanTopoFull::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.WpanTopoFull)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rloc16 = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rloc16(), target);
  }

  // optional uint32 router_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_router_id(), target);
  }

  // optional uint32 leader_router_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_leader_router_id(), target);
  }

  // optional bytes leader_address = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_leader_address(), target);
  }

  // optional uint32 leader_weight = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_leader_weight(), target);
  }

  // optional uint32 leader_local_weight = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_leader_local_weight(), target);
  }

  // optional bytes network_data = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_network_data(), target);
  }

  // optional uint32 network_data_version = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_network_data_version(), target);
  }

  // optional bytes stable_network_data = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_stable_network_data(), target);
  }

  // optional uint32 stable_network_data_version = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_stable_network_data_version(), target);
  }

  // optional uint32 preferred_router_id = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_preferred_router_id(), target);
  }

  // optional uint32 partition_id = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_partition_id(), target);
  }

  // optional uint32 child_table_size = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_child_table_size(), target);
  }

  // optional uint32 neighbor_table_size = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_neighbor_table_size(), target);
  }

  // optional int32 instant_rssi = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_instant_rssi(), target);
  }

  // optional uint64 extended_pan_id = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_extended_pan_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.WpanTopoFull)
  return target;
}

size_t TelemetryData_WpanTopoFull::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.WpanTopoFull)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes leader_address = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_leader_address());
    }

    // optional bytes network_data = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_network_data());
    }

    // optional bytes stable_network_data = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_stable_network_data());
    }

    // optional uint32 rloc16 = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rloc16());
    }

    // optional uint32 router_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_router_id());
    }

    // optional uint32 leader_router_id = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leader_router_id());
    }

    // optional uint32 leader_weight = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leader_weight());
    }

    // optional uint32 leader_local_weight = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leader_local_weight());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 network_data_version = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_network_data_version());
    }

    // optional uint32 stable_network_data_version = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stable_network_data_version());
    }

    // optional uint32 preferred_router_id = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preferred_router_id());
    }

    // optional uint32 partition_id = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partition_id());
    }

    // optional uint32 child_table_size = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_child_table_size());
    }

    // optional uint32 neighbor_table_size = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_neighbor_table_size());
    }

    // optional int32 instant_rssi = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_instant_rssi());
    }

    // optional uint64 extended_pan_id = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_extended_pan_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_WpanTopoFull::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_WpanTopoFull*>(
      &from));
}

void TelemetryData_WpanTopoFull::MergeFrom(const TelemetryData_WpanTopoFull& from) {
  TelemetryData_WpanTopoFull* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.WpanTopoFull)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_leader_address(from._internal_leader_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_network_data(from._internal_network_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_stable_network_data(from._internal_stable_network_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rloc16_ = from._impl_.rloc16_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.router_id_ = from._impl_.router_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.leader_router_id_ = from._impl_.leader_router_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.leader_weight_ = from._impl_.leader_weight_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.leader_local_weight_ = from._impl_.leader_local_weight_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.network_data_version_ = from._impl_.network_data_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.stable_network_data_version_ = from._impl_.stable_network_data_version_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.preferred_router_id_ = from._impl_.preferred_router_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.partition_id_ = from._impl_.partition_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.child_table_size_ = from._impl_.child_table_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.neighbor_table_size_ = from._impl_.neighbor_table_size_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.instant_rssi_ = from._impl_.instant_rssi_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.extended_pan_id_ = from._impl_.extended_pan_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_WpanTopoFull::CopyFrom(const TelemetryData_WpanTopoFull& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.WpanTopoFull)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_WpanTopoFull::IsInitialized() const {
  return true;
}

void TelemetryData_WpanTopoFull::InternalSwap(TelemetryData_WpanTopoFull* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.leader_address_, lhs_arena,
      &other->_impl_.leader_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.network_data_, lhs_arena,
      &other->_impl_.network_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stable_network_data_, lhs_arena,
      &other->_impl_.stable_network_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_WpanTopoFull, _impl_.extended_pan_id_)
      + sizeof(TelemetryData_WpanTopoFull::_impl_.extended_pan_id_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_WpanTopoFull, _impl_.rloc16_)>(
          reinterpret_cast<char*>(&_impl_.rloc16_),
          reinterpret_cast<char*>(&other->_impl_.rloc16_));
}

std::string TelemetryData_WpanTopoFull::GetTypeName() const {
  return "threadnetwork.TelemetryData.WpanTopoFull";
}


// ===================================================================

class TelemetryData_TopoEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_TopoEntry>()._impl_._has_bits_);
  static void set_has_rloc16(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_link_quality_in(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_average_rssi(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::threadnetwork::TelemetryData_Duration& age(const TelemetryData_TopoEntry* msg);
  static void set_has_age(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rx_on_when_idle(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_full_function(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_secure_data_request(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_full_network_data(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_last_rssi(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_link_frame_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mle_frame_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_child(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::threadnetwork::TelemetryData_Duration& timeout(const TelemetryData_TopoEntry* msg);
  static void set_has_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_data_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_mac_frame_error_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_ip_message_error_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

const ::threadnetwork::TelemetryData_Duration&
TelemetryData_TopoEntry::_Internal::age(const TelemetryData_TopoEntry* msg) {
  return *msg->_impl_.age_;
}
const ::threadnetwork::TelemetryData_Duration&
TelemetryData_TopoEntry::_Internal::timeout(const TelemetryData_TopoEntry* msg) {
  return *msg->_impl_.timeout_;
}
TelemetryData_TopoEntry::TelemetryData_TopoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.TopoEntry)
}
TelemetryData_TopoEntry::TelemetryData_TopoEntry(const TelemetryData_TopoEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_TopoEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.age_){nullptr}
    , decltype(_impl_.timeout_){nullptr}
    , decltype(_impl_.rloc16_){}
    , decltype(_impl_.link_quality_in_){}
    , decltype(_impl_.average_rssi_){}
    , decltype(_impl_.rx_on_when_idle_){}
    , decltype(_impl_.full_function_){}
    , decltype(_impl_.secure_data_request_){}
    , decltype(_impl_.full_network_data_){}
    , decltype(_impl_.last_rssi_){}
    , decltype(_impl_.link_frame_counter_){}
    , decltype(_impl_.mle_frame_counter_){}
    , decltype(_impl_.is_child_){}
    , decltype(_impl_.network_data_version_){}
    , decltype(_impl_.mac_frame_error_rate_){}
    , decltype(_impl_.ip_message_error_rate_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_age()) {
    _this->_impl_.age_ = new ::threadnetwork::TelemetryData_Duration(*from._impl_.age_);
  }
  if (from._internal_has_timeout()) {
    _this->_impl_.timeout_ = new ::threadnetwork::TelemetryData_Duration(*from._impl_.timeout_);
  }
  ::memcpy(&_impl_.rloc16_, &from._impl_.rloc16_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.rloc16_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.TopoEntry)
}

inline void TelemetryData_TopoEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.age_){nullptr}
    , decltype(_impl_.timeout_){nullptr}
    , decltype(_impl_.rloc16_){0u}
    , decltype(_impl_.link_quality_in_){0u}
    , decltype(_impl_.average_rssi_){0}
    , decltype(_impl_.rx_on_when_idle_){false}
    , decltype(_impl_.full_function_){false}
    , decltype(_impl_.secure_data_request_){false}
    , decltype(_impl_.full_network_data_){false}
    , decltype(_impl_.last_rssi_){0}
    , decltype(_impl_.link_frame_counter_){0u}
    , decltype(_impl_.mle_frame_counter_){0u}
    , decltype(_impl_.is_child_){false}
    , decltype(_impl_.network_data_version_){0u}
    , decltype(_impl_.mac_frame_error_rate_){0}
    , decltype(_impl_.ip_message_error_rate_){0}
    , decltype(_impl_.version_){0}
  };
}

TelemetryData_TopoEntry::~TelemetryData_TopoEntry() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.TopoEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_TopoEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.age_;
  if (this != internal_default_instance()) delete _impl_.timeout_;
}

void TelemetryData_TopoEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_TopoEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.TopoEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.age_ != nullptr);
      _impl_.age_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.timeout_ != nullptr);
      _impl_.timeout_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.rloc16_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.secure_data_request_) -
        reinterpret_cast<char*>(&_impl_.rloc16_)) + sizeof(_impl_.secure_data_request_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.full_network_data_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ip_message_error_rate_) -
        reinterpret_cast<char*>(&_impl_.full_network_data_)) + sizeof(_impl_.ip_message_error_rate_));
  }
  _impl_.version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_TopoEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rloc16 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rloc16(&has_bits);
          _impl_.rloc16_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_quality_in = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_link_quality_in(&has_bits);
          _impl_.link_quality_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 average_rssi = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_average_rssi(&has_bits);
          _impl_.average_rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Duration age = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_age(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rx_on_when_idle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_rx_on_when_idle(&has_bits);
          _impl_.rx_on_when_idle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool full_function = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_full_function(&has_bits);
          _impl_.full_function_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool secure_data_request = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_secure_data_request(&has_bits);
          _impl_.secure_data_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool full_network_data = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_full_network_data(&has_bits);
          _impl_.full_network_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_rssi = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_last_rssi(&has_bits);
          _impl_.last_rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_frame_counter = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_link_frame_counter(&has_bits);
          _impl_.link_frame_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mle_frame_counter = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mle_frame_counter(&has_bits);
          _impl_.mle_frame_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_child = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_child(&has_bits);
          _impl_.is_child_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Duration timeout = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 network_data_version = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_network_data_version(&has_bits);
          _impl_.network_data_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float mac_frame_error_rate = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_mac_frame_error_rate(&has_bits);
          _impl_.mac_frame_error_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float ip_message_error_rate = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_ip_message_error_rate(&has_bits);
          _impl_.ip_message_error_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_TopoEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.TopoEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rloc16 = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rloc16(), target);
  }

  // optional uint32 link_quality_in = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_link_quality_in(), target);
  }

  // optional int32 average_rssi = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_average_rssi(), target);
  }

  // optional .threadnetwork.TelemetryData.Duration age = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::age(this),
        _Internal::age(this).GetCachedSize(), target, stream);
  }

  // optional bool rx_on_when_idle = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_rx_on_when_idle(), target);
  }

  // optional bool full_function = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_full_function(), target);
  }

  // optional bool secure_data_request = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_secure_data_request(), target);
  }

  // optional bool full_network_data = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_full_network_data(), target);
  }

  // optional int32 last_rssi = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_last_rssi(), target);
  }

  // optional uint32 link_frame_counter = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_link_frame_counter(), target);
  }

  // optional uint32 mle_frame_counter = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_mle_frame_counter(), target);
  }

  // optional bool is_child = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_child(), target);
  }

  // optional .threadnetwork.TelemetryData.Duration timeout = 14;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::timeout(this),
        _Internal::timeout(this).GetCachedSize(), target, stream);
  }

  // optional uint32 network_data_version = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_network_data_version(), target);
  }

  // optional float mac_frame_error_rate = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_mac_frame_error_rate(), target);
  }

  // optional float ip_message_error_rate = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_ip_message_error_rate(), target);
  }

  // optional int32 version = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.TopoEntry)
  return target;
}

size_t TelemetryData_TopoEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.TopoEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .threadnetwork.TelemetryData.Duration age = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.age_);
    }

    // optional .threadnetwork.TelemetryData.Duration timeout = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timeout_);
    }

    // optional uint32 rloc16 = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rloc16());
    }

    // optional uint32 link_quality_in = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_quality_in());
    }

    // optional int32 average_rssi = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_average_rssi());
    }

    // optional bool rx_on_when_idle = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool full_function = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool secure_data_request = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool full_network_data = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 last_rssi = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_last_rssi());
    }

    // optional uint32 link_frame_counter = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_frame_counter());
    }

    // optional uint32 mle_frame_counter = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mle_frame_counter());
    }

    // optional bool is_child = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 network_data_version = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_network_data_version());
    }

    // optional float mac_frame_error_rate = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float ip_message_error_rate = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  // optional int32 version = 18;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_TopoEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_TopoEntry*>(
      &from));
}

void TelemetryData_TopoEntry::MergeFrom(const TelemetryData_TopoEntry& from) {
  TelemetryData_TopoEntry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.TopoEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_age()->::threadnetwork::TelemetryData_Duration::MergeFrom(
          from._internal_age());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timeout()->::threadnetwork::TelemetryData_Duration::MergeFrom(
          from._internal_timeout());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rloc16_ = from._impl_.rloc16_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.link_quality_in_ = from._impl_.link_quality_in_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.average_rssi_ = from._impl_.average_rssi_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.rx_on_when_idle_ = from._impl_.rx_on_when_idle_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.full_function_ = from._impl_.full_function_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.secure_data_request_ = from._impl_.secure_data_request_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.full_network_data_ = from._impl_.full_network_data_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.last_rssi_ = from._impl_.last_rssi_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.link_frame_counter_ = from._impl_.link_frame_counter_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.mle_frame_counter_ = from._impl_.mle_frame_counter_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_child_ = from._impl_.is_child_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.network_data_version_ = from._impl_.network_data_version_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.mac_frame_error_rate_ = from._impl_.mac_frame_error_rate_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.ip_message_error_rate_ = from._impl_.ip_message_error_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_TopoEntry::CopyFrom(const TelemetryData_TopoEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.TopoEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_TopoEntry::IsInitialized() const {
  return true;
}

void TelemetryData_TopoEntry::InternalSwap(TelemetryData_TopoEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_TopoEntry, _impl_.version_)
      + sizeof(TelemetryData_TopoEntry::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_TopoEntry, _impl_.age_)>(
          reinterpret_cast<char*>(&_impl_.age_),
          reinterpret_cast<char*>(&other->_impl_.age_));
}

std::string TelemetryData_TopoEntry::GetTypeName() const {
  return "threadnetwork.TelemetryData.TopoEntry";
}


// ===================================================================

class TelemetryData_PacketsAndBytes::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_PacketsAndBytes>()._impl_._has_bits_);
  static void set_has_packet_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_byte_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TelemetryData_PacketsAndBytes::TelemetryData_PacketsAndBytes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.PacketsAndBytes)
}
TelemetryData_PacketsAndBytes::TelemetryData_PacketsAndBytes(const TelemetryData_PacketsAndBytes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_PacketsAndBytes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_count_){}
    , decltype(_impl_.byte_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.packet_count_, &from._impl_.packet_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.byte_count_) -
    reinterpret_cast<char*>(&_impl_.packet_count_)) + sizeof(_impl_.byte_count_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.PacketsAndBytes)
}

inline void TelemetryData_PacketsAndBytes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_count_){int64_t{0}}
    , decltype(_impl_.byte_count_){int64_t{0}}
  };
}

TelemetryData_PacketsAndBytes::~TelemetryData_PacketsAndBytes() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.PacketsAndBytes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_PacketsAndBytes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_PacketsAndBytes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_PacketsAndBytes::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.PacketsAndBytes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.packet_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.byte_count_) -
        reinterpret_cast<char*>(&_impl_.packet_count_)) + sizeof(_impl_.byte_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_PacketsAndBytes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 packet_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_packet_count(&has_bits);
          _impl_.packet_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 byte_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_byte_count(&has_bits);
          _impl_.byte_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_PacketsAndBytes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.PacketsAndBytes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 packet_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_packet_count(), target);
  }

  // optional int64 byte_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_byte_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.PacketsAndBytes)
  return target;
}

size_t TelemetryData_PacketsAndBytes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.PacketsAndBytes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 packet_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packet_count());
    }

    // optional int64 byte_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_byte_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_PacketsAndBytes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_PacketsAndBytes*>(
      &from));
}

void TelemetryData_PacketsAndBytes::MergeFrom(const TelemetryData_PacketsAndBytes& from) {
  TelemetryData_PacketsAndBytes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.PacketsAndBytes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.packet_count_ = from._impl_.packet_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.byte_count_ = from._impl_.byte_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_PacketsAndBytes::CopyFrom(const TelemetryData_PacketsAndBytes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.PacketsAndBytes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_PacketsAndBytes::IsInitialized() const {
  return true;
}

void TelemetryData_PacketsAndBytes::InternalSwap(TelemetryData_PacketsAndBytes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_PacketsAndBytes, _impl_.byte_count_)
      + sizeof(TelemetryData_PacketsAndBytes::_impl_.byte_count_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_PacketsAndBytes, _impl_.packet_count_)>(
          reinterpret_cast<char*>(&_impl_.packet_count_),
          reinterpret_cast<char*>(&other->_impl_.packet_count_));
}

std::string TelemetryData_PacketsAndBytes::GetTypeName() const {
  return "threadnetwork.TelemetryData.PacketsAndBytes";
}


// ===================================================================

class TelemetryData_Nat64TrafficCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Nat64TrafficCounters>()._impl_._has_bits_);
  static void set_has_ipv4_to_ipv6_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipv4_to_ipv6_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ipv6_to_ipv4_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ipv6_to_ipv4_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TelemetryData_Nat64TrafficCounters::TelemetryData_Nat64TrafficCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Nat64TrafficCounters)
}
TelemetryData_Nat64TrafficCounters::TelemetryData_Nat64TrafficCounters(const TelemetryData_Nat64TrafficCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Nat64TrafficCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_to_ipv6_packets_){}
    , decltype(_impl_.ipv4_to_ipv6_bytes_){}
    , decltype(_impl_.ipv6_to_ipv4_packets_){}
    , decltype(_impl_.ipv6_to_ipv4_bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ipv4_to_ipv6_packets_, &from._impl_.ipv4_to_ipv6_packets_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ipv6_to_ipv4_bytes_) -
    reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_)) + sizeof(_impl_.ipv6_to_ipv4_bytes_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Nat64TrafficCounters)
}

inline void TelemetryData_Nat64TrafficCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_to_ipv6_packets_){int64_t{0}}
    , decltype(_impl_.ipv4_to_ipv6_bytes_){int64_t{0}}
    , decltype(_impl_.ipv6_to_ipv4_packets_){int64_t{0}}
    , decltype(_impl_.ipv6_to_ipv4_bytes_){int64_t{0}}
  };
}

TelemetryData_Nat64TrafficCounters::~TelemetryData_Nat64TrafficCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Nat64TrafficCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Nat64TrafficCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_Nat64TrafficCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Nat64TrafficCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Nat64TrafficCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.ipv4_to_ipv6_packets_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ipv6_to_ipv4_bytes_) -
        reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_)) + sizeof(_impl_.ipv6_to_ipv4_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Nat64TrafficCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 ipv4_to_ipv6_packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ipv4_to_ipv6_packets(&has_bits);
          _impl_.ipv4_to_ipv6_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ipv4_to_ipv6_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ipv4_to_ipv6_bytes(&has_bits);
          _impl_.ipv4_to_ipv6_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ipv6_to_ipv4_packets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ipv6_to_ipv4_packets(&has_bits);
          _impl_.ipv6_to_ipv4_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ipv6_to_ipv4_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ipv6_to_ipv4_bytes(&has_bits);
          _impl_.ipv6_to_ipv4_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Nat64TrafficCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Nat64TrafficCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 ipv4_to_ipv6_packets = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_ipv4_to_ipv6_packets(), target);
  }

  // optional int64 ipv4_to_ipv6_bytes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_ipv4_to_ipv6_bytes(), target);
  }

  // optional int64 ipv6_to_ipv4_packets = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_ipv6_to_ipv4_packets(), target);
  }

  // optional int64 ipv6_to_ipv4_bytes = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_ipv6_to_ipv4_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Nat64TrafficCounters)
  return target;
}

size_t TelemetryData_Nat64TrafficCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Nat64TrafficCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 ipv4_to_ipv6_packets = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv4_to_ipv6_packets());
    }

    // optional int64 ipv4_to_ipv6_bytes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv4_to_ipv6_bytes());
    }

    // optional int64 ipv6_to_ipv4_packets = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv6_to_ipv4_packets());
    }

    // optional int64 ipv6_to_ipv4_bytes = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv6_to_ipv4_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Nat64TrafficCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Nat64TrafficCounters*>(
      &from));
}

void TelemetryData_Nat64TrafficCounters::MergeFrom(const TelemetryData_Nat64TrafficCounters& from) {
  TelemetryData_Nat64TrafficCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Nat64TrafficCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ipv4_to_ipv6_packets_ = from._impl_.ipv4_to_ipv6_packets_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ipv4_to_ipv6_bytes_ = from._impl_.ipv4_to_ipv6_bytes_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ipv6_to_ipv4_packets_ = from._impl_.ipv6_to_ipv4_packets_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ipv6_to_ipv4_bytes_ = from._impl_.ipv6_to_ipv4_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Nat64TrafficCounters::CopyFrom(const TelemetryData_Nat64TrafficCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Nat64TrafficCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Nat64TrafficCounters::IsInitialized() const {
  return true;
}

void TelemetryData_Nat64TrafficCounters::InternalSwap(TelemetryData_Nat64TrafficCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64TrafficCounters, _impl_.ipv6_to_ipv4_bytes_)
      + sizeof(TelemetryData_Nat64TrafficCounters::_impl_.ipv6_to_ipv4_bytes_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64TrafficCounters, _impl_.ipv4_to_ipv6_packets_)>(
          reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_),
          reinterpret_cast<char*>(&other->_impl_.ipv4_to_ipv6_packets_));
}

std::string TelemetryData_Nat64TrafficCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.Nat64TrafficCounters";
}


// ===================================================================

class TelemetryData_Nat64ProtocolCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Nat64ProtocolCounters>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_Nat64TrafficCounters& tcp(const TelemetryData_Nat64ProtocolCounters* msg);
  static void set_has_tcp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_Nat64TrafficCounters& udp(const TelemetryData_Nat64ProtocolCounters* msg);
  static void set_has_udp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_Nat64TrafficCounters& icmp(const TelemetryData_Nat64ProtocolCounters* msg);
  static void set_has_icmp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::threadnetwork::TelemetryData_Nat64TrafficCounters&
TelemetryData_Nat64ProtocolCounters::_Internal::tcp(const TelemetryData_Nat64ProtocolCounters* msg) {
  return *msg->_impl_.tcp_;
}
const ::threadnetwork::TelemetryData_Nat64TrafficCounters&
TelemetryData_Nat64ProtocolCounters::_Internal::udp(const TelemetryData_Nat64ProtocolCounters* msg) {
  return *msg->_impl_.udp_;
}
const ::threadnetwork::TelemetryData_Nat64TrafficCounters&
TelemetryData_Nat64ProtocolCounters::_Internal::icmp(const TelemetryData_Nat64ProtocolCounters* msg) {
  return *msg->_impl_.icmp_;
}
TelemetryData_Nat64ProtocolCounters::TelemetryData_Nat64ProtocolCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Nat64ProtocolCounters)
}
TelemetryData_Nat64ProtocolCounters::TelemetryData_Nat64ProtocolCounters(const TelemetryData_Nat64ProtocolCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Nat64ProtocolCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.udp_){nullptr}
    , decltype(_impl_.icmp_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tcp()) {
    _this->_impl_.tcp_ = new ::threadnetwork::TelemetryData_Nat64TrafficCounters(*from._impl_.tcp_);
  }
  if (from._internal_has_udp()) {
    _this->_impl_.udp_ = new ::threadnetwork::TelemetryData_Nat64TrafficCounters(*from._impl_.udp_);
  }
  if (from._internal_has_icmp()) {
    _this->_impl_.icmp_ = new ::threadnetwork::TelemetryData_Nat64TrafficCounters(*from._impl_.icmp_);
  }
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Nat64ProtocolCounters)
}

inline void TelemetryData_Nat64ProtocolCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.udp_){nullptr}
    , decltype(_impl_.icmp_){nullptr}
  };
}

TelemetryData_Nat64ProtocolCounters::~TelemetryData_Nat64ProtocolCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Nat64ProtocolCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tcp_;
  if (this != internal_default_instance()) delete _impl_.udp_;
  if (this != internal_default_instance()) delete _impl_.icmp_;
}

void TelemetryData_Nat64ProtocolCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Nat64ProtocolCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.tcp_ != nullptr);
      _impl_.tcp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.udp_ != nullptr);
      _impl_.udp_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.icmp_ != nullptr);
      _impl_.icmp_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Nat64ProtocolCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.Nat64TrafficCounters tcp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64TrafficCounters udp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_udp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64TrafficCounters icmp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_icmp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Nat64ProtocolCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters tcp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tcp(this),
        _Internal::tcp(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters udp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::udp(this),
        _Internal::udp(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters icmp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::icmp(this),
        _Internal::icmp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  return target;
}

size_t TelemetryData_Nat64ProtocolCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .threadnetwork.TelemetryData.Nat64TrafficCounters tcp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tcp_);
    }

    // optional .threadnetwork.TelemetryData.Nat64TrafficCounters udp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.udp_);
    }

    // optional .threadnetwork.TelemetryData.Nat64TrafficCounters icmp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.icmp_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Nat64ProtocolCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Nat64ProtocolCounters*>(
      &from));
}

void TelemetryData_Nat64ProtocolCounters::MergeFrom(const TelemetryData_Nat64ProtocolCounters& from) {
  TelemetryData_Nat64ProtocolCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tcp()->::threadnetwork::TelemetryData_Nat64TrafficCounters::MergeFrom(
          from._internal_tcp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_udp()->::threadnetwork::TelemetryData_Nat64TrafficCounters::MergeFrom(
          from._internal_udp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_icmp()->::threadnetwork::TelemetryData_Nat64TrafficCounters::MergeFrom(
          from._internal_icmp());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Nat64ProtocolCounters::CopyFrom(const TelemetryData_Nat64ProtocolCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Nat64ProtocolCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Nat64ProtocolCounters::IsInitialized() const {
  return true;
}

void TelemetryData_Nat64ProtocolCounters::InternalSwap(TelemetryData_Nat64ProtocolCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64ProtocolCounters, _impl_.icmp_)
      + sizeof(TelemetryData_Nat64ProtocolCounters::_impl_.icmp_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64ProtocolCounters, _impl_.tcp_)>(
          reinterpret_cast<char*>(&_impl_.tcp_),
          reinterpret_cast<char*>(&other->_impl_.tcp_));
}

std::string TelemetryData_Nat64ProtocolCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.Nat64ProtocolCounters";
}


// ===================================================================

class TelemetryData_Nat64PacketCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Nat64PacketCounters>()._impl_._has_bits_);
  static void set_has_ipv4_to_ipv6_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipv6_to_ipv4_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TelemetryData_Nat64PacketCounters::TelemetryData_Nat64PacketCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Nat64PacketCounters)
}
TelemetryData_Nat64PacketCounters::TelemetryData_Nat64PacketCounters(const TelemetryData_Nat64PacketCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Nat64PacketCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_to_ipv6_packets_){}
    , decltype(_impl_.ipv6_to_ipv4_packets_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ipv4_to_ipv6_packets_, &from._impl_.ipv4_to_ipv6_packets_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ipv6_to_ipv4_packets_) -
    reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_)) + sizeof(_impl_.ipv6_to_ipv4_packets_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Nat64PacketCounters)
}

inline void TelemetryData_Nat64PacketCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_to_ipv6_packets_){int64_t{0}}
    , decltype(_impl_.ipv6_to_ipv4_packets_){int64_t{0}}
  };
}

TelemetryData_Nat64PacketCounters::~TelemetryData_Nat64PacketCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Nat64PacketCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Nat64PacketCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_Nat64PacketCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Nat64PacketCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Nat64PacketCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ipv4_to_ipv6_packets_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ipv6_to_ipv4_packets_) -
        reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_)) + sizeof(_impl_.ipv6_to_ipv4_packets_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Nat64PacketCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 ipv4_to_ipv6_packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ipv4_to_ipv6_packets(&has_bits);
          _impl_.ipv4_to_ipv6_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ipv6_to_ipv4_packets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ipv6_to_ipv4_packets(&has_bits);
          _impl_.ipv6_to_ipv4_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Nat64PacketCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Nat64PacketCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 ipv4_to_ipv6_packets = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_ipv4_to_ipv6_packets(), target);
  }

  // optional int64 ipv6_to_ipv4_packets = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_ipv6_to_ipv4_packets(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Nat64PacketCounters)
  return target;
}

size_t TelemetryData_Nat64PacketCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Nat64PacketCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 ipv4_to_ipv6_packets = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv4_to_ipv6_packets());
    }

    // optional int64 ipv6_to_ipv4_packets = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipv6_to_ipv4_packets());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Nat64PacketCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Nat64PacketCounters*>(
      &from));
}

void TelemetryData_Nat64PacketCounters::MergeFrom(const TelemetryData_Nat64PacketCounters& from) {
  TelemetryData_Nat64PacketCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Nat64PacketCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ipv4_to_ipv6_packets_ = from._impl_.ipv4_to_ipv6_packets_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ipv6_to_ipv4_packets_ = from._impl_.ipv6_to_ipv4_packets_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Nat64PacketCounters::CopyFrom(const TelemetryData_Nat64PacketCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Nat64PacketCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Nat64PacketCounters::IsInitialized() const {
  return true;
}

void TelemetryData_Nat64PacketCounters::InternalSwap(TelemetryData_Nat64PacketCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64PacketCounters, _impl_.ipv6_to_ipv4_packets_)
      + sizeof(TelemetryData_Nat64PacketCounters::_impl_.ipv6_to_ipv4_packets_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64PacketCounters, _impl_.ipv4_to_ipv6_packets_)>(
          reinterpret_cast<char*>(&_impl_.ipv4_to_ipv6_packets_),
          reinterpret_cast<char*>(&other->_impl_.ipv4_to_ipv6_packets_));
}

std::string TelemetryData_Nat64PacketCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.Nat64PacketCounters";
}


// ===================================================================

class TelemetryData_Nat64ErrorCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Nat64ErrorCounters>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_Nat64PacketCounters& unknown(const TelemetryData_Nat64ErrorCounters* msg);
  static void set_has_unknown(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_Nat64PacketCounters& illegal_packet(const TelemetryData_Nat64ErrorCounters* msg);
  static void set_has_illegal_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_Nat64PacketCounters& unsupported_protocol(const TelemetryData_Nat64ErrorCounters* msg);
  static void set_has_unsupported_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_Nat64PacketCounters& no_mapping(const TelemetryData_Nat64ErrorCounters* msg);
  static void set_has_no_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::threadnetwork::TelemetryData_Nat64PacketCounters&
TelemetryData_Nat64ErrorCounters::_Internal::unknown(const TelemetryData_Nat64ErrorCounters* msg) {
  return *msg->_impl_.unknown_;
}
const ::threadnetwork::TelemetryData_Nat64PacketCounters&
TelemetryData_Nat64ErrorCounters::_Internal::illegal_packet(const TelemetryData_Nat64ErrorCounters* msg) {
  return *msg->_impl_.illegal_packet_;
}
const ::threadnetwork::TelemetryData_Nat64PacketCounters&
TelemetryData_Nat64ErrorCounters::_Internal::unsupported_protocol(const TelemetryData_Nat64ErrorCounters* msg) {
  return *msg->_impl_.unsupported_protocol_;
}
const ::threadnetwork::TelemetryData_Nat64PacketCounters&
TelemetryData_Nat64ErrorCounters::_Internal::no_mapping(const TelemetryData_Nat64ErrorCounters* msg) {
  return *msg->_impl_.no_mapping_;
}
TelemetryData_Nat64ErrorCounters::TelemetryData_Nat64ErrorCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Nat64ErrorCounters)
}
TelemetryData_Nat64ErrorCounters::TelemetryData_Nat64ErrorCounters(const TelemetryData_Nat64ErrorCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Nat64ErrorCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unknown_){nullptr}
    , decltype(_impl_.illegal_packet_){nullptr}
    , decltype(_impl_.unsupported_protocol_){nullptr}
    , decltype(_impl_.no_mapping_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_unknown()) {
    _this->_impl_.unknown_ = new ::threadnetwork::TelemetryData_Nat64PacketCounters(*from._impl_.unknown_);
  }
  if (from._internal_has_illegal_packet()) {
    _this->_impl_.illegal_packet_ = new ::threadnetwork::TelemetryData_Nat64PacketCounters(*from._impl_.illegal_packet_);
  }
  if (from._internal_has_unsupported_protocol()) {
    _this->_impl_.unsupported_protocol_ = new ::threadnetwork::TelemetryData_Nat64PacketCounters(*from._impl_.unsupported_protocol_);
  }
  if (from._internal_has_no_mapping()) {
    _this->_impl_.no_mapping_ = new ::threadnetwork::TelemetryData_Nat64PacketCounters(*from._impl_.no_mapping_);
  }
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Nat64ErrorCounters)
}

inline void TelemetryData_Nat64ErrorCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unknown_){nullptr}
    , decltype(_impl_.illegal_packet_){nullptr}
    , decltype(_impl_.unsupported_protocol_){nullptr}
    , decltype(_impl_.no_mapping_){nullptr}
  };
}

TelemetryData_Nat64ErrorCounters::~TelemetryData_Nat64ErrorCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Nat64ErrorCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Nat64ErrorCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.unknown_;
  if (this != internal_default_instance()) delete _impl_.illegal_packet_;
  if (this != internal_default_instance()) delete _impl_.unsupported_protocol_;
  if (this != internal_default_instance()) delete _impl_.no_mapping_;
}

void TelemetryData_Nat64ErrorCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Nat64ErrorCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Nat64ErrorCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.unknown_ != nullptr);
      _impl_.unknown_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.illegal_packet_ != nullptr);
      _impl_.illegal_packet_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.unsupported_protocol_ != nullptr);
      _impl_.unsupported_protocol_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.no_mapping_ != nullptr);
      _impl_.no_mapping_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Nat64ErrorCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.Nat64PacketCounters unknown = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unknown(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64PacketCounters illegal_packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_illegal_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64PacketCounters unsupported_protocol = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_unsupported_protocol(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64PacketCounters no_mapping = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_no_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Nat64ErrorCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Nat64ErrorCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.Nat64PacketCounters unknown = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::unknown(this),
        _Internal::unknown(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters illegal_packet = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::illegal_packet(this),
        _Internal::illegal_packet(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters unsupported_protocol = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::unsupported_protocol(this),
        _Internal::unsupported_protocol(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters no_mapping = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::no_mapping(this),
        _Internal::no_mapping(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Nat64ErrorCounters)
  return target;
}

size_t TelemetryData_Nat64ErrorCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Nat64ErrorCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .threadnetwork.TelemetryData.Nat64PacketCounters unknown = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unknown_);
    }

    // optional .threadnetwork.TelemetryData.Nat64PacketCounters illegal_packet = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.illegal_packet_);
    }

    // optional .threadnetwork.TelemetryData.Nat64PacketCounters unsupported_protocol = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unsupported_protocol_);
    }

    // optional .threadnetwork.TelemetryData.Nat64PacketCounters no_mapping = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.no_mapping_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Nat64ErrorCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Nat64ErrorCounters*>(
      &from));
}

void TelemetryData_Nat64ErrorCounters::MergeFrom(const TelemetryData_Nat64ErrorCounters& from) {
  TelemetryData_Nat64ErrorCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Nat64ErrorCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_unknown()->::threadnetwork::TelemetryData_Nat64PacketCounters::MergeFrom(
          from._internal_unknown());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_illegal_packet()->::threadnetwork::TelemetryData_Nat64PacketCounters::MergeFrom(
          from._internal_illegal_packet());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_unsupported_protocol()->::threadnetwork::TelemetryData_Nat64PacketCounters::MergeFrom(
          from._internal_unsupported_protocol());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_no_mapping()->::threadnetwork::TelemetryData_Nat64PacketCounters::MergeFrom(
          from._internal_no_mapping());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Nat64ErrorCounters::CopyFrom(const TelemetryData_Nat64ErrorCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Nat64ErrorCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Nat64ErrorCounters::IsInitialized() const {
  return true;
}

void TelemetryData_Nat64ErrorCounters::InternalSwap(TelemetryData_Nat64ErrorCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64ErrorCounters, _impl_.no_mapping_)
      + sizeof(TelemetryData_Nat64ErrorCounters::_impl_.no_mapping_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64ErrorCounters, _impl_.unknown_)>(
          reinterpret_cast<char*>(&_impl_.unknown_),
          reinterpret_cast<char*>(&other->_impl_.unknown_));
}

std::string TelemetryData_Nat64ErrorCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.Nat64ErrorCounters";
}


// ===================================================================

class TelemetryData_BorderRoutingCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_BorderRoutingCounters>()._impl_._has_bits_);
  static void set_has_ra_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ra_tx_success(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ra_tx_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_rs_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_rs_tx_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_rs_tx_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_unicast(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_inbound_unicast(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_multicast(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_inbound_multicast(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_unicast(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_outbound_unicast(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_multicast(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_outbound_multicast(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& nat64_protocol_counters(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_nat64_protocol_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::threadnetwork::TelemetryData_Nat64ErrorCounters& nat64_error_counters(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_nat64_error_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_internet(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_inbound_internet(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_internet(const TelemetryData_BorderRoutingCounters* msg);
  static void set_has_outbound_internet(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::inbound_unicast(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.inbound_unicast_;
}
const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::inbound_multicast(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.inbound_multicast_;
}
const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::outbound_unicast(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.outbound_unicast_;
}
const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::outbound_multicast(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.outbound_multicast_;
}
const ::threadnetwork::TelemetryData_Nat64ProtocolCounters&
TelemetryData_BorderRoutingCounters::_Internal::nat64_protocol_counters(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.nat64_protocol_counters_;
}
const ::threadnetwork::TelemetryData_Nat64ErrorCounters&
TelemetryData_BorderRoutingCounters::_Internal::nat64_error_counters(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.nat64_error_counters_;
}
const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::inbound_internet(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.inbound_internet_;
}
const ::threadnetwork::TelemetryData_PacketsAndBytes&
TelemetryData_BorderRoutingCounters::_Internal::outbound_internet(const TelemetryData_BorderRoutingCounters* msg) {
  return *msg->_impl_.outbound_internet_;
}
TelemetryData_BorderRoutingCounters::TelemetryData_BorderRoutingCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.BorderRoutingCounters)
}
TelemetryData_BorderRoutingCounters::TelemetryData_BorderRoutingCounters(const TelemetryData_BorderRoutingCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_BorderRoutingCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.inbound_unicast_){nullptr}
    , decltype(_impl_.inbound_multicast_){nullptr}
    , decltype(_impl_.outbound_unicast_){nullptr}
    , decltype(_impl_.outbound_multicast_){nullptr}
    , decltype(_impl_.nat64_protocol_counters_){nullptr}
    , decltype(_impl_.nat64_error_counters_){nullptr}
    , decltype(_impl_.inbound_internet_){nullptr}
    , decltype(_impl_.outbound_internet_){nullptr}
    , decltype(_impl_.ra_rx_){}
    , decltype(_impl_.ra_tx_success_){}
    , decltype(_impl_.ra_tx_failure_){}
    , decltype(_impl_.rs_rx_){}
    , decltype(_impl_.rs_tx_success_){}
    , decltype(_impl_.rs_tx_failure_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_inbound_unicast()) {
    _this->_impl_.inbound_unicast_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.inbound_unicast_);
  }
  if (from._internal_has_inbound_multicast()) {
    _this->_impl_.inbound_multicast_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.inbound_multicast_);
  }
  if (from._internal_has_outbound_unicast()) {
    _this->_impl_.outbound_unicast_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.outbound_unicast_);
  }
  if (from._internal_has_outbound_multicast()) {
    _this->_impl_.outbound_multicast_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.outbound_multicast_);
  }
  if (from._internal_has_nat64_protocol_counters()) {
    _this->_impl_.nat64_protocol_counters_ = new ::threadnetwork::TelemetryData_Nat64ProtocolCounters(*from._impl_.nat64_protocol_counters_);
  }
  if (from._internal_has_nat64_error_counters()) {
    _this->_impl_.nat64_error_counters_ = new ::threadnetwork::TelemetryData_Nat64ErrorCounters(*from._impl_.nat64_error_counters_);
  }
  if (from._internal_has_inbound_internet()) {
    _this->_impl_.inbound_internet_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.inbound_internet_);
  }
  if (from._internal_has_outbound_internet()) {
    _this->_impl_.outbound_internet_ = new ::threadnetwork::TelemetryData_PacketsAndBytes(*from._impl_.outbound_internet_);
  }
  ::memcpy(&_impl_.ra_rx_, &from._impl_.ra_rx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rs_tx_failure_) -
    reinterpret_cast<char*>(&_impl_.ra_rx_)) + sizeof(_impl_.rs_tx_failure_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.BorderRoutingCounters)
}

inline void TelemetryData_BorderRoutingCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.inbound_unicast_){nullptr}
    , decltype(_impl_.inbound_multicast_){nullptr}
    , decltype(_impl_.outbound_unicast_){nullptr}
    , decltype(_impl_.outbound_multicast_){nullptr}
    , decltype(_impl_.nat64_protocol_counters_){nullptr}
    , decltype(_impl_.nat64_error_counters_){nullptr}
    , decltype(_impl_.inbound_internet_){nullptr}
    , decltype(_impl_.outbound_internet_){nullptr}
    , decltype(_impl_.ra_rx_){int64_t{0}}
    , decltype(_impl_.ra_tx_success_){int64_t{0}}
    , decltype(_impl_.ra_tx_failure_){int64_t{0}}
    , decltype(_impl_.rs_rx_){int64_t{0}}
    , decltype(_impl_.rs_tx_success_){int64_t{0}}
    , decltype(_impl_.rs_tx_failure_){int64_t{0}}
  };
}

TelemetryData_BorderRoutingCounters::~TelemetryData_BorderRoutingCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.BorderRoutingCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_BorderRoutingCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.inbound_unicast_;
  if (this != internal_default_instance()) delete _impl_.inbound_multicast_;
  if (this != internal_default_instance()) delete _impl_.outbound_unicast_;
  if (this != internal_default_instance()) delete _impl_.outbound_multicast_;
  if (this != internal_default_instance()) delete _impl_.nat64_protocol_counters_;
  if (this != internal_default_instance()) delete _impl_.nat64_error_counters_;
  if (this != internal_default_instance()) delete _impl_.inbound_internet_;
  if (this != internal_default_instance()) delete _impl_.outbound_internet_;
}

void TelemetryData_BorderRoutingCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_BorderRoutingCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.BorderRoutingCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.inbound_unicast_ != nullptr);
      _impl_.inbound_unicast_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.inbound_multicast_ != nullptr);
      _impl_.inbound_multicast_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.outbound_unicast_ != nullptr);
      _impl_.outbound_unicast_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.outbound_multicast_ != nullptr);
      _impl_.outbound_multicast_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.nat64_protocol_counters_ != nullptr);
      _impl_.nat64_protocol_counters_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.nat64_error_counters_ != nullptr);
      _impl_.nat64_error_counters_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.inbound_internet_ != nullptr);
      _impl_.inbound_internet_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.outbound_internet_ != nullptr);
      _impl_.outbound_internet_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.ra_rx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rs_tx_failure_) -
        reinterpret_cast<char*>(&_impl_.ra_rx_)) + sizeof(_impl_.rs_tx_failure_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_BorderRoutingCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 ra_rx = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_ra_rx(&has_bits);
          _impl_.ra_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ra_tx_success = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_ra_tx_success(&has_bits);
          _impl_.ra_tx_success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ra_tx_failure = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_ra_tx_failure(&has_bits);
          _impl_.ra_tx_failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rs_rx = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_rs_rx(&has_bits);
          _impl_.rs_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rs_tx_success = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_rs_tx_success(&has_bits);
          _impl_.rs_tx_success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rs_tx_failure = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_rs_tx_failure(&has_bits);
          _impl_.rs_tx_failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_unicast = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_inbound_unicast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_multicast = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_inbound_multicast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_unicast = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_outbound_unicast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_multicast = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_outbound_multicast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters nat64_protocol_counters = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_nat64_protocol_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64ErrorCounters nat64_error_counters = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_nat64_error_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_internet = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_inbound_internet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_internet = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_outbound_internet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_BorderRoutingCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.BorderRoutingCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 ra_rx = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_ra_rx(), target);
  }

  // optional int64 ra_tx_success = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_ra_tx_success(), target);
  }

  // optional int64 ra_tx_failure = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_ra_tx_failure(), target);
  }

  // optional int64 rs_rx = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_rs_rx(), target);
  }

  // optional int64 rs_tx_success = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_rs_tx_success(), target);
  }

  // optional int64 rs_tx_failure = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_rs_tx_failure(), target);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_unicast = 15;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::inbound_unicast(this),
        _Internal::inbound_unicast(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_multicast = 16;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::inbound_multicast(this),
        _Internal::inbound_multicast(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_unicast = 17;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::outbound_unicast(this),
        _Internal::outbound_unicast(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_multicast = 18;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::outbound_multicast(this),
        _Internal::outbound_multicast(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters nat64_protocol_counters = 19;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::nat64_protocol_counters(this),
        _Internal::nat64_protocol_counters(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Nat64ErrorCounters nat64_error_counters = 20;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::nat64_error_counters(this),
        _Internal::nat64_error_counters(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_internet = 21;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::inbound_internet(this),
        _Internal::inbound_internet(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_internet = 22;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::outbound_internet(this),
        _Internal::outbound_internet(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.BorderRoutingCounters)
  return target;
}

size_t TelemetryData_BorderRoutingCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.BorderRoutingCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_unicast = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inbound_unicast_);
    }

    // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_multicast = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inbound_multicast_);
    }

    // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_unicast = 17;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.outbound_unicast_);
    }

    // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_multicast = 18;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.outbound_multicast_);
    }

    // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters nat64_protocol_counters = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nat64_protocol_counters_);
    }

    // optional .threadnetwork.TelemetryData.Nat64ErrorCounters nat64_error_counters = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nat64_error_counters_);
    }

    // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_internet = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inbound_internet_);
    }

    // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_internet = 22;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.outbound_internet_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional int64 ra_rx = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ra_rx());
    }

    // optional int64 ra_tx_success = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ra_tx_success());
    }

    // optional int64 ra_tx_failure = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ra_tx_failure());
    }

    // optional int64 rs_rx = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rs_rx());
    }

    // optional int64 rs_tx_success = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rs_tx_success());
    }

    // optional int64 rs_tx_failure = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rs_tx_failure());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_BorderRoutingCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_BorderRoutingCounters*>(
      &from));
}

void TelemetryData_BorderRoutingCounters::MergeFrom(const TelemetryData_BorderRoutingCounters& from) {
  TelemetryData_BorderRoutingCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.BorderRoutingCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_inbound_unicast()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_inbound_unicast());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_inbound_multicast()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_inbound_multicast());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_outbound_unicast()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_outbound_unicast());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_outbound_multicast()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_outbound_multicast());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_nat64_protocol_counters()->::threadnetwork::TelemetryData_Nat64ProtocolCounters::MergeFrom(
          from._internal_nat64_protocol_counters());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_nat64_error_counters()->::threadnetwork::TelemetryData_Nat64ErrorCounters::MergeFrom(
          from._internal_nat64_error_counters());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_inbound_internet()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_inbound_internet());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_outbound_internet()->::threadnetwork::TelemetryData_PacketsAndBytes::MergeFrom(
          from._internal_outbound_internet());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ra_rx_ = from._impl_.ra_rx_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ra_tx_success_ = from._impl_.ra_tx_success_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.ra_tx_failure_ = from._impl_.ra_tx_failure_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.rs_rx_ = from._impl_.rs_rx_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.rs_tx_success_ = from._impl_.rs_tx_success_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.rs_tx_failure_ = from._impl_.rs_tx_failure_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_BorderRoutingCounters::CopyFrom(const TelemetryData_BorderRoutingCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.BorderRoutingCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_BorderRoutingCounters::IsInitialized() const {
  return true;
}

void TelemetryData_BorderRoutingCounters::InternalSwap(TelemetryData_BorderRoutingCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_BorderRoutingCounters, _impl_.rs_tx_failure_)
      + sizeof(TelemetryData_BorderRoutingCounters::_impl_.rs_tx_failure_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_BorderRoutingCounters, _impl_.inbound_unicast_)>(
          reinterpret_cast<char*>(&_impl_.inbound_unicast_),
          reinterpret_cast<char*>(&other->_impl_.inbound_unicast_));
}

std::string TelemetryData_BorderRoutingCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.BorderRoutingCounters";
}


// ===================================================================

class TelemetryData_PdProcessedRaInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_PdProcessedRaInfo>()._impl_._has_bits_);
  static void set_has_num_platform_ra_received(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_platform_pio_processed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_platform_ra_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TelemetryData_PdProcessedRaInfo::TelemetryData_PdProcessedRaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.PdProcessedRaInfo)
}
TelemetryData_PdProcessedRaInfo::TelemetryData_PdProcessedRaInfo(const TelemetryData_PdProcessedRaInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_PdProcessedRaInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_platform_ra_received_){}
    , decltype(_impl_.num_platform_pio_processed_){}
    , decltype(_impl_.last_platform_ra_msec_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.num_platform_ra_received_, &from._impl_.num_platform_ra_received_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_platform_ra_msec_) -
    reinterpret_cast<char*>(&_impl_.num_platform_ra_received_)) + sizeof(_impl_.last_platform_ra_msec_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.PdProcessedRaInfo)
}

inline void TelemetryData_PdProcessedRaInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_platform_ra_received_){0u}
    , decltype(_impl_.num_platform_pio_processed_){0u}
    , decltype(_impl_.last_platform_ra_msec_){0u}
  };
}

TelemetryData_PdProcessedRaInfo::~TelemetryData_PdProcessedRaInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.PdProcessedRaInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_PdProcessedRaInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_PdProcessedRaInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_PdProcessedRaInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.PdProcessedRaInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.num_platform_ra_received_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_platform_ra_msec_) -
        reinterpret_cast<char*>(&_impl_.num_platform_ra_received_)) + sizeof(_impl_.last_platform_ra_msec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_PdProcessedRaInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num_platform_ra_received = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_platform_ra_received(&has_bits);
          _impl_.num_platform_ra_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_platform_pio_processed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_platform_pio_processed(&has_bits);
          _impl_.num_platform_pio_processed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_platform_ra_msec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_platform_ra_msec(&has_bits);
          _impl_.last_platform_ra_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_PdProcessedRaInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.PdProcessedRaInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num_platform_ra_received = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_platform_ra_received(), target);
  }

  // optional uint32 num_platform_pio_processed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_platform_pio_processed(), target);
  }

  // optional uint32 last_platform_ra_msec = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_platform_ra_msec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.PdProcessedRaInfo)
  return target;
}

size_t TelemetryData_PdProcessedRaInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.PdProcessedRaInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 num_platform_ra_received = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_platform_ra_received());
    }

    // optional uint32 num_platform_pio_processed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_platform_pio_processed());
    }

    // optional uint32 last_platform_ra_msec = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_platform_ra_msec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_PdProcessedRaInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_PdProcessedRaInfo*>(
      &from));
}

void TelemetryData_PdProcessedRaInfo::MergeFrom(const TelemetryData_PdProcessedRaInfo& from) {
  TelemetryData_PdProcessedRaInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.PdProcessedRaInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_platform_ra_received_ = from._impl_.num_platform_ra_received_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_platform_pio_processed_ = from._impl_.num_platform_pio_processed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.last_platform_ra_msec_ = from._impl_.last_platform_ra_msec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_PdProcessedRaInfo::CopyFrom(const TelemetryData_PdProcessedRaInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.PdProcessedRaInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_PdProcessedRaInfo::IsInitialized() const {
  return true;
}

void TelemetryData_PdProcessedRaInfo::InternalSwap(TelemetryData_PdProcessedRaInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_PdProcessedRaInfo, _impl_.last_platform_ra_msec_)
      + sizeof(TelemetryData_PdProcessedRaInfo::_impl_.last_platform_ra_msec_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_PdProcessedRaInfo, _impl_.num_platform_ra_received_)>(
          reinterpret_cast<char*>(&_impl_.num_platform_ra_received_),
          reinterpret_cast<char*>(&other->_impl_.num_platform_ra_received_));
}

std::string TelemetryData_PdProcessedRaInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.PdProcessedRaInfo";
}


// ===================================================================

class TelemetryData_SrpServerRegistrationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_SrpServerRegistrationInfo>()._impl_._has_bits_);
  static void set_has_fresh_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_deleted_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lease_time_total_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key_lease_time_total_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remaining_lease_time_total_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_remaining_key_lease_time_total_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TelemetryData_SrpServerRegistrationInfo::TelemetryData_SrpServerRegistrationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
}
TelemetryData_SrpServerRegistrationInfo::TelemetryData_SrpServerRegistrationInfo(const TelemetryData_SrpServerRegistrationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_SrpServerRegistrationInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fresh_count_){}
    , decltype(_impl_.deleted_count_){}
    , decltype(_impl_.lease_time_total_ms_){}
    , decltype(_impl_.key_lease_time_total_ms_){}
    , decltype(_impl_.remaining_lease_time_total_ms_){}
    , decltype(_impl_.remaining_key_lease_time_total_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.fresh_count_, &from._impl_.fresh_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.remaining_key_lease_time_total_ms_) -
    reinterpret_cast<char*>(&_impl_.fresh_count_)) + sizeof(_impl_.remaining_key_lease_time_total_ms_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
}

inline void TelemetryData_SrpServerRegistrationInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fresh_count_){0u}
    , decltype(_impl_.deleted_count_){0u}
    , decltype(_impl_.lease_time_total_ms_){uint64_t{0u}}
    , decltype(_impl_.key_lease_time_total_ms_){uint64_t{0u}}
    , decltype(_impl_.remaining_lease_time_total_ms_){uint64_t{0u}}
    , decltype(_impl_.remaining_key_lease_time_total_ms_){uint64_t{0u}}
  };
}

TelemetryData_SrpServerRegistrationInfo::~TelemetryData_SrpServerRegistrationInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_SrpServerRegistrationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_SrpServerRegistrationInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_SrpServerRegistrationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.fresh_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.remaining_key_lease_time_total_ms_) -
        reinterpret_cast<char*>(&_impl_.fresh_count_)) + sizeof(_impl_.remaining_key_lease_time_total_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_SrpServerRegistrationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 fresh_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_fresh_count(&has_bits);
          _impl_.fresh_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deleted_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_deleted_count(&has_bits);
          _impl_.deleted_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lease_time_total_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lease_time_total_ms(&has_bits);
          _impl_.lease_time_total_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 key_lease_time_total_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_key_lease_time_total_ms(&has_bits);
          _impl_.key_lease_time_total_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 remaining_lease_time_total_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_remaining_lease_time_total_ms(&has_bits);
          _impl_.remaining_lease_time_total_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 remaining_key_lease_time_total_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_remaining_key_lease_time_total_ms(&has_bits);
          _impl_.remaining_key_lease_time_total_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_SrpServerRegistrationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 fresh_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_fresh_count(), target);
  }

  // optional uint32 deleted_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_deleted_count(), target);
  }

  // optional uint64 lease_time_total_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_lease_time_total_ms(), target);
  }

  // optional uint64 key_lease_time_total_ms = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_key_lease_time_total_ms(), target);
  }

  // optional uint64 remaining_lease_time_total_ms = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_remaining_lease_time_total_ms(), target);
  }

  // optional uint64 remaining_key_lease_time_total_ms = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_remaining_key_lease_time_total_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  return target;
}

size_t TelemetryData_SrpServerRegistrationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 fresh_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fresh_count());
    }

    // optional uint32 deleted_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deleted_count());
    }

    // optional uint64 lease_time_total_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lease_time_total_ms());
    }

    // optional uint64 key_lease_time_total_ms = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_key_lease_time_total_ms());
    }

    // optional uint64 remaining_lease_time_total_ms = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_remaining_lease_time_total_ms());
    }

    // optional uint64 remaining_key_lease_time_total_ms = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_remaining_key_lease_time_total_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_SrpServerRegistrationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_SrpServerRegistrationInfo*>(
      &from));
}

void TelemetryData_SrpServerRegistrationInfo::MergeFrom(const TelemetryData_SrpServerRegistrationInfo& from) {
  TelemetryData_SrpServerRegistrationInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.fresh_count_ = from._impl_.fresh_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.deleted_count_ = from._impl_.deleted_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lease_time_total_ms_ = from._impl_.lease_time_total_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.key_lease_time_total_ms_ = from._impl_.key_lease_time_total_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.remaining_lease_time_total_ms_ = from._impl_.remaining_lease_time_total_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.remaining_key_lease_time_total_ms_ = from._impl_.remaining_key_lease_time_total_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_SrpServerRegistrationInfo::CopyFrom(const TelemetryData_SrpServerRegistrationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_SrpServerRegistrationInfo::IsInitialized() const {
  return true;
}

void TelemetryData_SrpServerRegistrationInfo::InternalSwap(TelemetryData_SrpServerRegistrationInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerRegistrationInfo, _impl_.remaining_key_lease_time_total_ms_)
      + sizeof(TelemetryData_SrpServerRegistrationInfo::_impl_.remaining_key_lease_time_total_ms_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerRegistrationInfo, _impl_.fresh_count_)>(
          reinterpret_cast<char*>(&_impl_.fresh_count_),
          reinterpret_cast<char*>(&other->_impl_.fresh_count_));
}

std::string TelemetryData_SrpServerRegistrationInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.SrpServerRegistrationInfo";
}


// ===================================================================

class TelemetryData_SrpServerResponseCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_SrpServerResponseCounters>()._impl_._has_bits_);
  static void set_has_success_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_failure_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format_error_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name_exists_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_refused_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_other_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TelemetryData_SrpServerResponseCounters::TelemetryData_SrpServerResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.SrpServerResponseCounters)
}
TelemetryData_SrpServerResponseCounters::TelemetryData_SrpServerResponseCounters(const TelemetryData_SrpServerResponseCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_SrpServerResponseCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){}
    , decltype(_impl_.server_failure_count_){}
    , decltype(_impl_.format_error_count_){}
    , decltype(_impl_.name_exists_count_){}
    , decltype(_impl_.refused_count_){}
    , decltype(_impl_.other_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.success_count_, &from._impl_.success_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.other_count_) -
    reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.other_count_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.SrpServerResponseCounters)
}

inline void TelemetryData_SrpServerResponseCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){0u}
    , decltype(_impl_.server_failure_count_){0u}
    , decltype(_impl_.format_error_count_){0u}
    , decltype(_impl_.name_exists_count_){0u}
    , decltype(_impl_.refused_count_){0u}
    , decltype(_impl_.other_count_){0u}
  };
}

TelemetryData_SrpServerResponseCounters::~TelemetryData_SrpServerResponseCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.SrpServerResponseCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_SrpServerResponseCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_SrpServerResponseCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_SrpServerResponseCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.SrpServerResponseCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.success_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.other_count_) -
        reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.other_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_SrpServerResponseCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 success_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success_count(&has_bits);
          _impl_.success_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_failure_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_failure_count(&has_bits);
          _impl_.server_failure_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 format_error_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_format_error_count(&has_bits);
          _impl_.format_error_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 name_exists_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_name_exists_count(&has_bits);
          _impl_.name_exists_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 refused_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_refused_count(&has_bits);
          _impl_.refused_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 other_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_other_count(&has_bits);
          _impl_.other_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_SrpServerResponseCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.SrpServerResponseCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 success_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_success_count(), target);
  }

  // optional uint32 server_failure_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_server_failure_count(), target);
  }

  // optional uint32 format_error_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_format_error_count(), target);
  }

  // optional uint32 name_exists_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_name_exists_count(), target);
  }

  // optional uint32 refused_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_refused_count(), target);
  }

  // optional uint32 other_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_other_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.SrpServerResponseCounters)
  return target;
}

size_t TelemetryData_SrpServerResponseCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.SrpServerResponseCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 success_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_success_count());
    }

    // optional uint32 server_failure_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_failure_count());
    }

    // optional uint32 format_error_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_error_count());
    }

    // optional uint32 name_exists_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_name_exists_count());
    }

    // optional uint32 refused_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_refused_count());
    }

    // optional uint32 other_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_other_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_SrpServerResponseCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_SrpServerResponseCounters*>(
      &from));
}

void TelemetryData_SrpServerResponseCounters::MergeFrom(const TelemetryData_SrpServerResponseCounters& from) {
  TelemetryData_SrpServerResponseCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.SrpServerResponseCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.success_count_ = from._impl_.success_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.server_failure_count_ = from._impl_.server_failure_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_error_count_ = from._impl_.format_error_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.name_exists_count_ = from._impl_.name_exists_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.refused_count_ = from._impl_.refused_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.other_count_ = from._impl_.other_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_SrpServerResponseCounters::CopyFrom(const TelemetryData_SrpServerResponseCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.SrpServerResponseCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_SrpServerResponseCounters::IsInitialized() const {
  return true;
}

void TelemetryData_SrpServerResponseCounters::InternalSwap(TelemetryData_SrpServerResponseCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerResponseCounters, _impl_.other_count_)
      + sizeof(TelemetryData_SrpServerResponseCounters::_impl_.other_count_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerResponseCounters, _impl_.success_count_)>(
          reinterpret_cast<char*>(&_impl_.success_count_),
          reinterpret_cast<char*>(&other->_impl_.success_count_));
}

std::string TelemetryData_SrpServerResponseCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.SrpServerResponseCounters";
}


// ===================================================================

class TelemetryData_SrpServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_SrpServerInfo>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_address_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& hosts(const TelemetryData_SrpServerInfo* msg);
  static void set_has_hosts(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& services(const TelemetryData_SrpServerInfo* msg);
  static void set_has_services(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_SrpServerResponseCounters& response_counters(const TelemetryData_SrpServerInfo* msg);
  static void set_has_response_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo&
TelemetryData_SrpServerInfo::_Internal::hosts(const TelemetryData_SrpServerInfo* msg) {
  return *msg->_impl_.hosts_;
}
const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo&
TelemetryData_SrpServerInfo::_Internal::services(const TelemetryData_SrpServerInfo* msg) {
  return *msg->_impl_.services_;
}
const ::threadnetwork::TelemetryData_SrpServerResponseCounters&
TelemetryData_SrpServerInfo::_Internal::response_counters(const TelemetryData_SrpServerInfo* msg) {
  return *msg->_impl_.response_counters_;
}
TelemetryData_SrpServerInfo::TelemetryData_SrpServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.SrpServerInfo)
}
TelemetryData_SrpServerInfo::TelemetryData_SrpServerInfo(const TelemetryData_SrpServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_SrpServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hosts_){nullptr}
    , decltype(_impl_.services_){nullptr}
    , decltype(_impl_.response_counters_){nullptr}
    , decltype(_impl_.state_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.address_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_hosts()) {
    _this->_impl_.hosts_ = new ::threadnetwork::TelemetryData_SrpServerRegistrationInfo(*from._impl_.hosts_);
  }
  if (from._internal_has_services()) {
    _this->_impl_.services_ = new ::threadnetwork::TelemetryData_SrpServerRegistrationInfo(*from._impl_.services_);
  }
  if (from._internal_has_response_counters()) {
    _this->_impl_.response_counters_ = new ::threadnetwork::TelemetryData_SrpServerResponseCounters(*from._impl_.response_counters_);
  }
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.address_mode_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.address_mode_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.SrpServerInfo)
}

inline void TelemetryData_SrpServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hosts_){nullptr}
    , decltype(_impl_.services_){nullptr}
    , decltype(_impl_.response_counters_){nullptr}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.port_){0u}
    , decltype(_impl_.address_mode_){0}
  };
}

TelemetryData_SrpServerInfo::~TelemetryData_SrpServerInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.SrpServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_SrpServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hosts_;
  if (this != internal_default_instance()) delete _impl_.services_;
  if (this != internal_default_instance()) delete _impl_.response_counters_;
}

void TelemetryData_SrpServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_SrpServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.SrpServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.hosts_ != nullptr);
      _impl_.hosts_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.services_ != nullptr);
      _impl_.services_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.response_counters_ != nullptr);
      _impl_.response_counters_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.address_mode_) -
        reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.address_mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_SrpServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.SrpServerState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_SrpServerState_IsValid(val))) {
            _internal_set_state(static_cast<::threadnetwork::TelemetryData_SrpServerState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.SrpServerAddressMode address_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_SrpServerAddressMode_IsValid(val))) {
            _internal_set_address_mode(static_cast<::threadnetwork::TelemetryData_SrpServerAddressMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo hosts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hosts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo services = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_services(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.SrpServerResponseCounters response_counters = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_SrpServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.SrpServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.SrpServerState state = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // optional uint32 port = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  // optional .threadnetwork.TelemetryData.SrpServerAddressMode address_mode = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_address_mode(), target);
  }

  // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo hosts = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hosts(this),
        _Internal::hosts(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo services = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::services(this),
        _Internal::services(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.SrpServerResponseCounters response_counters = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::response_counters(this),
        _Internal::response_counters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.SrpServerInfo)
  return target;
}

size_t TelemetryData_SrpServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.SrpServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo hosts = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hosts_);
    }

    // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo services = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.services_);
    }

    // optional .threadnetwork.TelemetryData.SrpServerResponseCounters response_counters = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_counters_);
    }

    // optional .threadnetwork.TelemetryData.SrpServerState state = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional uint32 port = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
    }

    // optional .threadnetwork.TelemetryData.SrpServerAddressMode address_mode = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_address_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_SrpServerInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_SrpServerInfo*>(
      &from));
}

void TelemetryData_SrpServerInfo::MergeFrom(const TelemetryData_SrpServerInfo& from) {
  TelemetryData_SrpServerInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.SrpServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_hosts()->::threadnetwork::TelemetryData_SrpServerRegistrationInfo::MergeFrom(
          from._internal_hosts());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_services()->::threadnetwork::TelemetryData_SrpServerRegistrationInfo::MergeFrom(
          from._internal_services());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_response_counters()->::threadnetwork::TelemetryData_SrpServerResponseCounters::MergeFrom(
          from._internal_response_counters());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.address_mode_ = from._impl_.address_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_SrpServerInfo::CopyFrom(const TelemetryData_SrpServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.SrpServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_SrpServerInfo::IsInitialized() const {
  return true;
}

void TelemetryData_SrpServerInfo::InternalSwap(TelemetryData_SrpServerInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerInfo, _impl_.address_mode_)
      + sizeof(TelemetryData_SrpServerInfo::_impl_.address_mode_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_SrpServerInfo, _impl_.hosts_)>(
          reinterpret_cast<char*>(&_impl_.hosts_),
          reinterpret_cast<char*>(&other->_impl_.hosts_));
}

std::string TelemetryData_SrpServerInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.SrpServerInfo";
}


// ===================================================================

class TelemetryData_TrelPacketCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_TrelPacketCounters>()._impl_._has_bits_);
  static void set_has_trel_tx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trel_tx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_trel_tx_packets_failed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tre_rx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trel_rx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TelemetryData_TrelPacketCounters::TelemetryData_TrelPacketCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.TrelPacketCounters)
}
TelemetryData_TrelPacketCounters::TelemetryData_TrelPacketCounters(const TelemetryData_TrelPacketCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_TrelPacketCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trel_tx_packets_){}
    , decltype(_impl_.trel_tx_bytes_){}
    , decltype(_impl_.trel_tx_packets_failed_){}
    , decltype(_impl_.tre_rx_packets_){}
    , decltype(_impl_.trel_rx_bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.trel_tx_packets_, &from._impl_.trel_tx_packets_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trel_rx_bytes_) -
    reinterpret_cast<char*>(&_impl_.trel_tx_packets_)) + sizeof(_impl_.trel_rx_bytes_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.TrelPacketCounters)
}

inline void TelemetryData_TrelPacketCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trel_tx_packets_){uint64_t{0u}}
    , decltype(_impl_.trel_tx_bytes_){uint64_t{0u}}
    , decltype(_impl_.trel_tx_packets_failed_){uint64_t{0u}}
    , decltype(_impl_.tre_rx_packets_){uint64_t{0u}}
    , decltype(_impl_.trel_rx_bytes_){uint64_t{0u}}
  };
}

TelemetryData_TrelPacketCounters::~TelemetryData_TrelPacketCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.TrelPacketCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_TrelPacketCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_TrelPacketCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_TrelPacketCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.TrelPacketCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.trel_tx_packets_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trel_rx_bytes_) -
        reinterpret_cast<char*>(&_impl_.trel_tx_packets_)) + sizeof(_impl_.trel_rx_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_TrelPacketCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 trel_tx_packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_trel_tx_packets(&has_bits);
          _impl_.trel_tx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 trel_tx_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_trel_tx_bytes(&has_bits);
          _impl_.trel_tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 trel_tx_packets_failed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_trel_tx_packets_failed(&has_bits);
          _impl_.trel_tx_packets_failed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tre_rx_packets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tre_rx_packets(&has_bits);
          _impl_.tre_rx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 trel_rx_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_trel_rx_bytes(&has_bits);
          _impl_.trel_rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_TrelPacketCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.TrelPacketCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 trel_tx_packets = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_trel_tx_packets(), target);
  }

  // optional uint64 trel_tx_bytes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trel_tx_bytes(), target);
  }

  // optional uint64 trel_tx_packets_failed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_trel_tx_packets_failed(), target);
  }

  // optional uint64 tre_rx_packets = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_tre_rx_packets(), target);
  }

  // optional uint64 trel_rx_bytes = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_trel_rx_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.TrelPacketCounters)
  return target;
}

size_t TelemetryData_TrelPacketCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.TrelPacketCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 trel_tx_packets = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trel_tx_packets());
    }

    // optional uint64 trel_tx_bytes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trel_tx_bytes());
    }

    // optional uint64 trel_tx_packets_failed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trel_tx_packets_failed());
    }

    // optional uint64 tre_rx_packets = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tre_rx_packets());
    }

    // optional uint64 trel_rx_bytes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trel_rx_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_TrelPacketCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_TrelPacketCounters*>(
      &from));
}

void TelemetryData_TrelPacketCounters::MergeFrom(const TelemetryData_TrelPacketCounters& from) {
  TelemetryData_TrelPacketCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.TrelPacketCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.trel_tx_packets_ = from._impl_.trel_tx_packets_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.trel_tx_bytes_ = from._impl_.trel_tx_bytes_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.trel_tx_packets_failed_ = from._impl_.trel_tx_packets_failed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tre_rx_packets_ = from._impl_.tre_rx_packets_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.trel_rx_bytes_ = from._impl_.trel_rx_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_TrelPacketCounters::CopyFrom(const TelemetryData_TrelPacketCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.TrelPacketCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_TrelPacketCounters::IsInitialized() const {
  return true;
}

void TelemetryData_TrelPacketCounters::InternalSwap(TelemetryData_TrelPacketCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_TrelPacketCounters, _impl_.trel_rx_bytes_)
      + sizeof(TelemetryData_TrelPacketCounters::_impl_.trel_rx_bytes_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_TrelPacketCounters, _impl_.trel_tx_packets_)>(
          reinterpret_cast<char*>(&_impl_.trel_tx_packets_),
          reinterpret_cast<char*>(&other->_impl_.trel_tx_packets_));
}

std::string TelemetryData_TrelPacketCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.TrelPacketCounters";
}


// ===================================================================

class TelemetryData_TrelInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_TrelInfo>()._impl_._has_bits_);
  static void set_has_is_trel_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_trel_peers(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_TrelPacketCounters& counters(const TelemetryData_TrelInfo* msg);
  static void set_has_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::threadnetwork::TelemetryData_TrelPacketCounters&
TelemetryData_TrelInfo::_Internal::counters(const TelemetryData_TrelInfo* msg) {
  return *msg->_impl_.counters_;
}
TelemetryData_TrelInfo::TelemetryData_TrelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.TrelInfo)
}
TelemetryData_TrelInfo::TelemetryData_TrelInfo(const TelemetryData_TrelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_TrelInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.counters_){nullptr}
    , decltype(_impl_.is_trel_enabled_){}
    , decltype(_impl_.num_trel_peers_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_counters()) {
    _this->_impl_.counters_ = new ::threadnetwork::TelemetryData_TrelPacketCounters(*from._impl_.counters_);
  }
  ::memcpy(&_impl_.is_trel_enabled_, &from._impl_.is_trel_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_trel_peers_) -
    reinterpret_cast<char*>(&_impl_.is_trel_enabled_)) + sizeof(_impl_.num_trel_peers_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.TrelInfo)
}

inline void TelemetryData_TrelInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.counters_){nullptr}
    , decltype(_impl_.is_trel_enabled_){false}
    , decltype(_impl_.num_trel_peers_){0u}
  };
}

TelemetryData_TrelInfo::~TelemetryData_TrelInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.TrelInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_TrelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.counters_;
}

void TelemetryData_TrelInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_TrelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.TrelInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.counters_ != nullptr);
    _impl_.counters_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.is_trel_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_trel_peers_) -
        reinterpret_cast<char*>(&_impl_.is_trel_enabled_)) + sizeof(_impl_.num_trel_peers_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_TrelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_trel_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_trel_enabled(&has_bits);
          _impl_.is_trel_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_trel_peers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_trel_peers(&has_bits);
          _impl_.num_trel_peers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.TrelPacketCounters counters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_TrelInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.TrelInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_trel_enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_trel_enabled(), target);
  }

  // optional uint32 num_trel_peers = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_trel_peers(), target);
  }

  // optional .threadnetwork.TelemetryData.TrelPacketCounters counters = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::counters(this),
        _Internal::counters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.TrelInfo)
  return target;
}

size_t TelemetryData_TrelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.TrelInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .threadnetwork.TelemetryData.TrelPacketCounters counters = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.counters_);
    }

    // optional bool is_trel_enabled = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 num_trel_peers = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_trel_peers());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_TrelInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_TrelInfo*>(
      &from));
}

void TelemetryData_TrelInfo::MergeFrom(const TelemetryData_TrelInfo& from) {
  TelemetryData_TrelInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.TrelInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_counters()->::threadnetwork::TelemetryData_TrelPacketCounters::MergeFrom(
          from._internal_counters());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_trel_enabled_ = from._impl_.is_trel_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_trel_peers_ = from._impl_.num_trel_peers_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_TrelInfo::CopyFrom(const TelemetryData_TrelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.TrelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_TrelInfo::IsInitialized() const {
  return true;
}

void TelemetryData_TrelInfo::InternalSwap(TelemetryData_TrelInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_TrelInfo, _impl_.num_trel_peers_)
      + sizeof(TelemetryData_TrelInfo::_impl_.num_trel_peers_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_TrelInfo, _impl_.counters_)>(
          reinterpret_cast<char*>(&_impl_.counters_),
          reinterpret_cast<char*>(&other->_impl_.counters_));
}

std::string TelemetryData_TrelInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.TrelInfo";
}


// ===================================================================

class TelemetryData_DnsServerResponseCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_DnsServerResponseCounters>()._impl_._has_bits_);
  static void set_has_success_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_failure_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format_error_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name_error_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_not_implemented_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_other_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_upstream_dns_queries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_upstream_dns_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_upstream_dns_failures(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

TelemetryData_DnsServerResponseCounters::TelemetryData_DnsServerResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.DnsServerResponseCounters)
}
TelemetryData_DnsServerResponseCounters::TelemetryData_DnsServerResponseCounters(const TelemetryData_DnsServerResponseCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_DnsServerResponseCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){}
    , decltype(_impl_.server_failure_count_){}
    , decltype(_impl_.format_error_count_){}
    , decltype(_impl_.name_error_count_){}
    , decltype(_impl_.not_implemented_count_){}
    , decltype(_impl_.other_count_){}
    , decltype(_impl_.upstream_dns_queries_){}
    , decltype(_impl_.upstream_dns_responses_){}
    , decltype(_impl_.upstream_dns_failures_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.success_count_, &from._impl_.success_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upstream_dns_failures_) -
    reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.upstream_dns_failures_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.DnsServerResponseCounters)
}

inline void TelemetryData_DnsServerResponseCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){0u}
    , decltype(_impl_.server_failure_count_){0u}
    , decltype(_impl_.format_error_count_){0u}
    , decltype(_impl_.name_error_count_){0u}
    , decltype(_impl_.not_implemented_count_){0u}
    , decltype(_impl_.other_count_){0u}
    , decltype(_impl_.upstream_dns_queries_){0u}
    , decltype(_impl_.upstream_dns_responses_){0u}
    , decltype(_impl_.upstream_dns_failures_){0u}
  };
}

TelemetryData_DnsServerResponseCounters::~TelemetryData_DnsServerResponseCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.DnsServerResponseCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_DnsServerResponseCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_DnsServerResponseCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_DnsServerResponseCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.DnsServerResponseCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.success_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upstream_dns_responses_) -
        reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.upstream_dns_responses_));
  }
  _impl_.upstream_dns_failures_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_DnsServerResponseCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 success_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success_count(&has_bits);
          _impl_.success_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_failure_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_failure_count(&has_bits);
          _impl_.server_failure_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 format_error_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_format_error_count(&has_bits);
          _impl_.format_error_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 name_error_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_name_error_count(&has_bits);
          _impl_.name_error_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 not_implemented_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_not_implemented_count(&has_bits);
          _impl_.not_implemented_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 other_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_other_count(&has_bits);
          _impl_.other_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 upstream_dns_queries = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_upstream_dns_queries(&has_bits);
          _impl_.upstream_dns_queries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 upstream_dns_responses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_upstream_dns_responses(&has_bits);
          _impl_.upstream_dns_responses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 upstream_dns_failures = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_upstream_dns_failures(&has_bits);
          _impl_.upstream_dns_failures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_DnsServerResponseCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.DnsServerResponseCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 success_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_success_count(), target);
  }

  // optional uint32 server_failure_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_server_failure_count(), target);
  }

  // optional uint32 format_error_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_format_error_count(), target);
  }

  // optional uint32 name_error_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_name_error_count(), target);
  }

  // optional uint32 not_implemented_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_not_implemented_count(), target);
  }

  // optional uint32 other_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_other_count(), target);
  }

  // optional uint32 upstream_dns_queries = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_upstream_dns_queries(), target);
  }

  // optional uint32 upstream_dns_responses = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_upstream_dns_responses(), target);
  }

  // optional uint32 upstream_dns_failures = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_upstream_dns_failures(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.DnsServerResponseCounters)
  return target;
}

size_t TelemetryData_DnsServerResponseCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.DnsServerResponseCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 success_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_success_count());
    }

    // optional uint32 server_failure_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_failure_count());
    }

    // optional uint32 format_error_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_error_count());
    }

    // optional uint32 name_error_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_name_error_count());
    }

    // optional uint32 not_implemented_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_not_implemented_count());
    }

    // optional uint32 other_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_other_count());
    }

    // optional uint32 upstream_dns_queries = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_upstream_dns_queries());
    }

    // optional uint32 upstream_dns_responses = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_upstream_dns_responses());
    }

  }
  // optional uint32 upstream_dns_failures = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_upstream_dns_failures());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_DnsServerResponseCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_DnsServerResponseCounters*>(
      &from));
}

void TelemetryData_DnsServerResponseCounters::MergeFrom(const TelemetryData_DnsServerResponseCounters& from) {
  TelemetryData_DnsServerResponseCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.DnsServerResponseCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.success_count_ = from._impl_.success_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.server_failure_count_ = from._impl_.server_failure_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_error_count_ = from._impl_.format_error_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.name_error_count_ = from._impl_.name_error_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.not_implemented_count_ = from._impl_.not_implemented_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.other_count_ = from._impl_.other_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.upstream_dns_queries_ = from._impl_.upstream_dns_queries_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.upstream_dns_responses_ = from._impl_.upstream_dns_responses_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_upstream_dns_failures(from._internal_upstream_dns_failures());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_DnsServerResponseCounters::CopyFrom(const TelemetryData_DnsServerResponseCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.DnsServerResponseCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_DnsServerResponseCounters::IsInitialized() const {
  return true;
}

void TelemetryData_DnsServerResponseCounters::InternalSwap(TelemetryData_DnsServerResponseCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_DnsServerResponseCounters, _impl_.upstream_dns_failures_)
      + sizeof(TelemetryData_DnsServerResponseCounters::_impl_.upstream_dns_failures_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_DnsServerResponseCounters, _impl_.success_count_)>(
          reinterpret_cast<char*>(&_impl_.success_count_),
          reinterpret_cast<char*>(&other->_impl_.success_count_));
}

std::string TelemetryData_DnsServerResponseCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.DnsServerResponseCounters";
}


// ===================================================================

class TelemetryData_DnsServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_DnsServerInfo>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_DnsServerResponseCounters& response_counters(const TelemetryData_DnsServerInfo* msg);
  static void set_has_response_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resolved_by_local_srp_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upstream_dns_query_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::threadnetwork::TelemetryData_DnsServerResponseCounters&
TelemetryData_DnsServerInfo::_Internal::response_counters(const TelemetryData_DnsServerInfo* msg) {
  return *msg->_impl_.response_counters_;
}
TelemetryData_DnsServerInfo::TelemetryData_DnsServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.DnsServerInfo)
}
TelemetryData_DnsServerInfo::TelemetryData_DnsServerInfo(const TelemetryData_DnsServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_DnsServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_counters_){nullptr}
    , decltype(_impl_.resolved_by_local_srp_count_){}
    , decltype(_impl_.upstream_dns_query_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_response_counters()) {
    _this->_impl_.response_counters_ = new ::threadnetwork::TelemetryData_DnsServerResponseCounters(*from._impl_.response_counters_);
  }
  ::memcpy(&_impl_.resolved_by_local_srp_count_, &from._impl_.resolved_by_local_srp_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upstream_dns_query_state_) -
    reinterpret_cast<char*>(&_impl_.resolved_by_local_srp_count_)) + sizeof(_impl_.upstream_dns_query_state_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.DnsServerInfo)
}

inline void TelemetryData_DnsServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_counters_){nullptr}
    , decltype(_impl_.resolved_by_local_srp_count_){0u}
    , decltype(_impl_.upstream_dns_query_state_){0}
  };
}

TelemetryData_DnsServerInfo::~TelemetryData_DnsServerInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.DnsServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_DnsServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.response_counters_;
}

void TelemetryData_DnsServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_DnsServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.DnsServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.response_counters_ != nullptr);
    _impl_.response_counters_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.resolved_by_local_srp_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upstream_dns_query_state_) -
        reinterpret_cast<char*>(&_impl_.resolved_by_local_srp_count_)) + sizeof(_impl_.upstream_dns_query_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_DnsServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.DnsServerResponseCounters response_counters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 resolved_by_local_srp_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_resolved_by_local_srp_count(&has_bits);
          _impl_.resolved_by_local_srp_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.UpstreamDnsQueryState upstream_dns_query_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_UpstreamDnsQueryState_IsValid(val))) {
            _internal_set_upstream_dns_query_state(static_cast<::threadnetwork::TelemetryData_UpstreamDnsQueryState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_DnsServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.DnsServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.DnsServerResponseCounters response_counters = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response_counters(this),
        _Internal::response_counters(this).GetCachedSize(), target, stream);
  }

  // optional uint32 resolved_by_local_srp_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_resolved_by_local_srp_count(), target);
  }

  // optional .threadnetwork.TelemetryData.UpstreamDnsQueryState upstream_dns_query_state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_upstream_dns_query_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.DnsServerInfo)
  return target;
}

size_t TelemetryData_DnsServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.DnsServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .threadnetwork.TelemetryData.DnsServerResponseCounters response_counters = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_counters_);
    }

    // optional uint32 resolved_by_local_srp_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_resolved_by_local_srp_count());
    }

    // optional .threadnetwork.TelemetryData.UpstreamDnsQueryState upstream_dns_query_state = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_upstream_dns_query_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_DnsServerInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_DnsServerInfo*>(
      &from));
}

void TelemetryData_DnsServerInfo::MergeFrom(const TelemetryData_DnsServerInfo& from) {
  TelemetryData_DnsServerInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.DnsServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_response_counters()->::threadnetwork::TelemetryData_DnsServerResponseCounters::MergeFrom(
          from._internal_response_counters());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resolved_by_local_srp_count_ = from._impl_.resolved_by_local_srp_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.upstream_dns_query_state_ = from._impl_.upstream_dns_query_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_DnsServerInfo::CopyFrom(const TelemetryData_DnsServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.DnsServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_DnsServerInfo::IsInitialized() const {
  return true;
}

void TelemetryData_DnsServerInfo::InternalSwap(TelemetryData_DnsServerInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_DnsServerInfo, _impl_.upstream_dns_query_state_)
      + sizeof(TelemetryData_DnsServerInfo::_impl_.upstream_dns_query_state_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_DnsServerInfo, _impl_.response_counters_)>(
          reinterpret_cast<char*>(&_impl_.response_counters_),
          reinterpret_cast<char*>(&other->_impl_.response_counters_));
}

std::string TelemetryData_DnsServerInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.DnsServerInfo";
}


// ===================================================================

class TelemetryData_MdnsResponseCounters::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_MdnsResponseCounters>()._impl_._has_bits_);
  static void set_has_success_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_not_found_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_invalid_args_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_duplicated_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_not_implemented_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_unknown_error_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_aborted_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_invalid_state_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

TelemetryData_MdnsResponseCounters::TelemetryData_MdnsResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.MdnsResponseCounters)
}
TelemetryData_MdnsResponseCounters::TelemetryData_MdnsResponseCounters(const TelemetryData_MdnsResponseCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_MdnsResponseCounters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){}
    , decltype(_impl_.not_found_count_){}
    , decltype(_impl_.invalid_args_count_){}
    , decltype(_impl_.duplicated_count_){}
    , decltype(_impl_.not_implemented_count_){}
    , decltype(_impl_.unknown_error_count_){}
    , decltype(_impl_.aborted_count_){}
    , decltype(_impl_.invalid_state_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.success_count_, &from._impl_.success_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.invalid_state_count_) -
    reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.invalid_state_count_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.MdnsResponseCounters)
}

inline void TelemetryData_MdnsResponseCounters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_count_){0u}
    , decltype(_impl_.not_found_count_){0u}
    , decltype(_impl_.invalid_args_count_){0u}
    , decltype(_impl_.duplicated_count_){0u}
    , decltype(_impl_.not_implemented_count_){0u}
    , decltype(_impl_.unknown_error_count_){0u}
    , decltype(_impl_.aborted_count_){0u}
    , decltype(_impl_.invalid_state_count_){0u}
  };
}

TelemetryData_MdnsResponseCounters::~TelemetryData_MdnsResponseCounters() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.MdnsResponseCounters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_MdnsResponseCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_MdnsResponseCounters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_MdnsResponseCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.MdnsResponseCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.success_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.invalid_state_count_) -
        reinterpret_cast<char*>(&_impl_.success_count_)) + sizeof(_impl_.invalid_state_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_MdnsResponseCounters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 success_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success_count(&has_bits);
          _impl_.success_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 not_found_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_not_found_count(&has_bits);
          _impl_.not_found_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 invalid_args_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_invalid_args_count(&has_bits);
          _impl_.invalid_args_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duplicated_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_duplicated_count(&has_bits);
          _impl_.duplicated_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 not_implemented_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_not_implemented_count(&has_bits);
          _impl_.not_implemented_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unknown_error_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_unknown_error_count(&has_bits);
          _impl_.unknown_error_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 aborted_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_aborted_count(&has_bits);
          _impl_.aborted_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 invalid_state_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_invalid_state_count(&has_bits);
          _impl_.invalid_state_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_MdnsResponseCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.MdnsResponseCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 success_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_success_count(), target);
  }

  // optional uint32 not_found_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_not_found_count(), target);
  }

  // optional uint32 invalid_args_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_invalid_args_count(), target);
  }

  // optional uint32 duplicated_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_duplicated_count(), target);
  }

  // optional uint32 not_implemented_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_not_implemented_count(), target);
  }

  // optional uint32 unknown_error_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_unknown_error_count(), target);
  }

  // optional uint32 aborted_count = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_aborted_count(), target);
  }

  // optional uint32 invalid_state_count = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_invalid_state_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.MdnsResponseCounters)
  return target;
}

size_t TelemetryData_MdnsResponseCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.MdnsResponseCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 success_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_success_count());
    }

    // optional uint32 not_found_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_not_found_count());
    }

    // optional uint32 invalid_args_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_invalid_args_count());
    }

    // optional uint32 duplicated_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duplicated_count());
    }

    // optional uint32 not_implemented_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_not_implemented_count());
    }

    // optional uint32 unknown_error_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unknown_error_count());
    }

    // optional uint32 aborted_count = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_aborted_count());
    }

    // optional uint32 invalid_state_count = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_invalid_state_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_MdnsResponseCounters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_MdnsResponseCounters*>(
      &from));
}

void TelemetryData_MdnsResponseCounters::MergeFrom(const TelemetryData_MdnsResponseCounters& from) {
  TelemetryData_MdnsResponseCounters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.MdnsResponseCounters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.success_count_ = from._impl_.success_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.not_found_count_ = from._impl_.not_found_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.invalid_args_count_ = from._impl_.invalid_args_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.duplicated_count_ = from._impl_.duplicated_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.not_implemented_count_ = from._impl_.not_implemented_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.unknown_error_count_ = from._impl_.unknown_error_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.aborted_count_ = from._impl_.aborted_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.invalid_state_count_ = from._impl_.invalid_state_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_MdnsResponseCounters::CopyFrom(const TelemetryData_MdnsResponseCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.MdnsResponseCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_MdnsResponseCounters::IsInitialized() const {
  return true;
}

void TelemetryData_MdnsResponseCounters::InternalSwap(TelemetryData_MdnsResponseCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_MdnsResponseCounters, _impl_.invalid_state_count_)
      + sizeof(TelemetryData_MdnsResponseCounters::_impl_.invalid_state_count_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_MdnsResponseCounters, _impl_.success_count_)>(
          reinterpret_cast<char*>(&_impl_.success_count_),
          reinterpret_cast<char*>(&other->_impl_.success_count_));
}

std::string TelemetryData_MdnsResponseCounters::GetTypeName() const {
  return "threadnetwork.TelemetryData.MdnsResponseCounters";
}


// ===================================================================

class TelemetryData_MdnsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_MdnsInfo>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_MdnsResponseCounters& host_registration_responses(const TelemetryData_MdnsInfo* msg);
  static void set_has_host_registration_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_MdnsResponseCounters& service_registration_responses(const TelemetryData_MdnsInfo* msg);
  static void set_has_service_registration_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_MdnsResponseCounters& host_resolution_responses(const TelemetryData_MdnsInfo* msg);
  static void set_has_host_resolution_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_MdnsResponseCounters& service_resolution_responses(const TelemetryData_MdnsInfo* msg);
  static void set_has_service_resolution_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_host_registration_ema_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_service_registration_ema_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_host_resolution_ema_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_service_resolution_ema_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::threadnetwork::TelemetryData_MdnsResponseCounters&
TelemetryData_MdnsInfo::_Internal::host_registration_responses(const TelemetryData_MdnsInfo* msg) {
  return *msg->_impl_.host_registration_responses_;
}
const ::threadnetwork::TelemetryData_MdnsResponseCounters&
TelemetryData_MdnsInfo::_Internal::service_registration_responses(const TelemetryData_MdnsInfo* msg) {
  return *msg->_impl_.service_registration_responses_;
}
const ::threadnetwork::TelemetryData_MdnsResponseCounters&
TelemetryData_MdnsInfo::_Internal::host_resolution_responses(const TelemetryData_MdnsInfo* msg) {
  return *msg->_impl_.host_resolution_responses_;
}
const ::threadnetwork::TelemetryData_MdnsResponseCounters&
TelemetryData_MdnsInfo::_Internal::service_resolution_responses(const TelemetryData_MdnsInfo* msg) {
  return *msg->_impl_.service_resolution_responses_;
}
TelemetryData_MdnsInfo::TelemetryData_MdnsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.MdnsInfo)
}
TelemetryData_MdnsInfo::TelemetryData_MdnsInfo(const TelemetryData_MdnsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_MdnsInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_registration_responses_){nullptr}
    , decltype(_impl_.service_registration_responses_){nullptr}
    , decltype(_impl_.host_resolution_responses_){nullptr}
    , decltype(_impl_.service_resolution_responses_){nullptr}
    , decltype(_impl_.host_registration_ema_latency_ms_){}
    , decltype(_impl_.service_registration_ema_latency_ms_){}
    , decltype(_impl_.host_resolution_ema_latency_ms_){}
    , decltype(_impl_.service_resolution_ema_latency_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_host_registration_responses()) {
    _this->_impl_.host_registration_responses_ = new ::threadnetwork::TelemetryData_MdnsResponseCounters(*from._impl_.host_registration_responses_);
  }
  if (from._internal_has_service_registration_responses()) {
    _this->_impl_.service_registration_responses_ = new ::threadnetwork::TelemetryData_MdnsResponseCounters(*from._impl_.service_registration_responses_);
  }
  if (from._internal_has_host_resolution_responses()) {
    _this->_impl_.host_resolution_responses_ = new ::threadnetwork::TelemetryData_MdnsResponseCounters(*from._impl_.host_resolution_responses_);
  }
  if (from._internal_has_service_resolution_responses()) {
    _this->_impl_.service_resolution_responses_ = new ::threadnetwork::TelemetryData_MdnsResponseCounters(*from._impl_.service_resolution_responses_);
  }
  ::memcpy(&_impl_.host_registration_ema_latency_ms_, &from._impl_.host_registration_ema_latency_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_resolution_ema_latency_ms_) -
    reinterpret_cast<char*>(&_impl_.host_registration_ema_latency_ms_)) + sizeof(_impl_.service_resolution_ema_latency_ms_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.MdnsInfo)
}

inline void TelemetryData_MdnsInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_registration_responses_){nullptr}
    , decltype(_impl_.service_registration_responses_){nullptr}
    , decltype(_impl_.host_resolution_responses_){nullptr}
    , decltype(_impl_.service_resolution_responses_){nullptr}
    , decltype(_impl_.host_registration_ema_latency_ms_){0u}
    , decltype(_impl_.service_registration_ema_latency_ms_){0u}
    , decltype(_impl_.host_resolution_ema_latency_ms_){0u}
    , decltype(_impl_.service_resolution_ema_latency_ms_){0u}
  };
}

TelemetryData_MdnsInfo::~TelemetryData_MdnsInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.MdnsInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_MdnsInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.host_registration_responses_;
  if (this != internal_default_instance()) delete _impl_.service_registration_responses_;
  if (this != internal_default_instance()) delete _impl_.host_resolution_responses_;
  if (this != internal_default_instance()) delete _impl_.service_resolution_responses_;
}

void TelemetryData_MdnsInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_MdnsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.MdnsInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.host_registration_responses_ != nullptr);
      _impl_.host_registration_responses_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.service_registration_responses_ != nullptr);
      _impl_.service_registration_responses_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.host_resolution_responses_ != nullptr);
      _impl_.host_resolution_responses_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.service_resolution_responses_ != nullptr);
      _impl_.service_resolution_responses_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.host_registration_ema_latency_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_resolution_ema_latency_ms_) -
        reinterpret_cast<char*>(&_impl_.host_registration_ema_latency_ms_)) + sizeof(_impl_.service_resolution_ema_latency_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_MdnsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_registration_responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_registration_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_registration_responses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_registration_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_resolution_responses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_resolution_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_resolution_responses = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_resolution_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 host_registration_ema_latency_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_host_registration_ema_latency_ms(&has_bits);
          _impl_.host_registration_ema_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_registration_ema_latency_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_service_registration_ema_latency_ms(&has_bits);
          _impl_.service_registration_ema_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 host_resolution_ema_latency_ms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_host_resolution_ema_latency_ms(&has_bits);
          _impl_.host_resolution_ema_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_resolution_ema_latency_ms = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_service_resolution_ema_latency_ms(&has_bits);
          _impl_.service_resolution_ema_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_MdnsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.MdnsInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_registration_responses = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::host_registration_responses(this),
        _Internal::host_registration_responses(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_registration_responses = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::service_registration_responses(this),
        _Internal::service_registration_responses(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_resolution_responses = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::host_resolution_responses(this),
        _Internal::host_resolution_responses(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_resolution_responses = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::service_resolution_responses(this),
        _Internal::service_resolution_responses(this).GetCachedSize(), target, stream);
  }

  // optional uint32 host_registration_ema_latency_ms = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_host_registration_ema_latency_ms(), target);
  }

  // optional uint32 service_registration_ema_latency_ms = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_service_registration_ema_latency_ms(), target);
  }

  // optional uint32 host_resolution_ema_latency_ms = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_host_resolution_ema_latency_ms(), target);
  }

  // optional uint32 service_resolution_ema_latency_ms = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_service_resolution_ema_latency_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.MdnsInfo)
  return target;
}

size_t TelemetryData_MdnsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.MdnsInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_registration_responses = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.host_registration_responses_);
    }

    // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_registration_responses = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.service_registration_responses_);
    }

    // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_resolution_responses = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.host_resolution_responses_);
    }

    // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_resolution_responses = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.service_resolution_responses_);
    }

    // optional uint32 host_registration_ema_latency_ms = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_host_registration_ema_latency_ms());
    }

    // optional uint32 service_registration_ema_latency_ms = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_registration_ema_latency_ms());
    }

    // optional uint32 host_resolution_ema_latency_ms = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_host_resolution_ema_latency_ms());
    }

    // optional uint32 service_resolution_ema_latency_ms = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_resolution_ema_latency_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_MdnsInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_MdnsInfo*>(
      &from));
}

void TelemetryData_MdnsInfo::MergeFrom(const TelemetryData_MdnsInfo& from) {
  TelemetryData_MdnsInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.MdnsInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_host_registration_responses()->::threadnetwork::TelemetryData_MdnsResponseCounters::MergeFrom(
          from._internal_host_registration_responses());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_service_registration_responses()->::threadnetwork::TelemetryData_MdnsResponseCounters::MergeFrom(
          from._internal_service_registration_responses());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_host_resolution_responses()->::threadnetwork::TelemetryData_MdnsResponseCounters::MergeFrom(
          from._internal_host_resolution_responses());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_service_resolution_responses()->::threadnetwork::TelemetryData_MdnsResponseCounters::MergeFrom(
          from._internal_service_resolution_responses());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.host_registration_ema_latency_ms_ = from._impl_.host_registration_ema_latency_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.service_registration_ema_latency_ms_ = from._impl_.service_registration_ema_latency_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.host_resolution_ema_latency_ms_ = from._impl_.host_resolution_ema_latency_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.service_resolution_ema_latency_ms_ = from._impl_.service_resolution_ema_latency_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_MdnsInfo::CopyFrom(const TelemetryData_MdnsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.MdnsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_MdnsInfo::IsInitialized() const {
  return true;
}

void TelemetryData_MdnsInfo::InternalSwap(TelemetryData_MdnsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_MdnsInfo, _impl_.service_resolution_ema_latency_ms_)
      + sizeof(TelemetryData_MdnsInfo::_impl_.service_resolution_ema_latency_ms_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_MdnsInfo, _impl_.host_registration_responses_)>(
          reinterpret_cast<char*>(&_impl_.host_registration_responses_),
          reinterpret_cast<char*>(&other->_impl_.host_registration_responses_));
}

std::string TelemetryData_MdnsInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.MdnsInfo";
}


// ===================================================================

class TelemetryData_BorderRoutingNat64State::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_BorderRoutingNat64State>()._impl_._has_bits_);
  static void set_has_prefix_manager_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_translator_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TelemetryData_BorderRoutingNat64State::TelemetryData_BorderRoutingNat64State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.BorderRoutingNat64State)
}
TelemetryData_BorderRoutingNat64State::TelemetryData_BorderRoutingNat64State(const TelemetryData_BorderRoutingNat64State& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_BorderRoutingNat64State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefix_manager_state_){}
    , decltype(_impl_.translator_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.prefix_manager_state_, &from._impl_.prefix_manager_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.translator_state_) -
    reinterpret_cast<char*>(&_impl_.prefix_manager_state_)) + sizeof(_impl_.translator_state_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.BorderRoutingNat64State)
}

inline void TelemetryData_BorderRoutingNat64State::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefix_manager_state_){0}
    , decltype(_impl_.translator_state_){0}
  };
}

TelemetryData_BorderRoutingNat64State::~TelemetryData_BorderRoutingNat64State() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.BorderRoutingNat64State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_BorderRoutingNat64State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_BorderRoutingNat64State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_BorderRoutingNat64State::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.BorderRoutingNat64State)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.prefix_manager_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.translator_state_) -
        reinterpret_cast<char*>(&_impl_.prefix_manager_state_)) + sizeof(_impl_.translator_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_BorderRoutingNat64State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.Nat64State prefix_manager_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_Nat64State_IsValid(val))) {
            _internal_set_prefix_manager_state(static_cast<::threadnetwork::TelemetryData_Nat64State>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64State translator_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_Nat64State_IsValid(val))) {
            _internal_set_translator_state(static_cast<::threadnetwork::TelemetryData_Nat64State>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_BorderRoutingNat64State::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.BorderRoutingNat64State)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.Nat64State prefix_manager_state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_prefix_manager_state(), target);
  }

  // optional .threadnetwork.TelemetryData.Nat64State translator_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_translator_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.BorderRoutingNat64State)
  return target;
}

size_t TelemetryData_BorderRoutingNat64State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.BorderRoutingNat64State)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .threadnetwork.TelemetryData.Nat64State prefix_manager_state = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_prefix_manager_state());
    }

    // optional .threadnetwork.TelemetryData.Nat64State translator_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_translator_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_BorderRoutingNat64State::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_BorderRoutingNat64State*>(
      &from));
}

void TelemetryData_BorderRoutingNat64State::MergeFrom(const TelemetryData_BorderRoutingNat64State& from) {
  TelemetryData_BorderRoutingNat64State* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.BorderRoutingNat64State)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.prefix_manager_state_ = from._impl_.prefix_manager_state_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.translator_state_ = from._impl_.translator_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_BorderRoutingNat64State::CopyFrom(const TelemetryData_BorderRoutingNat64State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.BorderRoutingNat64State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_BorderRoutingNat64State::IsInitialized() const {
  return true;
}

void TelemetryData_BorderRoutingNat64State::InternalSwap(TelemetryData_BorderRoutingNat64State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_BorderRoutingNat64State, _impl_.translator_state_)
      + sizeof(TelemetryData_BorderRoutingNat64State::_impl_.translator_state_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_BorderRoutingNat64State, _impl_.prefix_manager_state_)>(
          reinterpret_cast<char*>(&_impl_.prefix_manager_state_),
          reinterpret_cast<char*>(&other->_impl_.prefix_manager_state_));
}

std::string TelemetryData_BorderRoutingNat64State::GetTypeName() const {
  return "threadnetwork.TelemetryData.BorderRoutingNat64State";
}


// ===================================================================

class TelemetryData_Nat64Mapping::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_Nat64Mapping>()._impl_._has_bits_);
  static void set_has_mapping_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hashed_ipv6_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& counters(const TelemetryData_Nat64Mapping* msg);
  static void set_has_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::threadnetwork::TelemetryData_Nat64ProtocolCounters&
TelemetryData_Nat64Mapping::_Internal::counters(const TelemetryData_Nat64Mapping* msg) {
  return *msg->_impl_.counters_;
}
TelemetryData_Nat64Mapping::TelemetryData_Nat64Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.Nat64Mapping)
}
TelemetryData_Nat64Mapping::TelemetryData_Nat64Mapping(const TelemetryData_Nat64Mapping& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_Nat64Mapping* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hashed_ipv6_address_){}
    , decltype(_impl_.counters_){nullptr}
    , decltype(_impl_.mapping_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.hashed_ipv6_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_ipv6_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hashed_ipv6_address()) {
    _this->_impl_.hashed_ipv6_address_.Set(from._internal_hashed_ipv6_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_counters()) {
    _this->_impl_.counters_ = new ::threadnetwork::TelemetryData_Nat64ProtocolCounters(*from._impl_.counters_);
  }
  _this->_impl_.mapping_id_ = from._impl_.mapping_id_;
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.Nat64Mapping)
}

inline void TelemetryData_Nat64Mapping::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hashed_ipv6_address_){}
    , decltype(_impl_.counters_){nullptr}
    , decltype(_impl_.mapping_id_){uint64_t{0u}}
  };
  _impl_.hashed_ipv6_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_ipv6_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TelemetryData_Nat64Mapping::~TelemetryData_Nat64Mapping() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.Nat64Mapping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_Nat64Mapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hashed_ipv6_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.counters_;
}

void TelemetryData_Nat64Mapping::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_Nat64Mapping::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.Nat64Mapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hashed_ipv6_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.counters_ != nullptr);
      _impl_.counters_->Clear();
    }
  }
  _impl_.mapping_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_Nat64Mapping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 mapping_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mapping_id(&has_bits);
          _impl_.mapping_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hashed_ipv6_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hashed_ipv6_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters counters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_Nat64Mapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.Nat64Mapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 mapping_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_mapping_id(), target);
  }

  // optional bytes hashed_ipv6_address = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hashed_ipv6_address(), target);
  }

  // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters counters = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::counters(this),
        _Internal::counters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.Nat64Mapping)
  return target;
}

size_t TelemetryData_Nat64Mapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.Nat64Mapping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes hashed_ipv6_address = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hashed_ipv6_address());
    }

    // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters counters = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.counters_);
    }

    // optional uint64 mapping_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_mapping_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_Nat64Mapping::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_Nat64Mapping*>(
      &from));
}

void TelemetryData_Nat64Mapping::MergeFrom(const TelemetryData_Nat64Mapping& from) {
  TelemetryData_Nat64Mapping* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.Nat64Mapping)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hashed_ipv6_address(from._internal_hashed_ipv6_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_counters()->::threadnetwork::TelemetryData_Nat64ProtocolCounters::MergeFrom(
          from._internal_counters());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mapping_id_ = from._impl_.mapping_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_Nat64Mapping::CopyFrom(const TelemetryData_Nat64Mapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.Nat64Mapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_Nat64Mapping::IsInitialized() const {
  return true;
}

void TelemetryData_Nat64Mapping::InternalSwap(TelemetryData_Nat64Mapping* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hashed_ipv6_address_, lhs_arena,
      &other->_impl_.hashed_ipv6_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64Mapping, _impl_.mapping_id_)
      + sizeof(TelemetryData_Nat64Mapping::_impl_.mapping_id_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_Nat64Mapping, _impl_.counters_)>(
          reinterpret_cast<char*>(&_impl_.counters_),
          reinterpret_cast<char*>(&other->_impl_.counters_));
}

std::string TelemetryData_Nat64Mapping::GetTypeName() const {
  return "threadnetwork.TelemetryData.Nat64Mapping";
}


// ===================================================================

class TelemetryData_InfraLinkInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_InfraLinkInfo>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_up(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_running(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_multicast(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_link_local_address_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_unique_local_address_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_global_unicast_address_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

TelemetryData_InfraLinkInfo::TelemetryData_InfraLinkInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.InfraLinkInfo)
}
TelemetryData_InfraLinkInfo::TelemetryData_InfraLinkInfo(const TelemetryData_InfraLinkInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_InfraLinkInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.is_up_){}
    , decltype(_impl_.is_running_){}
    , decltype(_impl_.is_multicast_){}
    , decltype(_impl_.link_local_address_count_){}
    , decltype(_impl_.unique_local_address_count_){}
    , decltype(_impl_.global_unicast_address_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_up_, &from._impl_.is_up_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.global_unicast_address_count_) -
    reinterpret_cast<char*>(&_impl_.is_up_)) + sizeof(_impl_.global_unicast_address_count_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.InfraLinkInfo)
}

inline void TelemetryData_InfraLinkInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.is_up_){false}
    , decltype(_impl_.is_running_){false}
    , decltype(_impl_.is_multicast_){false}
    , decltype(_impl_.link_local_address_count_){0u}
    , decltype(_impl_.unique_local_address_count_){0u}
    , decltype(_impl_.global_unicast_address_count_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TelemetryData_InfraLinkInfo::~TelemetryData_InfraLinkInfo() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.InfraLinkInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_InfraLinkInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void TelemetryData_InfraLinkInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_InfraLinkInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.InfraLinkInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.is_up_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.global_unicast_address_count_) -
        reinterpret_cast<char*>(&_impl_.is_up_)) + sizeof(_impl_.global_unicast_address_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_InfraLinkInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_up = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_up(&has_bits);
          _impl_.is_up_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_running = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_running(&has_bits);
          _impl_.is_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_multicast = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_multicast(&has_bits);
          _impl_.is_multicast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_local_address_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_link_local_address_count(&has_bits);
          _impl_.link_local_address_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unique_local_address_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_unique_local_address_count(&has_bits);
          _impl_.unique_local_address_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 global_unicast_address_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_global_unicast_address_count(&has_bits);
          _impl_.global_unicast_address_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_InfraLinkInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.InfraLinkInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool is_up = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_up(), target);
  }

  // optional bool is_running = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_running(), target);
  }

  // optional bool is_multicast = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_multicast(), target);
  }

  // optional uint32 link_local_address_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_link_local_address_count(), target);
  }

  // optional uint32 unique_local_address_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_unique_local_address_count(), target);
  }

  // optional uint32 global_unicast_address_count = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_global_unicast_address_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.InfraLinkInfo)
  return target;
}

size_t TelemetryData_InfraLinkInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.InfraLinkInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool is_up = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_running = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_multicast = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 link_local_address_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_local_address_count());
    }

    // optional uint32 unique_local_address_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unique_local_address_count());
    }

    // optional uint32 global_unicast_address_count = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_global_unicast_address_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_InfraLinkInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_InfraLinkInfo*>(
      &from));
}

void TelemetryData_InfraLinkInfo::MergeFrom(const TelemetryData_InfraLinkInfo& from) {
  TelemetryData_InfraLinkInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.InfraLinkInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_up_ = from._impl_.is_up_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_running_ = from._impl_.is_running_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_multicast_ = from._impl_.is_multicast_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.link_local_address_count_ = from._impl_.link_local_address_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.unique_local_address_count_ = from._impl_.unique_local_address_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.global_unicast_address_count_ = from._impl_.global_unicast_address_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_InfraLinkInfo::CopyFrom(const TelemetryData_InfraLinkInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.InfraLinkInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_InfraLinkInfo::IsInitialized() const {
  return true;
}

void TelemetryData_InfraLinkInfo::InternalSwap(TelemetryData_InfraLinkInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_InfraLinkInfo, _impl_.global_unicast_address_count_)
      + sizeof(TelemetryData_InfraLinkInfo::_impl_.global_unicast_address_count_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_InfraLinkInfo, _impl_.is_up_)>(
          reinterpret_cast<char*>(&_impl_.is_up_),
          reinterpret_cast<char*>(&other->_impl_.is_up_));
}

std::string TelemetryData_InfraLinkInfo::GetTypeName() const {
  return "threadnetwork.TelemetryData.InfraLinkInfo";
}


// ===================================================================

class TelemetryData_WpanBorderRouter::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_WpanBorderRouter>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_BorderRoutingCounters& border_routing_counters(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_border_routing_counters(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_SrpServerInfo& srp_server(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_srp_server(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_DnsServerInfo& dns_server(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_dns_server(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::threadnetwork::TelemetryData_MdnsInfo& mdns(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_mdns(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::threadnetwork::TelemetryData_BorderRoutingNat64State& nat64_state(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_nat64_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dhcp6_pd_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_hashed_pd_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_PdProcessedRaInfo& pd_processed_ra_info(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_pd_processed_ra_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::threadnetwork::TelemetryData_TrelInfo& trel_info(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_trel_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::threadnetwork::TelemetryData_InfraLinkInfo& infra_link_info(const TelemetryData_WpanBorderRouter* msg);
  static void set_has_infra_link_info(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::threadnetwork::TelemetryData_BorderRoutingCounters&
TelemetryData_WpanBorderRouter::_Internal::border_routing_counters(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.border_routing_counters_;
}
const ::threadnetwork::TelemetryData_SrpServerInfo&
TelemetryData_WpanBorderRouter::_Internal::srp_server(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.srp_server_;
}
const ::threadnetwork::TelemetryData_DnsServerInfo&
TelemetryData_WpanBorderRouter::_Internal::dns_server(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.dns_server_;
}
const ::threadnetwork::TelemetryData_MdnsInfo&
TelemetryData_WpanBorderRouter::_Internal::mdns(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.mdns_;
}
const ::threadnetwork::TelemetryData_BorderRoutingNat64State&
TelemetryData_WpanBorderRouter::_Internal::nat64_state(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.nat64_state_;
}
const ::threadnetwork::TelemetryData_PdProcessedRaInfo&
TelemetryData_WpanBorderRouter::_Internal::pd_processed_ra_info(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.pd_processed_ra_info_;
}
const ::threadnetwork::TelemetryData_TrelInfo&
TelemetryData_WpanBorderRouter::_Internal::trel_info(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.trel_info_;
}
const ::threadnetwork::TelemetryData_InfraLinkInfo&
TelemetryData_WpanBorderRouter::_Internal::infra_link_info(const TelemetryData_WpanBorderRouter* msg) {
  return *msg->_impl_.infra_link_info_;
}
TelemetryData_WpanBorderRouter::TelemetryData_WpanBorderRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.WpanBorderRouter)
}
TelemetryData_WpanBorderRouter::TelemetryData_WpanBorderRouter(const TelemetryData_WpanBorderRouter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_WpanBorderRouter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nat64_mappings_){from._impl_.nat64_mappings_}
    , decltype(_impl_.hashed_pd_prefix_){}
    , decltype(_impl_.border_routing_counters_){nullptr}
    , decltype(_impl_.srp_server_){nullptr}
    , decltype(_impl_.dns_server_){nullptr}
    , decltype(_impl_.mdns_){nullptr}
    , decltype(_impl_.nat64_state_){nullptr}
    , decltype(_impl_.pd_processed_ra_info_){nullptr}
    , decltype(_impl_.trel_info_){nullptr}
    , decltype(_impl_.infra_link_info_){nullptr}
    , decltype(_impl_.dhcp6_pd_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.hashed_pd_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_pd_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hashed_pd_prefix()) {
    _this->_impl_.hashed_pd_prefix_.Set(from._internal_hashed_pd_prefix(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_border_routing_counters()) {
    _this->_impl_.border_routing_counters_ = new ::threadnetwork::TelemetryData_BorderRoutingCounters(*from._impl_.border_routing_counters_);
  }
  if (from._internal_has_srp_server()) {
    _this->_impl_.srp_server_ = new ::threadnetwork::TelemetryData_SrpServerInfo(*from._impl_.srp_server_);
  }
  if (from._internal_has_dns_server()) {
    _this->_impl_.dns_server_ = new ::threadnetwork::TelemetryData_DnsServerInfo(*from._impl_.dns_server_);
  }
  if (from._internal_has_mdns()) {
    _this->_impl_.mdns_ = new ::threadnetwork::TelemetryData_MdnsInfo(*from._impl_.mdns_);
  }
  if (from._internal_has_nat64_state()) {
    _this->_impl_.nat64_state_ = new ::threadnetwork::TelemetryData_BorderRoutingNat64State(*from._impl_.nat64_state_);
  }
  if (from._internal_has_pd_processed_ra_info()) {
    _this->_impl_.pd_processed_ra_info_ = new ::threadnetwork::TelemetryData_PdProcessedRaInfo(*from._impl_.pd_processed_ra_info_);
  }
  if (from._internal_has_trel_info()) {
    _this->_impl_.trel_info_ = new ::threadnetwork::TelemetryData_TrelInfo(*from._impl_.trel_info_);
  }
  if (from._internal_has_infra_link_info()) {
    _this->_impl_.infra_link_info_ = new ::threadnetwork::TelemetryData_InfraLinkInfo(*from._impl_.infra_link_info_);
  }
  _this->_impl_.dhcp6_pd_state_ = from._impl_.dhcp6_pd_state_;
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.WpanBorderRouter)
}

inline void TelemetryData_WpanBorderRouter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nat64_mappings_){arena}
    , decltype(_impl_.hashed_pd_prefix_){}
    , decltype(_impl_.border_routing_counters_){nullptr}
    , decltype(_impl_.srp_server_){nullptr}
    , decltype(_impl_.dns_server_){nullptr}
    , decltype(_impl_.mdns_){nullptr}
    , decltype(_impl_.nat64_state_){nullptr}
    , decltype(_impl_.pd_processed_ra_info_){nullptr}
    , decltype(_impl_.trel_info_){nullptr}
    , decltype(_impl_.infra_link_info_){nullptr}
    , decltype(_impl_.dhcp6_pd_state_){0}
  };
  _impl_.hashed_pd_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_pd_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TelemetryData_WpanBorderRouter::~TelemetryData_WpanBorderRouter() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.WpanBorderRouter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_WpanBorderRouter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nat64_mappings_.~RepeatedPtrField();
  _impl_.hashed_pd_prefix_.Destroy();
  if (this != internal_default_instance()) delete _impl_.border_routing_counters_;
  if (this != internal_default_instance()) delete _impl_.srp_server_;
  if (this != internal_default_instance()) delete _impl_.dns_server_;
  if (this != internal_default_instance()) delete _impl_.mdns_;
  if (this != internal_default_instance()) delete _impl_.nat64_state_;
  if (this != internal_default_instance()) delete _impl_.pd_processed_ra_info_;
  if (this != internal_default_instance()) delete _impl_.trel_info_;
  if (this != internal_default_instance()) delete _impl_.infra_link_info_;
}

void TelemetryData_WpanBorderRouter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_WpanBorderRouter::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.WpanBorderRouter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nat64_mappings_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hashed_pd_prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.border_routing_counters_ != nullptr);
      _impl_.border_routing_counters_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.srp_server_ != nullptr);
      _impl_.srp_server_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.dns_server_ != nullptr);
      _impl_.dns_server_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.mdns_ != nullptr);
      _impl_.mdns_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.nat64_state_ != nullptr);
      _impl_.nat64_state_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.pd_processed_ra_info_ != nullptr);
      _impl_.pd_processed_ra_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.trel_info_ != nullptr);
      _impl_.trel_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.infra_link_info_ != nullptr);
    _impl_.infra_link_info_->Clear();
  }
  _impl_.dhcp6_pd_state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_WpanBorderRouter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.BorderRoutingCounters border_routing_counters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_border_routing_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.SrpServerInfo srp_server = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_srp_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.DnsServerInfo dns_server = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dns_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.MdnsInfo mdns = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_mdns(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.BorderRoutingNat64State nat64_state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nat64_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .threadnetwork.TelemetryData.Nat64Mapping nat64_mappings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nat64_mappings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.Dhcp6PdState dhcp6_pd_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::threadnetwork::TelemetryData_Dhcp6PdState_IsValid(val))) {
            _internal_set_dhcp6_pd_state(static_cast<::threadnetwork::TelemetryData_Dhcp6PdState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes hashed_pd_prefix = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_hashed_pd_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.PdProcessedRaInfo pd_processed_ra_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pd_processed_ra_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.TrelInfo trel_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_trel_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.InfraLinkInfo infra_link_info = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_infra_link_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_WpanBorderRouter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.WpanBorderRouter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.BorderRoutingCounters border_routing_counters = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::border_routing_counters(this),
        _Internal::border_routing_counters(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.SrpServerInfo srp_server = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::srp_server(this),
        _Internal::srp_server(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.DnsServerInfo dns_server = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dns_server(this),
        _Internal::dns_server(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.MdnsInfo mdns = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::mdns(this),
        _Internal::mdns(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.BorderRoutingNat64State nat64_state = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::nat64_state(this),
        _Internal::nat64_state(this).GetCachedSize(), target, stream);
  }

  // repeated .threadnetwork.TelemetryData.Nat64Mapping nat64_mappings = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nat64_mappings_size()); i < n; i++) {
    const auto& repfield = this->_internal_nat64_mappings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.Dhcp6PdState dhcp6_pd_state = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_dhcp6_pd_state(), target);
  }

  // optional bytes hashed_pd_prefix = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_hashed_pd_prefix(), target);
  }

  // optional .threadnetwork.TelemetryData.PdProcessedRaInfo pd_processed_ra_info = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::pd_processed_ra_info(this),
        _Internal::pd_processed_ra_info(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.TrelInfo trel_info = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::trel_info(this),
        _Internal::trel_info(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.InfraLinkInfo infra_link_info = 12;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::infra_link_info(this),
        _Internal::infra_link_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.WpanBorderRouter)
  return target;
}

size_t TelemetryData_WpanBorderRouter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.WpanBorderRouter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .threadnetwork.TelemetryData.Nat64Mapping nat64_mappings = 7;
  total_size += 1UL * this->_internal_nat64_mappings_size();
  for (const auto& msg : this->_impl_.nat64_mappings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes hashed_pd_prefix = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hashed_pd_prefix());
    }

    // optional .threadnetwork.TelemetryData.BorderRoutingCounters border_routing_counters = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.border_routing_counters_);
    }

    // optional .threadnetwork.TelemetryData.SrpServerInfo srp_server = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.srp_server_);
    }

    // optional .threadnetwork.TelemetryData.DnsServerInfo dns_server = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dns_server_);
    }

    // optional .threadnetwork.TelemetryData.MdnsInfo mdns = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mdns_);
    }

    // optional .threadnetwork.TelemetryData.BorderRoutingNat64State nat64_state = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nat64_state_);
    }

    // optional .threadnetwork.TelemetryData.PdProcessedRaInfo pd_processed_ra_info = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pd_processed_ra_info_);
    }

    // optional .threadnetwork.TelemetryData.TrelInfo trel_info = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trel_info_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .threadnetwork.TelemetryData.InfraLinkInfo infra_link_info = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.infra_link_info_);
    }

    // optional .threadnetwork.TelemetryData.Dhcp6PdState dhcp6_pd_state = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_dhcp6_pd_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_WpanBorderRouter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_WpanBorderRouter*>(
      &from));
}

void TelemetryData_WpanBorderRouter::MergeFrom(const TelemetryData_WpanBorderRouter& from) {
  TelemetryData_WpanBorderRouter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.WpanBorderRouter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nat64_mappings_.MergeFrom(from._impl_.nat64_mappings_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hashed_pd_prefix(from._internal_hashed_pd_prefix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_border_routing_counters()->::threadnetwork::TelemetryData_BorderRoutingCounters::MergeFrom(
          from._internal_border_routing_counters());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_srp_server()->::threadnetwork::TelemetryData_SrpServerInfo::MergeFrom(
          from._internal_srp_server());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_dns_server()->::threadnetwork::TelemetryData_DnsServerInfo::MergeFrom(
          from._internal_dns_server());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_mdns()->::threadnetwork::TelemetryData_MdnsInfo::MergeFrom(
          from._internal_mdns());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_nat64_state()->::threadnetwork::TelemetryData_BorderRoutingNat64State::MergeFrom(
          from._internal_nat64_state());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_pd_processed_ra_info()->::threadnetwork::TelemetryData_PdProcessedRaInfo::MergeFrom(
          from._internal_pd_processed_ra_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_trel_info()->::threadnetwork::TelemetryData_TrelInfo::MergeFrom(
          from._internal_trel_info());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_infra_link_info()->::threadnetwork::TelemetryData_InfraLinkInfo::MergeFrom(
          from._internal_infra_link_info());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.dhcp6_pd_state_ = from._impl_.dhcp6_pd_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_WpanBorderRouter::CopyFrom(const TelemetryData_WpanBorderRouter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.WpanBorderRouter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_WpanBorderRouter::IsInitialized() const {
  return true;
}

void TelemetryData_WpanBorderRouter::InternalSwap(TelemetryData_WpanBorderRouter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nat64_mappings_.InternalSwap(&other->_impl_.nat64_mappings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hashed_pd_prefix_, lhs_arena,
      &other->_impl_.hashed_pd_prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_WpanBorderRouter, _impl_.dhcp6_pd_state_)
      + sizeof(TelemetryData_WpanBorderRouter::_impl_.dhcp6_pd_state_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_WpanBorderRouter, _impl_.border_routing_counters_)>(
          reinterpret_cast<char*>(&_impl_.border_routing_counters_),
          reinterpret_cast<char*>(&other->_impl_.border_routing_counters_));
}

std::string TelemetryData_WpanBorderRouter::GetTypeName() const {
  return "threadnetwork.TelemetryData.WpanBorderRouter";
}


// ===================================================================

class TelemetryData_RcpStabilityStatistics::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_RcpStabilityStatistics>()._impl_._has_bits_);
  static void set_has_rcp_timeout_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rcp_reset_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rcp_restoration_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_spinel_parse_error_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rcp_firmware_update_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_thread_stack_uptime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TelemetryData_RcpStabilityStatistics::TelemetryData_RcpStabilityStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.RcpStabilityStatistics)
}
TelemetryData_RcpStabilityStatistics::TelemetryData_RcpStabilityStatistics(const TelemetryData_RcpStabilityStatistics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_RcpStabilityStatistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rcp_timeout_count_){}
    , decltype(_impl_.rcp_reset_count_){}
    , decltype(_impl_.rcp_restoration_count_){}
    , decltype(_impl_.spinel_parse_error_count_){}
    , decltype(_impl_.rcp_firmware_update_count_){}
    , decltype(_impl_.thread_stack_uptime_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.rcp_timeout_count_, &from._impl_.rcp_timeout_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.thread_stack_uptime_) -
    reinterpret_cast<char*>(&_impl_.rcp_timeout_count_)) + sizeof(_impl_.thread_stack_uptime_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.RcpStabilityStatistics)
}

inline void TelemetryData_RcpStabilityStatistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rcp_timeout_count_){0u}
    , decltype(_impl_.rcp_reset_count_){0u}
    , decltype(_impl_.rcp_restoration_count_){0u}
    , decltype(_impl_.spinel_parse_error_count_){0u}
    , decltype(_impl_.rcp_firmware_update_count_){0}
    , decltype(_impl_.thread_stack_uptime_){0u}
  };
}

TelemetryData_RcpStabilityStatistics::~TelemetryData_RcpStabilityStatistics() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.RcpStabilityStatistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_RcpStabilityStatistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_RcpStabilityStatistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_RcpStabilityStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.RcpStabilityStatistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.rcp_timeout_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.thread_stack_uptime_) -
        reinterpret_cast<char*>(&_impl_.rcp_timeout_count_)) + sizeof(_impl_.thread_stack_uptime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_RcpStabilityStatistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rcp_timeout_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rcp_timeout_count(&has_bits);
          _impl_.rcp_timeout_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rcp_reset_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rcp_reset_count(&has_bits);
          _impl_.rcp_reset_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rcp_restoration_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rcp_restoration_count(&has_bits);
          _impl_.rcp_restoration_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 spinel_parse_error_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_spinel_parse_error_count(&has_bits);
          _impl_.spinel_parse_error_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rcp_firmware_update_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rcp_firmware_update_count(&has_bits);
          _impl_.rcp_firmware_update_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 thread_stack_uptime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_thread_stack_uptime(&has_bits);
          _impl_.thread_stack_uptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_RcpStabilityStatistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.RcpStabilityStatistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rcp_timeout_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rcp_timeout_count(), target);
  }

  // optional uint32 rcp_reset_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rcp_reset_count(), target);
  }

  // optional uint32 rcp_restoration_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rcp_restoration_count(), target);
  }

  // optional uint32 spinel_parse_error_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_spinel_parse_error_count(), target);
  }

  // optional int32 rcp_firmware_update_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rcp_firmware_update_count(), target);
  }

  // optional uint32 thread_stack_uptime = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_thread_stack_uptime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.RcpStabilityStatistics)
  return target;
}

size_t TelemetryData_RcpStabilityStatistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.RcpStabilityStatistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 rcp_timeout_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rcp_timeout_count());
    }

    // optional uint32 rcp_reset_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rcp_reset_count());
    }

    // optional uint32 rcp_restoration_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rcp_restoration_count());
    }

    // optional uint32 spinel_parse_error_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_spinel_parse_error_count());
    }

    // optional int32 rcp_firmware_update_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rcp_firmware_update_count());
    }

    // optional uint32 thread_stack_uptime = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_thread_stack_uptime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_RcpStabilityStatistics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_RcpStabilityStatistics*>(
      &from));
}

void TelemetryData_RcpStabilityStatistics::MergeFrom(const TelemetryData_RcpStabilityStatistics& from) {
  TelemetryData_RcpStabilityStatistics* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.RcpStabilityStatistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rcp_timeout_count_ = from._impl_.rcp_timeout_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rcp_reset_count_ = from._impl_.rcp_reset_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rcp_restoration_count_ = from._impl_.rcp_restoration_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.spinel_parse_error_count_ = from._impl_.spinel_parse_error_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rcp_firmware_update_count_ = from._impl_.rcp_firmware_update_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.thread_stack_uptime_ = from._impl_.thread_stack_uptime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_RcpStabilityStatistics::CopyFrom(const TelemetryData_RcpStabilityStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.RcpStabilityStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_RcpStabilityStatistics::IsInitialized() const {
  return true;
}

void TelemetryData_RcpStabilityStatistics::InternalSwap(TelemetryData_RcpStabilityStatistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_RcpStabilityStatistics, _impl_.thread_stack_uptime_)
      + sizeof(TelemetryData_RcpStabilityStatistics::_impl_.thread_stack_uptime_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_RcpStabilityStatistics, _impl_.rcp_timeout_count_)>(
          reinterpret_cast<char*>(&_impl_.rcp_timeout_count_),
          reinterpret_cast<char*>(&other->_impl_.rcp_timeout_count_));
}

std::string TelemetryData_RcpStabilityStatistics::GetTypeName() const {
  return "threadnetwork.TelemetryData.RcpStabilityStatistics";
}


// ===================================================================

class TelemetryData_RcpInterfaceStatistics::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_RcpInterfaceStatistics>()._impl_._has_bits_);
  static void set_has_rcp_interface_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_transferred_frames_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transferred_valid_frames_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transferred_garbage_frames_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rx_frames_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rx_bytes_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tx_frames_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tx_bytes_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

TelemetryData_RcpInterfaceStatistics::TelemetryData_RcpInterfaceStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.RcpInterfaceStatistics)
}
TelemetryData_RcpInterfaceStatistics::TelemetryData_RcpInterfaceStatistics(const TelemetryData_RcpInterfaceStatistics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_RcpInterfaceStatistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transferred_frames_count_){}
    , decltype(_impl_.transferred_valid_frames_count_){}
    , decltype(_impl_.transferred_garbage_frames_count_){}
    , decltype(_impl_.rx_frames_count_){}
    , decltype(_impl_.rx_bytes_count_){}
    , decltype(_impl_.tx_frames_count_){}
    , decltype(_impl_.tx_bytes_count_){}
    , decltype(_impl_.rcp_interface_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.transferred_frames_count_, &from._impl_.transferred_frames_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rcp_interface_type_) -
    reinterpret_cast<char*>(&_impl_.transferred_frames_count_)) + sizeof(_impl_.rcp_interface_type_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.RcpInterfaceStatistics)
}

inline void TelemetryData_RcpInterfaceStatistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transferred_frames_count_){uint64_t{0u}}
    , decltype(_impl_.transferred_valid_frames_count_){uint64_t{0u}}
    , decltype(_impl_.transferred_garbage_frames_count_){uint64_t{0u}}
    , decltype(_impl_.rx_frames_count_){uint64_t{0u}}
    , decltype(_impl_.rx_bytes_count_){uint64_t{0u}}
    , decltype(_impl_.tx_frames_count_){uint64_t{0u}}
    , decltype(_impl_.tx_bytes_count_){uint64_t{0u}}
    , decltype(_impl_.rcp_interface_type_){0u}
  };
}

TelemetryData_RcpInterfaceStatistics::~TelemetryData_RcpInterfaceStatistics() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_RcpInterfaceStatistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_RcpInterfaceStatistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_RcpInterfaceStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.transferred_frames_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rcp_interface_type_) -
        reinterpret_cast<char*>(&_impl_.transferred_frames_count_)) + sizeof(_impl_.rcp_interface_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_RcpInterfaceStatistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rcp_interface_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rcp_interface_type(&has_bits);
          _impl_.rcp_interface_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 transferred_frames_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_transferred_frames_count(&has_bits);
          _impl_.transferred_frames_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 transferred_valid_frames_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_transferred_valid_frames_count(&has_bits);
          _impl_.transferred_valid_frames_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 transferred_garbage_frames_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_transferred_garbage_frames_count(&has_bits);
          _impl_.transferred_garbage_frames_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 rx_frames_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rx_frames_count(&has_bits);
          _impl_.rx_frames_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 rx_bytes_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_rx_bytes_count(&has_bits);
          _impl_.rx_bytes_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tx_frames_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_tx_frames_count(&has_bits);
          _impl_.tx_frames_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tx_bytes_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_tx_bytes_count(&has_bits);
          _impl_.tx_bytes_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_RcpInterfaceStatistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rcp_interface_type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rcp_interface_type(), target);
  }

  // optional uint64 transferred_frames_count = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_transferred_frames_count(), target);
  }

  // optional uint64 transferred_valid_frames_count = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_transferred_valid_frames_count(), target);
  }

  // optional uint64 transferred_garbage_frames_count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_transferred_garbage_frames_count(), target);
  }

  // optional uint64 rx_frames_count = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_rx_frames_count(), target);
  }

  // optional uint64 rx_bytes_count = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_rx_bytes_count(), target);
  }

  // optional uint64 tx_frames_count = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_tx_frames_count(), target);
  }

  // optional uint64 tx_bytes_count = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_tx_bytes_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  return target;
}

size_t TelemetryData_RcpInterfaceStatistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 transferred_frames_count = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_transferred_frames_count());
    }

    // optional uint64 transferred_valid_frames_count = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_transferred_valid_frames_count());
    }

    // optional uint64 transferred_garbage_frames_count = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_transferred_garbage_frames_count());
    }

    // optional uint64 rx_frames_count = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_count());
    }

    // optional uint64 rx_bytes_count = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_bytes_count());
    }

    // optional uint64 tx_frames_count = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_frames_count());
    }

    // optional uint64 tx_bytes_count = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_bytes_count());
    }

    // optional uint32 rcp_interface_type = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rcp_interface_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_RcpInterfaceStatistics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_RcpInterfaceStatistics*>(
      &from));
}

void TelemetryData_RcpInterfaceStatistics::MergeFrom(const TelemetryData_RcpInterfaceStatistics& from) {
  TelemetryData_RcpInterfaceStatistics* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.transferred_frames_count_ = from._impl_.transferred_frames_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.transferred_valid_frames_count_ = from._impl_.transferred_valid_frames_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.transferred_garbage_frames_count_ = from._impl_.transferred_garbage_frames_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rx_frames_count_ = from._impl_.rx_frames_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rx_bytes_count_ = from._impl_.rx_bytes_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tx_frames_count_ = from._impl_.tx_frames_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tx_bytes_count_ = from._impl_.tx_bytes_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.rcp_interface_type_ = from._impl_.rcp_interface_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_RcpInterfaceStatistics::CopyFrom(const TelemetryData_RcpInterfaceStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.RcpInterfaceStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_RcpInterfaceStatistics::IsInitialized() const {
  return true;
}

void TelemetryData_RcpInterfaceStatistics::InternalSwap(TelemetryData_RcpInterfaceStatistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_RcpInterfaceStatistics, _impl_.rcp_interface_type_)
      + sizeof(TelemetryData_RcpInterfaceStatistics::_impl_.rcp_interface_type_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_RcpInterfaceStatistics, _impl_.transferred_frames_count_)>(
          reinterpret_cast<char*>(&_impl_.transferred_frames_count_),
          reinterpret_cast<char*>(&other->_impl_.transferred_frames_count_));
}

std::string TelemetryData_RcpInterfaceStatistics::GetTypeName() const {
  return "threadnetwork.TelemetryData.RcpInterfaceStatistics";
}


// ===================================================================

class TelemetryData_WpanRcp::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_WpanRcp>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_RcpStabilityStatistics& rcp_stability_statistics(const TelemetryData_WpanRcp* msg);
  static void set_has_rcp_stability_statistics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_RcpInterfaceStatistics& rcp_interface_statistics(const TelemetryData_WpanRcp* msg);
  static void set_has_rcp_interface_statistics(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::threadnetwork::TelemetryData_RcpStabilityStatistics&
TelemetryData_WpanRcp::_Internal::rcp_stability_statistics(const TelemetryData_WpanRcp* msg) {
  return *msg->_impl_.rcp_stability_statistics_;
}
const ::threadnetwork::TelemetryData_RcpInterfaceStatistics&
TelemetryData_WpanRcp::_Internal::rcp_interface_statistics(const TelemetryData_WpanRcp* msg) {
  return *msg->_impl_.rcp_interface_statistics_;
}
TelemetryData_WpanRcp::TelemetryData_WpanRcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.WpanRcp)
}
TelemetryData_WpanRcp::TelemetryData_WpanRcp(const TelemetryData_WpanRcp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_WpanRcp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rcp_stability_statistics_){nullptr}
    , decltype(_impl_.rcp_interface_statistics_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_rcp_stability_statistics()) {
    _this->_impl_.rcp_stability_statistics_ = new ::threadnetwork::TelemetryData_RcpStabilityStatistics(*from._impl_.rcp_stability_statistics_);
  }
  if (from._internal_has_rcp_interface_statistics()) {
    _this->_impl_.rcp_interface_statistics_ = new ::threadnetwork::TelemetryData_RcpInterfaceStatistics(*from._impl_.rcp_interface_statistics_);
  }
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.WpanRcp)
}

inline void TelemetryData_WpanRcp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rcp_stability_statistics_){nullptr}
    , decltype(_impl_.rcp_interface_statistics_){nullptr}
  };
}

TelemetryData_WpanRcp::~TelemetryData_WpanRcp() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.WpanRcp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_WpanRcp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rcp_stability_statistics_;
  if (this != internal_default_instance()) delete _impl_.rcp_interface_statistics_;
}

void TelemetryData_WpanRcp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_WpanRcp::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.WpanRcp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rcp_stability_statistics_ != nullptr);
      _impl_.rcp_stability_statistics_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rcp_interface_statistics_ != nullptr);
      _impl_.rcp_interface_statistics_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_WpanRcp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.RcpStabilityStatistics rcp_stability_statistics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rcp_stability_statistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.RcpInterfaceStatistics rcp_interface_statistics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rcp_interface_statistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_WpanRcp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.WpanRcp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.RcpStabilityStatistics rcp_stability_statistics = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rcp_stability_statistics(this),
        _Internal::rcp_stability_statistics(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.RcpInterfaceStatistics rcp_interface_statistics = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rcp_interface_statistics(this),
        _Internal::rcp_interface_statistics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.WpanRcp)
  return target;
}

size_t TelemetryData_WpanRcp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.WpanRcp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .threadnetwork.TelemetryData.RcpStabilityStatistics rcp_stability_statistics = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rcp_stability_statistics_);
    }

    // optional .threadnetwork.TelemetryData.RcpInterfaceStatistics rcp_interface_statistics = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rcp_interface_statistics_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_WpanRcp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_WpanRcp*>(
      &from));
}

void TelemetryData_WpanRcp::MergeFrom(const TelemetryData_WpanRcp& from) {
  TelemetryData_WpanRcp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.WpanRcp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rcp_stability_statistics()->::threadnetwork::TelemetryData_RcpStabilityStatistics::MergeFrom(
          from._internal_rcp_stability_statistics());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rcp_interface_statistics()->::threadnetwork::TelemetryData_RcpInterfaceStatistics::MergeFrom(
          from._internal_rcp_interface_statistics());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_WpanRcp::CopyFrom(const TelemetryData_WpanRcp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.WpanRcp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_WpanRcp::IsInitialized() const {
  return true;
}

void TelemetryData_WpanRcp::InternalSwap(TelemetryData_WpanRcp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_WpanRcp, _impl_.rcp_interface_statistics_)
      + sizeof(TelemetryData_WpanRcp::_impl_.rcp_interface_statistics_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_WpanRcp, _impl_.rcp_stability_statistics_)>(
          reinterpret_cast<char*>(&_impl_.rcp_stability_statistics_),
          reinterpret_cast<char*>(&other->_impl_.rcp_stability_statistics_));
}

std::string TelemetryData_WpanRcp::GetTypeName() const {
  return "threadnetwork.TelemetryData.WpanRcp";
}


// ===================================================================

class TelemetryData_CoexMetrics::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_CoexMetrics>()._impl_._has_bits_);
  static void set_has_count_tx_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count_tx_grant_immediate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count_tx_grant_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count_tx_grant_wait_activated(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_count_tx_grant_wait_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count_tx_grant_deactivated_during_request(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tx_average_request_to_grant_time_us(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_count_rx_request(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_count_rx_grant_immediate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_count_rx_grant_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_count_rx_grant_wait_activated(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_count_rx_grant_wait_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_count_rx_grant_deactivated_during_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_count_rx_grant_none(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_rx_average_request_to_grant_time_us(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

TelemetryData_CoexMetrics::TelemetryData_CoexMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.CoexMetrics)
}
TelemetryData_CoexMetrics::TelemetryData_CoexMetrics(const TelemetryData_CoexMetrics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_CoexMetrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.count_tx_request_){}
    , decltype(_impl_.count_tx_grant_immediate_){}
    , decltype(_impl_.count_tx_grant_wait_){}
    , decltype(_impl_.count_tx_grant_wait_activated_){}
    , decltype(_impl_.count_tx_grant_wait_timeout_){}
    , decltype(_impl_.count_tx_grant_deactivated_during_request_){}
    , decltype(_impl_.tx_average_request_to_grant_time_us_){}
    , decltype(_impl_.count_rx_request_){}
    , decltype(_impl_.count_rx_grant_immediate_){}
    , decltype(_impl_.count_rx_grant_wait_){}
    , decltype(_impl_.count_rx_grant_wait_activated_){}
    , decltype(_impl_.count_rx_grant_wait_timeout_){}
    , decltype(_impl_.count_rx_grant_deactivated_during_request_){}
    , decltype(_impl_.count_rx_grant_none_){}
    , decltype(_impl_.rx_average_request_to_grant_time_us_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.count_tx_request_, &from._impl_.count_tx_request_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rx_average_request_to_grant_time_us_) -
    reinterpret_cast<char*>(&_impl_.count_tx_request_)) + sizeof(_impl_.rx_average_request_to_grant_time_us_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.CoexMetrics)
}

inline void TelemetryData_CoexMetrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.count_tx_request_){0u}
    , decltype(_impl_.count_tx_grant_immediate_){0u}
    , decltype(_impl_.count_tx_grant_wait_){0u}
    , decltype(_impl_.count_tx_grant_wait_activated_){0u}
    , decltype(_impl_.count_tx_grant_wait_timeout_){0u}
    , decltype(_impl_.count_tx_grant_deactivated_during_request_){0u}
    , decltype(_impl_.tx_average_request_to_grant_time_us_){0u}
    , decltype(_impl_.count_rx_request_){0u}
    , decltype(_impl_.count_rx_grant_immediate_){0u}
    , decltype(_impl_.count_rx_grant_wait_){0u}
    , decltype(_impl_.count_rx_grant_wait_activated_){0u}
    , decltype(_impl_.count_rx_grant_wait_timeout_){0u}
    , decltype(_impl_.count_rx_grant_deactivated_during_request_){0u}
    , decltype(_impl_.count_rx_grant_none_){0u}
    , decltype(_impl_.rx_average_request_to_grant_time_us_){0u}
  };
}

TelemetryData_CoexMetrics::~TelemetryData_CoexMetrics() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.CoexMetrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_CoexMetrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_CoexMetrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_CoexMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.CoexMetrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.count_tx_request_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_rx_request_) -
        reinterpret_cast<char*>(&_impl_.count_tx_request_)) + sizeof(_impl_.count_rx_request_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.count_rx_grant_immediate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rx_average_request_to_grant_time_us_) -
        reinterpret_cast<char*>(&_impl_.count_rx_grant_immediate_)) + sizeof(_impl_.rx_average_request_to_grant_time_us_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_CoexMetrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 count_tx_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_count_tx_request(&has_bits);
          _impl_.count_tx_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_tx_grant_immediate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count_tx_grant_immediate(&has_bits);
          _impl_.count_tx_grant_immediate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_tx_grant_wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count_tx_grant_wait(&has_bits);
          _impl_.count_tx_grant_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_tx_grant_wait_activated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count_tx_grant_wait_activated(&has_bits);
          _impl_.count_tx_grant_wait_activated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_tx_grant_wait_timeout = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_count_tx_grant_wait_timeout(&has_bits);
          _impl_.count_tx_grant_wait_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_tx_grant_deactivated_during_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_count_tx_grant_deactivated_during_request(&has_bits);
          _impl_.count_tx_grant_deactivated_during_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tx_average_request_to_grant_time_us = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_tx_average_request_to_grant_time_us(&has_bits);
          _impl_.tx_average_request_to_grant_time_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_request = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_count_rx_request(&has_bits);
          _impl_.count_rx_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_immediate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_count_rx_grant_immediate(&has_bits);
          _impl_.count_rx_grant_immediate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_wait = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_count_rx_grant_wait(&has_bits);
          _impl_.count_rx_grant_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_wait_activated = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_count_rx_grant_wait_activated(&has_bits);
          _impl_.count_rx_grant_wait_activated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_wait_timeout = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_count_rx_grant_wait_timeout(&has_bits);
          _impl_.count_rx_grant_wait_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_deactivated_during_request = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_count_rx_grant_deactivated_during_request(&has_bits);
          _impl_.count_rx_grant_deactivated_during_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count_rx_grant_none = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_count_rx_grant_none(&has_bits);
          _impl_.count_rx_grant_none_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rx_average_request_to_grant_time_us = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_rx_average_request_to_grant_time_us(&has_bits);
          _impl_.rx_average_request_to_grant_time_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_CoexMetrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.CoexMetrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 count_tx_request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_count_tx_request(), target);
  }

  // optional uint32 count_tx_grant_immediate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count_tx_grant_immediate(), target);
  }

  // optional uint32 count_tx_grant_wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count_tx_grant_wait(), target);
  }

  // optional uint32 count_tx_grant_wait_activated = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count_tx_grant_wait_activated(), target);
  }

  // optional uint32 count_tx_grant_wait_timeout = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count_tx_grant_wait_timeout(), target);
  }

  // optional uint32 count_tx_grant_deactivated_during_request = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_count_tx_grant_deactivated_during_request(), target);
  }

  // optional uint32 tx_average_request_to_grant_time_us = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_tx_average_request_to_grant_time_us(), target);
  }

  // optional uint32 count_rx_request = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_count_rx_request(), target);
  }

  // optional uint32 count_rx_grant_immediate = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_count_rx_grant_immediate(), target);
  }

  // optional uint32 count_rx_grant_wait = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_count_rx_grant_wait(), target);
  }

  // optional uint32 count_rx_grant_wait_activated = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_count_rx_grant_wait_activated(), target);
  }

  // optional uint32 count_rx_grant_wait_timeout = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_count_rx_grant_wait_timeout(), target);
  }

  // optional uint32 count_rx_grant_deactivated_during_request = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_count_rx_grant_deactivated_during_request(), target);
  }

  // optional uint32 count_rx_grant_none = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_count_rx_grant_none(), target);
  }

  // optional uint32 rx_average_request_to_grant_time_us = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_rx_average_request_to_grant_time_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.CoexMetrics)
  return target;
}

size_t TelemetryData_CoexMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.CoexMetrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 count_tx_request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_request());
    }

    // optional uint32 count_tx_grant_immediate = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_grant_immediate());
    }

    // optional uint32 count_tx_grant_wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_grant_wait());
    }

    // optional uint32 count_tx_grant_wait_activated = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_grant_wait_activated());
    }

    // optional uint32 count_tx_grant_wait_timeout = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_grant_wait_timeout());
    }

    // optional uint32 count_tx_grant_deactivated_during_request = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_tx_grant_deactivated_during_request());
    }

    // optional uint32 tx_average_request_to_grant_time_us = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tx_average_request_to_grant_time_us());
    }

    // optional uint32 count_rx_request = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_request());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 count_rx_grant_immediate = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_immediate());
    }

    // optional uint32 count_rx_grant_wait = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_wait());
    }

    // optional uint32 count_rx_grant_wait_activated = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_wait_activated());
    }

    // optional uint32 count_rx_grant_wait_timeout = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_wait_timeout());
    }

    // optional uint32 count_rx_grant_deactivated_during_request = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_deactivated_during_request());
    }

    // optional uint32 count_rx_grant_none = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count_rx_grant_none());
    }

    // optional uint32 rx_average_request_to_grant_time_us = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rx_average_request_to_grant_time_us());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_CoexMetrics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_CoexMetrics*>(
      &from));
}

void TelemetryData_CoexMetrics::MergeFrom(const TelemetryData_CoexMetrics& from) {
  TelemetryData_CoexMetrics* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.CoexMetrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.count_tx_request_ = from._impl_.count_tx_request_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_tx_grant_immediate_ = from._impl_.count_tx_grant_immediate_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_tx_grant_wait_ = from._impl_.count_tx_grant_wait_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_tx_grant_wait_activated_ = from._impl_.count_tx_grant_wait_activated_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.count_tx_grant_wait_timeout_ = from._impl_.count_tx_grant_wait_timeout_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_tx_grant_deactivated_during_request_ = from._impl_.count_tx_grant_deactivated_during_request_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tx_average_request_to_grant_time_us_ = from._impl_.tx_average_request_to_grant_time_us_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.count_rx_request_ = from._impl_.count_rx_request_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.count_rx_grant_immediate_ = from._impl_.count_rx_grant_immediate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.count_rx_grant_wait_ = from._impl_.count_rx_grant_wait_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.count_rx_grant_wait_activated_ = from._impl_.count_rx_grant_wait_activated_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.count_rx_grant_wait_timeout_ = from._impl_.count_rx_grant_wait_timeout_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.count_rx_grant_deactivated_during_request_ = from._impl_.count_rx_grant_deactivated_during_request_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.count_rx_grant_none_ = from._impl_.count_rx_grant_none_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.rx_average_request_to_grant_time_us_ = from._impl_.rx_average_request_to_grant_time_us_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_CoexMetrics::CopyFrom(const TelemetryData_CoexMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.CoexMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_CoexMetrics::IsInitialized() const {
  return true;
}

void TelemetryData_CoexMetrics::InternalSwap(TelemetryData_CoexMetrics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_CoexMetrics, _impl_.rx_average_request_to_grant_time_us_)
      + sizeof(TelemetryData_CoexMetrics::_impl_.rx_average_request_to_grant_time_us_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_CoexMetrics, _impl_.count_tx_request_)>(
          reinterpret_cast<char*>(&_impl_.count_tx_request_),
          reinterpret_cast<char*>(&other->_impl_.count_tx_request_));
}

std::string TelemetryData_CoexMetrics::GetTypeName() const {
  return "threadnetwork.TelemetryData.CoexMetrics";
}


// ===================================================================

class TelemetryData_LinkMetricsEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData_LinkMetricsEntry>()._impl_._has_bits_);
  static void set_has_link_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rssi(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TelemetryData_LinkMetricsEntry::TelemetryData_LinkMetricsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.LinkMetricsEntry)
}
TelemetryData_LinkMetricsEntry::TelemetryData_LinkMetricsEntry(const TelemetryData_LinkMetricsEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_LinkMetricsEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_margin_){}
    , decltype(_impl_.rssi_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.link_margin_, &from._impl_.link_margin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rssi_) -
    reinterpret_cast<char*>(&_impl_.link_margin_)) + sizeof(_impl_.rssi_));
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.LinkMetricsEntry)
}

inline void TelemetryData_LinkMetricsEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_margin_){0}
    , decltype(_impl_.rssi_){0}
  };
}

TelemetryData_LinkMetricsEntry::~TelemetryData_LinkMetricsEntry() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.LinkMetricsEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_LinkMetricsEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TelemetryData_LinkMetricsEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_LinkMetricsEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.LinkMetricsEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.link_margin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rssi_) -
        reinterpret_cast<char*>(&_impl_.link_margin_)) + sizeof(_impl_.rssi_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_LinkMetricsEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 link_margin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_link_margin(&has_bits);
          _impl_.link_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rssi = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rssi(&has_bits);
          _impl_.rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_LinkMetricsEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.LinkMetricsEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 link_margin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_link_margin(), target);
  }

  // optional int32 rssi = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rssi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.LinkMetricsEntry)
  return target;
}

size_t TelemetryData_LinkMetricsEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.LinkMetricsEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 link_margin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_link_margin());
    }

    // optional int32 rssi = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rssi());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_LinkMetricsEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_LinkMetricsEntry*>(
      &from));
}

void TelemetryData_LinkMetricsEntry::MergeFrom(const TelemetryData_LinkMetricsEntry& from) {
  TelemetryData_LinkMetricsEntry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.LinkMetricsEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.link_margin_ = from._impl_.link_margin_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rssi_ = from._impl_.rssi_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_LinkMetricsEntry::CopyFrom(const TelemetryData_LinkMetricsEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.LinkMetricsEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_LinkMetricsEntry::IsInitialized() const {
  return true;
}

void TelemetryData_LinkMetricsEntry::InternalSwap(TelemetryData_LinkMetricsEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData_LinkMetricsEntry, _impl_.rssi_)
      + sizeof(TelemetryData_LinkMetricsEntry::_impl_.rssi_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData_LinkMetricsEntry, _impl_.link_margin_)>(
          reinterpret_cast<char*>(&_impl_.link_margin_),
          reinterpret_cast<char*>(&other->_impl_.link_margin_));
}

std::string TelemetryData_LinkMetricsEntry::GetTypeName() const {
  return "threadnetwork.TelemetryData.LinkMetricsEntry";
}


// ===================================================================

class TelemetryData_LowPowerMetrics::_Internal {
 public:
};

TelemetryData_LowPowerMetrics::TelemetryData_LowPowerMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData.LowPowerMetrics)
}
TelemetryData_LowPowerMetrics::TelemetryData_LowPowerMetrics(const TelemetryData_LowPowerMetrics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData_LowPowerMetrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.link_metrics_entries_){from._impl_.link_metrics_entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData.LowPowerMetrics)
}

inline void TelemetryData_LowPowerMetrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.link_metrics_entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TelemetryData_LowPowerMetrics::~TelemetryData_LowPowerMetrics() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData.LowPowerMetrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData_LowPowerMetrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.link_metrics_entries_.~RepeatedPtrField();
}

void TelemetryData_LowPowerMetrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData_LowPowerMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData.LowPowerMetrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.link_metrics_entries_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData_LowPowerMetrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .threadnetwork.TelemetryData.LinkMetricsEntry link_metrics_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_link_metrics_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData_LowPowerMetrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData.LowPowerMetrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .threadnetwork.TelemetryData.LinkMetricsEntry link_metrics_entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_link_metrics_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_link_metrics_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData.LowPowerMetrics)
  return target;
}

size_t TelemetryData_LowPowerMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData.LowPowerMetrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .threadnetwork.TelemetryData.LinkMetricsEntry link_metrics_entries = 1;
  total_size += 1UL * this->_internal_link_metrics_entries_size();
  for (const auto& msg : this->_impl_.link_metrics_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData_LowPowerMetrics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData_LowPowerMetrics*>(
      &from));
}

void TelemetryData_LowPowerMetrics::MergeFrom(const TelemetryData_LowPowerMetrics& from) {
  TelemetryData_LowPowerMetrics* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData.LowPowerMetrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.link_metrics_entries_.MergeFrom(from._impl_.link_metrics_entries_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData_LowPowerMetrics::CopyFrom(const TelemetryData_LowPowerMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData.LowPowerMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData_LowPowerMetrics::IsInitialized() const {
  return true;
}

void TelemetryData_LowPowerMetrics::InternalSwap(TelemetryData_LowPowerMetrics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.link_metrics_entries_.InternalSwap(&other->_impl_.link_metrics_entries_);
}

std::string TelemetryData_LowPowerMetrics::GetTypeName() const {
  return "threadnetwork.TelemetryData.LowPowerMetrics";
}


// ===================================================================

class TelemetryData::_Internal {
 public:
  using HasBits = decltype(std::declval<TelemetryData>()._impl_._has_bits_);
  static const ::threadnetwork::TelemetryData_WpanStats& wpan_stats(const TelemetryData* msg);
  static void set_has_wpan_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::threadnetwork::TelemetryData_WpanTopoFull& wpan_topo_full(const TelemetryData* msg);
  static void set_has_wpan_topo_full(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::threadnetwork::TelemetryData_WpanBorderRouter& wpan_border_router(const TelemetryData* msg);
  static void set_has_wpan_border_router(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::threadnetwork::TelemetryData_WpanRcp& wpan_rcp(const TelemetryData* msg);
  static void set_has_wpan_rcp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::threadnetwork::TelemetryData_CoexMetrics& coex_metrics(const TelemetryData* msg);
  static void set_has_coex_metrics(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::threadnetwork::TelemetryData_LowPowerMetrics& low_power_metrics(const TelemetryData* msg);
  static void set_has_low_power_metrics(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::threadnetwork::TelemetryData_WpanStats&
TelemetryData::_Internal::wpan_stats(const TelemetryData* msg) {
  return *msg->_impl_.wpan_stats_;
}
const ::threadnetwork::TelemetryData_WpanTopoFull&
TelemetryData::_Internal::wpan_topo_full(const TelemetryData* msg) {
  return *msg->_impl_.wpan_topo_full_;
}
const ::threadnetwork::TelemetryData_WpanBorderRouter&
TelemetryData::_Internal::wpan_border_router(const TelemetryData* msg) {
  return *msg->_impl_.wpan_border_router_;
}
const ::threadnetwork::TelemetryData_WpanRcp&
TelemetryData::_Internal::wpan_rcp(const TelemetryData* msg) {
  return *msg->_impl_.wpan_rcp_;
}
const ::threadnetwork::TelemetryData_CoexMetrics&
TelemetryData::_Internal::coex_metrics(const TelemetryData* msg) {
  return *msg->_impl_.coex_metrics_;
}
const ::threadnetwork::TelemetryData_LowPowerMetrics&
TelemetryData::_Internal::low_power_metrics(const TelemetryData* msg) {
  return *msg->_impl_.low_power_metrics_;
}
TelemetryData::TelemetryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:threadnetwork.TelemetryData)
}
TelemetryData::TelemetryData(const TelemetryData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TelemetryData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.topo_entries_){from._impl_.topo_entries_}
    , decltype(_impl_.wpan_stats_){nullptr}
    , decltype(_impl_.wpan_topo_full_){nullptr}
    , decltype(_impl_.wpan_border_router_){nullptr}
    , decltype(_impl_.wpan_rcp_){nullptr}
    , decltype(_impl_.coex_metrics_){nullptr}
    , decltype(_impl_.low_power_metrics_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_wpan_stats()) {
    _this->_impl_.wpan_stats_ = new ::threadnetwork::TelemetryData_WpanStats(*from._impl_.wpan_stats_);
  }
  if (from._internal_has_wpan_topo_full()) {
    _this->_impl_.wpan_topo_full_ = new ::threadnetwork::TelemetryData_WpanTopoFull(*from._impl_.wpan_topo_full_);
  }
  if (from._internal_has_wpan_border_router()) {
    _this->_impl_.wpan_border_router_ = new ::threadnetwork::TelemetryData_WpanBorderRouter(*from._impl_.wpan_border_router_);
  }
  if (from._internal_has_wpan_rcp()) {
    _this->_impl_.wpan_rcp_ = new ::threadnetwork::TelemetryData_WpanRcp(*from._impl_.wpan_rcp_);
  }
  if (from._internal_has_coex_metrics()) {
    _this->_impl_.coex_metrics_ = new ::threadnetwork::TelemetryData_CoexMetrics(*from._impl_.coex_metrics_);
  }
  if (from._internal_has_low_power_metrics()) {
    _this->_impl_.low_power_metrics_ = new ::threadnetwork::TelemetryData_LowPowerMetrics(*from._impl_.low_power_metrics_);
  }
  // @@protoc_insertion_point(copy_constructor:threadnetwork.TelemetryData)
}

inline void TelemetryData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.topo_entries_){arena}
    , decltype(_impl_.wpan_stats_){nullptr}
    , decltype(_impl_.wpan_topo_full_){nullptr}
    , decltype(_impl_.wpan_border_router_){nullptr}
    , decltype(_impl_.wpan_rcp_){nullptr}
    , decltype(_impl_.coex_metrics_){nullptr}
    , decltype(_impl_.low_power_metrics_){nullptr}
  };
}

TelemetryData::~TelemetryData() {
  // @@protoc_insertion_point(destructor:threadnetwork.TelemetryData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TelemetryData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.topo_entries_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.wpan_stats_;
  if (this != internal_default_instance()) delete _impl_.wpan_topo_full_;
  if (this != internal_default_instance()) delete _impl_.wpan_border_router_;
  if (this != internal_default_instance()) delete _impl_.wpan_rcp_;
  if (this != internal_default_instance()) delete _impl_.coex_metrics_;
  if (this != internal_default_instance()) delete _impl_.low_power_metrics_;
}

void TelemetryData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TelemetryData::Clear() {
// @@protoc_insertion_point(message_clear_start:threadnetwork.TelemetryData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.topo_entries_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.wpan_stats_ != nullptr);
      _impl_.wpan_stats_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.wpan_topo_full_ != nullptr);
      _impl_.wpan_topo_full_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.wpan_border_router_ != nullptr);
      _impl_.wpan_border_router_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.wpan_rcp_ != nullptr);
      _impl_.wpan_rcp_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.coex_metrics_ != nullptr);
      _impl_.coex_metrics_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.low_power_metrics_ != nullptr);
      _impl_.low_power_metrics_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .threadnetwork.TelemetryData.WpanStats wpan_stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_wpan_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.WpanTopoFull wpan_topo_full = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wpan_topo_full(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .threadnetwork.TelemetryData.TopoEntry topo_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_topo_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.WpanBorderRouter wpan_border_router = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_wpan_border_router(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.WpanRcp wpan_rcp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_wpan_rcp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.CoexMetrics coex_metrics = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_coex_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .threadnetwork.TelemetryData.LowPowerMetrics low_power_metrics = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_low_power_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TelemetryData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:threadnetwork.TelemetryData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .threadnetwork.TelemetryData.WpanStats wpan_stats = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::wpan_stats(this),
        _Internal::wpan_stats(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.WpanTopoFull wpan_topo_full = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::wpan_topo_full(this),
        _Internal::wpan_topo_full(this).GetCachedSize(), target, stream);
  }

  // repeated .threadnetwork.TelemetryData.TopoEntry topo_entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_topo_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_topo_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.WpanBorderRouter wpan_border_router = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::wpan_border_router(this),
        _Internal::wpan_border_router(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.WpanRcp wpan_rcp = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::wpan_rcp(this),
        _Internal::wpan_rcp(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.CoexMetrics coex_metrics = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::coex_metrics(this),
        _Internal::coex_metrics(this).GetCachedSize(), target, stream);
  }

  // optional .threadnetwork.TelemetryData.LowPowerMetrics low_power_metrics = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::low_power_metrics(this),
        _Internal::low_power_metrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:threadnetwork.TelemetryData)
  return target;
}

size_t TelemetryData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:threadnetwork.TelemetryData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .threadnetwork.TelemetryData.TopoEntry topo_entries = 3;
  total_size += 1UL * this->_internal_topo_entries_size();
  for (const auto& msg : this->_impl_.topo_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .threadnetwork.TelemetryData.WpanStats wpan_stats = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wpan_stats_);
    }

    // optional .threadnetwork.TelemetryData.WpanTopoFull wpan_topo_full = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wpan_topo_full_);
    }

    // optional .threadnetwork.TelemetryData.WpanBorderRouter wpan_border_router = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wpan_border_router_);
    }

    // optional .threadnetwork.TelemetryData.WpanRcp wpan_rcp = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wpan_rcp_);
    }

    // optional .threadnetwork.TelemetryData.CoexMetrics coex_metrics = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.coex_metrics_);
    }

    // optional .threadnetwork.TelemetryData.LowPowerMetrics low_power_metrics = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.low_power_metrics_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TelemetryData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TelemetryData*>(
      &from));
}

void TelemetryData::MergeFrom(const TelemetryData& from) {
  TelemetryData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:threadnetwork.TelemetryData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.topo_entries_.MergeFrom(from._impl_.topo_entries_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_wpan_stats()->::threadnetwork::TelemetryData_WpanStats::MergeFrom(
          from._internal_wpan_stats());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_wpan_topo_full()->::threadnetwork::TelemetryData_WpanTopoFull::MergeFrom(
          from._internal_wpan_topo_full());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_wpan_border_router()->::threadnetwork::TelemetryData_WpanBorderRouter::MergeFrom(
          from._internal_wpan_border_router());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_wpan_rcp()->::threadnetwork::TelemetryData_WpanRcp::MergeFrom(
          from._internal_wpan_rcp());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_coex_metrics()->::threadnetwork::TelemetryData_CoexMetrics::MergeFrom(
          from._internal_coex_metrics());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_low_power_metrics()->::threadnetwork::TelemetryData_LowPowerMetrics::MergeFrom(
          from._internal_low_power_metrics());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData::CopyFrom(const TelemetryData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:threadnetwork.TelemetryData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TelemetryData::IsInitialized() const {
  return true;
}

void TelemetryData::InternalSwap(TelemetryData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.topo_entries_.InternalSwap(&other->_impl_.topo_entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TelemetryData, _impl_.low_power_metrics_)
      + sizeof(TelemetryData::_impl_.low_power_metrics_)
      - PROTOBUF_FIELD_OFFSET(TelemetryData, _impl_.wpan_stats_)>(
          reinterpret_cast<char*>(&_impl_.wpan_stats_),
          reinterpret_cast<char*>(&other->_impl_.wpan_stats_));
}

std::string TelemetryData::GetTypeName() const {
  return "threadnetwork.TelemetryData";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace threadnetwork
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Duration*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Duration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Duration >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_WpanStats*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_WpanStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_WpanStats >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_WpanTopoFull*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_WpanTopoFull >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_WpanTopoFull >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_TopoEntry*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_TopoEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_TopoEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_PacketsAndBytes*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_PacketsAndBytes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_PacketsAndBytes >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Nat64TrafficCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Nat64TrafficCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Nat64TrafficCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Nat64ProtocolCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Nat64ProtocolCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Nat64ProtocolCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Nat64PacketCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Nat64PacketCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Nat64PacketCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Nat64ErrorCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Nat64ErrorCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Nat64ErrorCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_BorderRoutingCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_BorderRoutingCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_BorderRoutingCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_PdProcessedRaInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_PdProcessedRaInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_PdProcessedRaInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_SrpServerRegistrationInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_SrpServerRegistrationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_SrpServerRegistrationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_SrpServerResponseCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_SrpServerResponseCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_SrpServerResponseCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_SrpServerInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_SrpServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_SrpServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_TrelPacketCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_TrelPacketCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_TrelPacketCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_TrelInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_TrelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_TrelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_DnsServerResponseCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_DnsServerResponseCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_DnsServerResponseCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_DnsServerInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_DnsServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_DnsServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_MdnsResponseCounters*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_MdnsResponseCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_MdnsResponseCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_MdnsInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_MdnsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_MdnsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_BorderRoutingNat64State*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_BorderRoutingNat64State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_BorderRoutingNat64State >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_Nat64Mapping*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_Nat64Mapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_Nat64Mapping >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_InfraLinkInfo*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_InfraLinkInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_InfraLinkInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_WpanBorderRouter*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_WpanBorderRouter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_WpanBorderRouter >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_RcpStabilityStatistics*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_RcpStabilityStatistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_RcpStabilityStatistics >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_RcpInterfaceStatistics*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_RcpInterfaceStatistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_RcpInterfaceStatistics >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_WpanRcp*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_WpanRcp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_WpanRcp >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_CoexMetrics*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_CoexMetrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_CoexMetrics >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_LinkMetricsEntry*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_LinkMetricsEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_LinkMetricsEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData_LowPowerMetrics*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData_LowPowerMetrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData_LowPowerMetrics >(arena);
}
template<> PROTOBUF_NOINLINE ::threadnetwork::TelemetryData*
Arena::CreateMaybeMessage< ::threadnetwork::TelemetryData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::threadnetwork::TelemetryData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
