// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: thread_telemetry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_thread_5ftelemetry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_thread_5ftelemetry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_thread_5ftelemetry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_thread_5ftelemetry_2eproto {
  static const uint32_t offsets[];
};
namespace threadnetwork {
class TelemetryData;
struct TelemetryDataDefaultTypeInternal;
extern TelemetryDataDefaultTypeInternal _TelemetryData_default_instance_;
class TelemetryData_BorderRoutingCounters;
struct TelemetryData_BorderRoutingCountersDefaultTypeInternal;
extern TelemetryData_BorderRoutingCountersDefaultTypeInternal _TelemetryData_BorderRoutingCounters_default_instance_;
class TelemetryData_BorderRoutingNat64State;
struct TelemetryData_BorderRoutingNat64StateDefaultTypeInternal;
extern TelemetryData_BorderRoutingNat64StateDefaultTypeInternal _TelemetryData_BorderRoutingNat64State_default_instance_;
class TelemetryData_CoexMetrics;
struct TelemetryData_CoexMetricsDefaultTypeInternal;
extern TelemetryData_CoexMetricsDefaultTypeInternal _TelemetryData_CoexMetrics_default_instance_;
class TelemetryData_DnsServerInfo;
struct TelemetryData_DnsServerInfoDefaultTypeInternal;
extern TelemetryData_DnsServerInfoDefaultTypeInternal _TelemetryData_DnsServerInfo_default_instance_;
class TelemetryData_DnsServerResponseCounters;
struct TelemetryData_DnsServerResponseCountersDefaultTypeInternal;
extern TelemetryData_DnsServerResponseCountersDefaultTypeInternal _TelemetryData_DnsServerResponseCounters_default_instance_;
class TelemetryData_Duration;
struct TelemetryData_DurationDefaultTypeInternal;
extern TelemetryData_DurationDefaultTypeInternal _TelemetryData_Duration_default_instance_;
class TelemetryData_InfraLinkInfo;
struct TelemetryData_InfraLinkInfoDefaultTypeInternal;
extern TelemetryData_InfraLinkInfoDefaultTypeInternal _TelemetryData_InfraLinkInfo_default_instance_;
class TelemetryData_LinkMetricsEntry;
struct TelemetryData_LinkMetricsEntryDefaultTypeInternal;
extern TelemetryData_LinkMetricsEntryDefaultTypeInternal _TelemetryData_LinkMetricsEntry_default_instance_;
class TelemetryData_LowPowerMetrics;
struct TelemetryData_LowPowerMetricsDefaultTypeInternal;
extern TelemetryData_LowPowerMetricsDefaultTypeInternal _TelemetryData_LowPowerMetrics_default_instance_;
class TelemetryData_MdnsInfo;
struct TelemetryData_MdnsInfoDefaultTypeInternal;
extern TelemetryData_MdnsInfoDefaultTypeInternal _TelemetryData_MdnsInfo_default_instance_;
class TelemetryData_MdnsResponseCounters;
struct TelemetryData_MdnsResponseCountersDefaultTypeInternal;
extern TelemetryData_MdnsResponseCountersDefaultTypeInternal _TelemetryData_MdnsResponseCounters_default_instance_;
class TelemetryData_Nat64ErrorCounters;
struct TelemetryData_Nat64ErrorCountersDefaultTypeInternal;
extern TelemetryData_Nat64ErrorCountersDefaultTypeInternal _TelemetryData_Nat64ErrorCounters_default_instance_;
class TelemetryData_Nat64Mapping;
struct TelemetryData_Nat64MappingDefaultTypeInternal;
extern TelemetryData_Nat64MappingDefaultTypeInternal _TelemetryData_Nat64Mapping_default_instance_;
class TelemetryData_Nat64PacketCounters;
struct TelemetryData_Nat64PacketCountersDefaultTypeInternal;
extern TelemetryData_Nat64PacketCountersDefaultTypeInternal _TelemetryData_Nat64PacketCounters_default_instance_;
class TelemetryData_Nat64ProtocolCounters;
struct TelemetryData_Nat64ProtocolCountersDefaultTypeInternal;
extern TelemetryData_Nat64ProtocolCountersDefaultTypeInternal _TelemetryData_Nat64ProtocolCounters_default_instance_;
class TelemetryData_Nat64TrafficCounters;
struct TelemetryData_Nat64TrafficCountersDefaultTypeInternal;
extern TelemetryData_Nat64TrafficCountersDefaultTypeInternal _TelemetryData_Nat64TrafficCounters_default_instance_;
class TelemetryData_PacketsAndBytes;
struct TelemetryData_PacketsAndBytesDefaultTypeInternal;
extern TelemetryData_PacketsAndBytesDefaultTypeInternal _TelemetryData_PacketsAndBytes_default_instance_;
class TelemetryData_PdProcessedRaInfo;
struct TelemetryData_PdProcessedRaInfoDefaultTypeInternal;
extern TelemetryData_PdProcessedRaInfoDefaultTypeInternal _TelemetryData_PdProcessedRaInfo_default_instance_;
class TelemetryData_RcpInterfaceStatistics;
struct TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal;
extern TelemetryData_RcpInterfaceStatisticsDefaultTypeInternal _TelemetryData_RcpInterfaceStatistics_default_instance_;
class TelemetryData_RcpStabilityStatistics;
struct TelemetryData_RcpStabilityStatisticsDefaultTypeInternal;
extern TelemetryData_RcpStabilityStatisticsDefaultTypeInternal _TelemetryData_RcpStabilityStatistics_default_instance_;
class TelemetryData_SrpServerInfo;
struct TelemetryData_SrpServerInfoDefaultTypeInternal;
extern TelemetryData_SrpServerInfoDefaultTypeInternal _TelemetryData_SrpServerInfo_default_instance_;
class TelemetryData_SrpServerRegistrationInfo;
struct TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal;
extern TelemetryData_SrpServerRegistrationInfoDefaultTypeInternal _TelemetryData_SrpServerRegistrationInfo_default_instance_;
class TelemetryData_SrpServerResponseCounters;
struct TelemetryData_SrpServerResponseCountersDefaultTypeInternal;
extern TelemetryData_SrpServerResponseCountersDefaultTypeInternal _TelemetryData_SrpServerResponseCounters_default_instance_;
class TelemetryData_TopoEntry;
struct TelemetryData_TopoEntryDefaultTypeInternal;
extern TelemetryData_TopoEntryDefaultTypeInternal _TelemetryData_TopoEntry_default_instance_;
class TelemetryData_TrelInfo;
struct TelemetryData_TrelInfoDefaultTypeInternal;
extern TelemetryData_TrelInfoDefaultTypeInternal _TelemetryData_TrelInfo_default_instance_;
class TelemetryData_TrelPacketCounters;
struct TelemetryData_TrelPacketCountersDefaultTypeInternal;
extern TelemetryData_TrelPacketCountersDefaultTypeInternal _TelemetryData_TrelPacketCounters_default_instance_;
class TelemetryData_WpanBorderRouter;
struct TelemetryData_WpanBorderRouterDefaultTypeInternal;
extern TelemetryData_WpanBorderRouterDefaultTypeInternal _TelemetryData_WpanBorderRouter_default_instance_;
class TelemetryData_WpanRcp;
struct TelemetryData_WpanRcpDefaultTypeInternal;
extern TelemetryData_WpanRcpDefaultTypeInternal _TelemetryData_WpanRcp_default_instance_;
class TelemetryData_WpanStats;
struct TelemetryData_WpanStatsDefaultTypeInternal;
extern TelemetryData_WpanStatsDefaultTypeInternal _TelemetryData_WpanStats_default_instance_;
class TelemetryData_WpanTopoFull;
struct TelemetryData_WpanTopoFullDefaultTypeInternal;
extern TelemetryData_WpanTopoFullDefaultTypeInternal _TelemetryData_WpanTopoFull_default_instance_;
}  // namespace threadnetwork
PROTOBUF_NAMESPACE_OPEN
template<> ::threadnetwork::TelemetryData* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData>(Arena*);
template<> ::threadnetwork::TelemetryData_BorderRoutingCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_BorderRoutingCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_BorderRoutingNat64State* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_BorderRoutingNat64State>(Arena*);
template<> ::threadnetwork::TelemetryData_CoexMetrics* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_CoexMetrics>(Arena*);
template<> ::threadnetwork::TelemetryData_DnsServerInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_DnsServerInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_DnsServerResponseCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_DnsServerResponseCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_Duration* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Duration>(Arena*);
template<> ::threadnetwork::TelemetryData_InfraLinkInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_InfraLinkInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_LinkMetricsEntry* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_LinkMetricsEntry>(Arena*);
template<> ::threadnetwork::TelemetryData_LowPowerMetrics* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_LowPowerMetrics>(Arena*);
template<> ::threadnetwork::TelemetryData_MdnsInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_MdnsResponseCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsResponseCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_Nat64ErrorCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64ErrorCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_Nat64Mapping* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64Mapping>(Arena*);
template<> ::threadnetwork::TelemetryData_Nat64PacketCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64PacketCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_Nat64ProtocolCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64ProtocolCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_Nat64TrafficCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64TrafficCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_PacketsAndBytes* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(Arena*);
template<> ::threadnetwork::TelemetryData_PdProcessedRaInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_PdProcessedRaInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_RcpInterfaceStatistics* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_RcpInterfaceStatistics>(Arena*);
template<> ::threadnetwork::TelemetryData_RcpStabilityStatistics* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_RcpStabilityStatistics>(Arena*);
template<> ::threadnetwork::TelemetryData_SrpServerInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerRegistrationInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_SrpServerResponseCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerResponseCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_TopoEntry* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_TopoEntry>(Arena*);
template<> ::threadnetwork::TelemetryData_TrelInfo* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_TrelInfo>(Arena*);
template<> ::threadnetwork::TelemetryData_TrelPacketCounters* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_TrelPacketCounters>(Arena*);
template<> ::threadnetwork::TelemetryData_WpanBorderRouter* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_WpanBorderRouter>(Arena*);
template<> ::threadnetwork::TelemetryData_WpanRcp* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_WpanRcp>(Arena*);
template<> ::threadnetwork::TelemetryData_WpanStats* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_WpanStats>(Arena*);
template<> ::threadnetwork::TelemetryData_WpanTopoFull* Arena::CreateMaybeMessage<::threadnetwork::TelemetryData_WpanTopoFull>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace threadnetwork {

enum TelemetryData_NodeType : int {
  TelemetryData_NodeType_NODE_TYPE_UNSPECIFIED = 0,
  TelemetryData_NodeType_NODE_TYPE_ROUTER = 1,
  TelemetryData_NodeType_NODE_TYPE_END = 2,
  TelemetryData_NodeType_NODE_TYPE_SLEEPY_END = 3,
  TelemetryData_NodeType_NODE_TYPE_MINIMAL_END = 4,
  TelemetryData_NodeType_NODE_TYPE_OFFLINE = 5,
  TelemetryData_NodeType_NODE_TYPE_DISABLED = 6,
  TelemetryData_NodeType_NODE_TYPE_DETACHED = 7,
  TelemetryData_NodeType_NODE_TYPE_NL_LURKER = 16,
  TelemetryData_NodeType_NODE_TYPE_COMMISSIONER = 32,
  TelemetryData_NodeType_NODE_TYPE_LEADER = 64
};
bool TelemetryData_NodeType_IsValid(int value);
constexpr TelemetryData_NodeType TelemetryData_NodeType_NodeType_MIN = TelemetryData_NodeType_NODE_TYPE_UNSPECIFIED;
constexpr TelemetryData_NodeType TelemetryData_NodeType_NodeType_MAX = TelemetryData_NodeType_NODE_TYPE_LEADER;
constexpr int TelemetryData_NodeType_NodeType_ARRAYSIZE = TelemetryData_NodeType_NodeType_MAX + 1;

const std::string& TelemetryData_NodeType_Name(TelemetryData_NodeType value);
template<typename T>
inline const std::string& TelemetryData_NodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_NodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_NodeType_Name.");
  return TelemetryData_NodeType_Name(static_cast<TelemetryData_NodeType>(enum_t_value));
}
bool TelemetryData_NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_NodeType* value);
enum TelemetryData_Dhcp6PdState : int {
  TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_UNSPECIFIED = 0,
  TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_DISABLED = 1,
  TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_STOPPED = 2,
  TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_RUNNING = 3
};
bool TelemetryData_Dhcp6PdState_IsValid(int value);
constexpr TelemetryData_Dhcp6PdState TelemetryData_Dhcp6PdState_Dhcp6PdState_MIN = TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_UNSPECIFIED;
constexpr TelemetryData_Dhcp6PdState TelemetryData_Dhcp6PdState_Dhcp6PdState_MAX = TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_RUNNING;
constexpr int TelemetryData_Dhcp6PdState_Dhcp6PdState_ARRAYSIZE = TelemetryData_Dhcp6PdState_Dhcp6PdState_MAX + 1;

const std::string& TelemetryData_Dhcp6PdState_Name(TelemetryData_Dhcp6PdState value);
template<typename T>
inline const std::string& TelemetryData_Dhcp6PdState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_Dhcp6PdState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_Dhcp6PdState_Name.");
  return TelemetryData_Dhcp6PdState_Name(static_cast<TelemetryData_Dhcp6PdState>(enum_t_value));
}
bool TelemetryData_Dhcp6PdState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_Dhcp6PdState* value);
enum TelemetryData_SrpServerState : int {
  TelemetryData_SrpServerState_SRP_SERVER_STATE_UNSPECIFIED = 0,
  TelemetryData_SrpServerState_SRP_SERVER_STATE_DISABLED = 1,
  TelemetryData_SrpServerState_SRP_SERVER_STATE_RUNNING = 2,
  TelemetryData_SrpServerState_SRP_SERVER_STATE_STOPPED = 3
};
bool TelemetryData_SrpServerState_IsValid(int value);
constexpr TelemetryData_SrpServerState TelemetryData_SrpServerState_SrpServerState_MIN = TelemetryData_SrpServerState_SRP_SERVER_STATE_UNSPECIFIED;
constexpr TelemetryData_SrpServerState TelemetryData_SrpServerState_SrpServerState_MAX = TelemetryData_SrpServerState_SRP_SERVER_STATE_STOPPED;
constexpr int TelemetryData_SrpServerState_SrpServerState_ARRAYSIZE = TelemetryData_SrpServerState_SrpServerState_MAX + 1;

const std::string& TelemetryData_SrpServerState_Name(TelemetryData_SrpServerState value);
template<typename T>
inline const std::string& TelemetryData_SrpServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_SrpServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_SrpServerState_Name.");
  return TelemetryData_SrpServerState_Name(static_cast<TelemetryData_SrpServerState>(enum_t_value));
}
bool TelemetryData_SrpServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_SrpServerState* value);
enum TelemetryData_SrpServerAddressMode : int {
  TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_UNSPECIFIED = 0,
  TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_UNICAST = 1,
  TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST = 2
};
bool TelemetryData_SrpServerAddressMode_IsValid(int value);
constexpr TelemetryData_SrpServerAddressMode TelemetryData_SrpServerAddressMode_SrpServerAddressMode_MIN = TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_UNSPECIFIED;
constexpr TelemetryData_SrpServerAddressMode TelemetryData_SrpServerAddressMode_SrpServerAddressMode_MAX = TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST;
constexpr int TelemetryData_SrpServerAddressMode_SrpServerAddressMode_ARRAYSIZE = TelemetryData_SrpServerAddressMode_SrpServerAddressMode_MAX + 1;

const std::string& TelemetryData_SrpServerAddressMode_Name(TelemetryData_SrpServerAddressMode value);
template<typename T>
inline const std::string& TelemetryData_SrpServerAddressMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_SrpServerAddressMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_SrpServerAddressMode_Name.");
  return TelemetryData_SrpServerAddressMode_Name(static_cast<TelemetryData_SrpServerAddressMode>(enum_t_value));
}
bool TelemetryData_SrpServerAddressMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_SrpServerAddressMode* value);
enum TelemetryData_UpstreamDnsQueryState : int {
  TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_UNSPECIFIED = 0,
  TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_ENABLED = 1,
  TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_DISABLED = 2
};
bool TelemetryData_UpstreamDnsQueryState_IsValid(int value);
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_MIN = TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_UNSPECIFIED;
constexpr TelemetryData_UpstreamDnsQueryState TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_MAX = TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_DISABLED;
constexpr int TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_ARRAYSIZE = TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_MAX + 1;

const std::string& TelemetryData_UpstreamDnsQueryState_Name(TelemetryData_UpstreamDnsQueryState value);
template<typename T>
inline const std::string& TelemetryData_UpstreamDnsQueryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_UpstreamDnsQueryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_UpstreamDnsQueryState_Name.");
  return TelemetryData_UpstreamDnsQueryState_Name(static_cast<TelemetryData_UpstreamDnsQueryState>(enum_t_value));
}
bool TelemetryData_UpstreamDnsQueryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_UpstreamDnsQueryState* value);
enum TelemetryData_Nat64State : int {
  TelemetryData_Nat64State_NAT64_STATE_UNSPECIFIED = 0,
  TelemetryData_Nat64State_NAT64_STATE_DISABLED = 1,
  TelemetryData_Nat64State_NAT64_STATE_NOT_RUNNING = 2,
  TelemetryData_Nat64State_NAT64_STATE_IDLE = 3,
  TelemetryData_Nat64State_NAT64_STATE_ACTIVE = 4
};
bool TelemetryData_Nat64State_IsValid(int value);
constexpr TelemetryData_Nat64State TelemetryData_Nat64State_Nat64State_MIN = TelemetryData_Nat64State_NAT64_STATE_UNSPECIFIED;
constexpr TelemetryData_Nat64State TelemetryData_Nat64State_Nat64State_MAX = TelemetryData_Nat64State_NAT64_STATE_ACTIVE;
constexpr int TelemetryData_Nat64State_Nat64State_ARRAYSIZE = TelemetryData_Nat64State_Nat64State_MAX + 1;

const std::string& TelemetryData_Nat64State_Name(TelemetryData_Nat64State value);
template<typename T>
inline const std::string& TelemetryData_Nat64State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryData_Nat64State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryData_Nat64State_Name.");
  return TelemetryData_Nat64State_Name(static_cast<TelemetryData_Nat64State>(enum_t_value));
}
bool TelemetryData_Nat64State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TelemetryData_Nat64State* value);
// ===================================================================

class TelemetryData_Duration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Duration) */ {
 public:
  inline TelemetryData_Duration() : TelemetryData_Duration(nullptr) {}
  ~TelemetryData_Duration() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Duration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Duration(const TelemetryData_Duration& from);
  TelemetryData_Duration(TelemetryData_Duration&& from) noexcept
    : TelemetryData_Duration() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Duration& operator=(const TelemetryData_Duration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Duration& operator=(TelemetryData_Duration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Duration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Duration* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Duration*>(
               &_TelemetryData_Duration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TelemetryData_Duration& a, TelemetryData_Duration& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Duration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Duration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Duration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Duration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Duration& from);
  void MergeFrom(const TelemetryData_Duration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Duration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Duration";
  }
  protected:
  explicit TelemetryData_Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Duration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seconds_;
    int32_t nanos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_WpanStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.WpanStats) */ {
 public:
  inline TelemetryData_WpanStats() : TelemetryData_WpanStats(nullptr) {}
  ~TelemetryData_WpanStats() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_WpanStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_WpanStats(const TelemetryData_WpanStats& from);
  TelemetryData_WpanStats(TelemetryData_WpanStats&& from) noexcept
    : TelemetryData_WpanStats() {
    *this = ::std::move(from);
  }

  inline TelemetryData_WpanStats& operator=(const TelemetryData_WpanStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_WpanStats& operator=(TelemetryData_WpanStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_WpanStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_WpanStats* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_WpanStats*>(
               &_TelemetryData_WpanStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TelemetryData_WpanStats& a, TelemetryData_WpanStats& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_WpanStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_WpanStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_WpanStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_WpanStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_WpanStats& from);
  void MergeFrom(const TelemetryData_WpanStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_WpanStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.WpanStats";
  }
  protected:
  explicit TelemetryData_WpanStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhyRxFieldNumber = 1,
    kPhyTxFieldNumber = 2,
    kMacUnicastRxFieldNumber = 3,
    kMacUnicastTxFieldNumber = 4,
    kMacBroadcastRxFieldNumber = 5,
    kMacBroadcastTxFieldNumber = 6,
    kMacTxAckReqFieldNumber = 7,
    kMacTxNoAckReqFieldNumber = 8,
    kMacTxAckedFieldNumber = 9,
    kMacTxDataFieldNumber = 10,
    kMacTxDataPollFieldNumber = 11,
    kMacTxBeaconFieldNumber = 12,
    kMacTxBeaconReqFieldNumber = 13,
    kMacTxOtherPktFieldNumber = 14,
    kMacTxRetryFieldNumber = 15,
    kMacRxDataFieldNumber = 16,
    kMacRxDataPollFieldNumber = 17,
    kMacRxBeaconFieldNumber = 18,
    kMacRxBeaconReqFieldNumber = 19,
    kMacRxOtherPktFieldNumber = 20,
    kMacRxFilterWhitelistFieldNumber = 21,
    kMacRxFilterDestAddrFieldNumber = 22,
    kMacTxFailCcaFieldNumber = 23,
    kMacRxFailDecryptFieldNumber = 24,
    kMacRxFailNoFrameFieldNumber = 25,
    kMacRxFailUnknownNeighborFieldNumber = 26,
    kMacRxFailInvalidSrcAddrFieldNumber = 27,
    kMacRxFailFcsFieldNumber = 28,
    kMacRxFailOtherFieldNumber = 29,
    kIpTxSuccessFieldNumber = 30,
    kIpRxSuccessFieldNumber = 31,
    kIpTxFailureFieldNumber = 32,
    kIpRxFailureFieldNumber = 33,
    kNodeTypeFieldNumber = 34,
    kChannelFieldNumber = 35,
    kRadioTxPowerFieldNumber = 36,
    kMacCcaFailRateFieldNumber = 37,
  };
  // optional int32 phy_rx = 1;
  bool has_phy_rx() const;
  private:
  bool _internal_has_phy_rx() const;
  public:
  void clear_phy_rx();
  int32_t phy_rx() const;
  void set_phy_rx(int32_t value);
  private:
  int32_t _internal_phy_rx() const;
  void _internal_set_phy_rx(int32_t value);
  public:

  // optional int32 phy_tx = 2;
  bool has_phy_tx() const;
  private:
  bool _internal_has_phy_tx() const;
  public:
  void clear_phy_tx();
  int32_t phy_tx() const;
  void set_phy_tx(int32_t value);
  private:
  int32_t _internal_phy_tx() const;
  void _internal_set_phy_tx(int32_t value);
  public:

  // optional int32 mac_unicast_rx = 3;
  bool has_mac_unicast_rx() const;
  private:
  bool _internal_has_mac_unicast_rx() const;
  public:
  void clear_mac_unicast_rx();
  int32_t mac_unicast_rx() const;
  void set_mac_unicast_rx(int32_t value);
  private:
  int32_t _internal_mac_unicast_rx() const;
  void _internal_set_mac_unicast_rx(int32_t value);
  public:

  // optional int32 mac_unicast_tx = 4;
  bool has_mac_unicast_tx() const;
  private:
  bool _internal_has_mac_unicast_tx() const;
  public:
  void clear_mac_unicast_tx();
  int32_t mac_unicast_tx() const;
  void set_mac_unicast_tx(int32_t value);
  private:
  int32_t _internal_mac_unicast_tx() const;
  void _internal_set_mac_unicast_tx(int32_t value);
  public:

  // optional int32 mac_broadcast_rx = 5;
  bool has_mac_broadcast_rx() const;
  private:
  bool _internal_has_mac_broadcast_rx() const;
  public:
  void clear_mac_broadcast_rx();
  int32_t mac_broadcast_rx() const;
  void set_mac_broadcast_rx(int32_t value);
  private:
  int32_t _internal_mac_broadcast_rx() const;
  void _internal_set_mac_broadcast_rx(int32_t value);
  public:

  // optional int32 mac_broadcast_tx = 6;
  bool has_mac_broadcast_tx() const;
  private:
  bool _internal_has_mac_broadcast_tx() const;
  public:
  void clear_mac_broadcast_tx();
  int32_t mac_broadcast_tx() const;
  void set_mac_broadcast_tx(int32_t value);
  private:
  int32_t _internal_mac_broadcast_tx() const;
  void _internal_set_mac_broadcast_tx(int32_t value);
  public:

  // optional int32 mac_tx_ack_req = 7;
  bool has_mac_tx_ack_req() const;
  private:
  bool _internal_has_mac_tx_ack_req() const;
  public:
  void clear_mac_tx_ack_req();
  int32_t mac_tx_ack_req() const;
  void set_mac_tx_ack_req(int32_t value);
  private:
  int32_t _internal_mac_tx_ack_req() const;
  void _internal_set_mac_tx_ack_req(int32_t value);
  public:

  // optional int32 mac_tx_no_ack_req = 8;
  bool has_mac_tx_no_ack_req() const;
  private:
  bool _internal_has_mac_tx_no_ack_req() const;
  public:
  void clear_mac_tx_no_ack_req();
  int32_t mac_tx_no_ack_req() const;
  void set_mac_tx_no_ack_req(int32_t value);
  private:
  int32_t _internal_mac_tx_no_ack_req() const;
  void _internal_set_mac_tx_no_ack_req(int32_t value);
  public:

  // optional int32 mac_tx_acked = 9;
  bool has_mac_tx_acked() const;
  private:
  bool _internal_has_mac_tx_acked() const;
  public:
  void clear_mac_tx_acked();
  int32_t mac_tx_acked() const;
  void set_mac_tx_acked(int32_t value);
  private:
  int32_t _internal_mac_tx_acked() const;
  void _internal_set_mac_tx_acked(int32_t value);
  public:

  // optional int32 mac_tx_data = 10;
  bool has_mac_tx_data() const;
  private:
  bool _internal_has_mac_tx_data() const;
  public:
  void clear_mac_tx_data();
  int32_t mac_tx_data() const;
  void set_mac_tx_data(int32_t value);
  private:
  int32_t _internal_mac_tx_data() const;
  void _internal_set_mac_tx_data(int32_t value);
  public:

  // optional int32 mac_tx_data_poll = 11;
  bool has_mac_tx_data_poll() const;
  private:
  bool _internal_has_mac_tx_data_poll() const;
  public:
  void clear_mac_tx_data_poll();
  int32_t mac_tx_data_poll() const;
  void set_mac_tx_data_poll(int32_t value);
  private:
  int32_t _internal_mac_tx_data_poll() const;
  void _internal_set_mac_tx_data_poll(int32_t value);
  public:

  // optional int32 mac_tx_beacon = 12;
  bool has_mac_tx_beacon() const;
  private:
  bool _internal_has_mac_tx_beacon() const;
  public:
  void clear_mac_tx_beacon();
  int32_t mac_tx_beacon() const;
  void set_mac_tx_beacon(int32_t value);
  private:
  int32_t _internal_mac_tx_beacon() const;
  void _internal_set_mac_tx_beacon(int32_t value);
  public:

  // optional int32 mac_tx_beacon_req = 13;
  bool has_mac_tx_beacon_req() const;
  private:
  bool _internal_has_mac_tx_beacon_req() const;
  public:
  void clear_mac_tx_beacon_req();
  int32_t mac_tx_beacon_req() const;
  void set_mac_tx_beacon_req(int32_t value);
  private:
  int32_t _internal_mac_tx_beacon_req() const;
  void _internal_set_mac_tx_beacon_req(int32_t value);
  public:

  // optional int32 mac_tx_other_pkt = 14;
  bool has_mac_tx_other_pkt() const;
  private:
  bool _internal_has_mac_tx_other_pkt() const;
  public:
  void clear_mac_tx_other_pkt();
  int32_t mac_tx_other_pkt() const;
  void set_mac_tx_other_pkt(int32_t value);
  private:
  int32_t _internal_mac_tx_other_pkt() const;
  void _internal_set_mac_tx_other_pkt(int32_t value);
  public:

  // optional int32 mac_tx_retry = 15;
  bool has_mac_tx_retry() const;
  private:
  bool _internal_has_mac_tx_retry() const;
  public:
  void clear_mac_tx_retry();
  int32_t mac_tx_retry() const;
  void set_mac_tx_retry(int32_t value);
  private:
  int32_t _internal_mac_tx_retry() const;
  void _internal_set_mac_tx_retry(int32_t value);
  public:

  // optional int32 mac_rx_data = 16;
  bool has_mac_rx_data() const;
  private:
  bool _internal_has_mac_rx_data() const;
  public:
  void clear_mac_rx_data();
  int32_t mac_rx_data() const;
  void set_mac_rx_data(int32_t value);
  private:
  int32_t _internal_mac_rx_data() const;
  void _internal_set_mac_rx_data(int32_t value);
  public:

  // optional int32 mac_rx_data_poll = 17;
  bool has_mac_rx_data_poll() const;
  private:
  bool _internal_has_mac_rx_data_poll() const;
  public:
  void clear_mac_rx_data_poll();
  int32_t mac_rx_data_poll() const;
  void set_mac_rx_data_poll(int32_t value);
  private:
  int32_t _internal_mac_rx_data_poll() const;
  void _internal_set_mac_rx_data_poll(int32_t value);
  public:

  // optional int32 mac_rx_beacon = 18;
  bool has_mac_rx_beacon() const;
  private:
  bool _internal_has_mac_rx_beacon() const;
  public:
  void clear_mac_rx_beacon();
  int32_t mac_rx_beacon() const;
  void set_mac_rx_beacon(int32_t value);
  private:
  int32_t _internal_mac_rx_beacon() const;
  void _internal_set_mac_rx_beacon(int32_t value);
  public:

  // optional int32 mac_rx_beacon_req = 19;
  bool has_mac_rx_beacon_req() const;
  private:
  bool _internal_has_mac_rx_beacon_req() const;
  public:
  void clear_mac_rx_beacon_req();
  int32_t mac_rx_beacon_req() const;
  void set_mac_rx_beacon_req(int32_t value);
  private:
  int32_t _internal_mac_rx_beacon_req() const;
  void _internal_set_mac_rx_beacon_req(int32_t value);
  public:

  // optional int32 mac_rx_other_pkt = 20;
  bool has_mac_rx_other_pkt() const;
  private:
  bool _internal_has_mac_rx_other_pkt() const;
  public:
  void clear_mac_rx_other_pkt();
  int32_t mac_rx_other_pkt() const;
  void set_mac_rx_other_pkt(int32_t value);
  private:
  int32_t _internal_mac_rx_other_pkt() const;
  void _internal_set_mac_rx_other_pkt(int32_t value);
  public:

  // optional int32 mac_rx_filter_whitelist = 21;
  bool has_mac_rx_filter_whitelist() const;
  private:
  bool _internal_has_mac_rx_filter_whitelist() const;
  public:
  void clear_mac_rx_filter_whitelist();
  int32_t mac_rx_filter_whitelist() const;
  void set_mac_rx_filter_whitelist(int32_t value);
  private:
  int32_t _internal_mac_rx_filter_whitelist() const;
  void _internal_set_mac_rx_filter_whitelist(int32_t value);
  public:

  // optional int32 mac_rx_filter_dest_addr = 22;
  bool has_mac_rx_filter_dest_addr() const;
  private:
  bool _internal_has_mac_rx_filter_dest_addr() const;
  public:
  void clear_mac_rx_filter_dest_addr();
  int32_t mac_rx_filter_dest_addr() const;
  void set_mac_rx_filter_dest_addr(int32_t value);
  private:
  int32_t _internal_mac_rx_filter_dest_addr() const;
  void _internal_set_mac_rx_filter_dest_addr(int32_t value);
  public:

  // optional int32 mac_tx_fail_cca = 23;
  bool has_mac_tx_fail_cca() const;
  private:
  bool _internal_has_mac_tx_fail_cca() const;
  public:
  void clear_mac_tx_fail_cca();
  int32_t mac_tx_fail_cca() const;
  void set_mac_tx_fail_cca(int32_t value);
  private:
  int32_t _internal_mac_tx_fail_cca() const;
  void _internal_set_mac_tx_fail_cca(int32_t value);
  public:

  // optional int32 mac_rx_fail_decrypt = 24;
  bool has_mac_rx_fail_decrypt() const;
  private:
  bool _internal_has_mac_rx_fail_decrypt() const;
  public:
  void clear_mac_rx_fail_decrypt();
  int32_t mac_rx_fail_decrypt() const;
  void set_mac_rx_fail_decrypt(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_decrypt() const;
  void _internal_set_mac_rx_fail_decrypt(int32_t value);
  public:

  // optional int32 mac_rx_fail_no_frame = 25;
  bool has_mac_rx_fail_no_frame() const;
  private:
  bool _internal_has_mac_rx_fail_no_frame() const;
  public:
  void clear_mac_rx_fail_no_frame();
  int32_t mac_rx_fail_no_frame() const;
  void set_mac_rx_fail_no_frame(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_no_frame() const;
  void _internal_set_mac_rx_fail_no_frame(int32_t value);
  public:

  // optional int32 mac_rx_fail_unknown_neighbor = 26;
  bool has_mac_rx_fail_unknown_neighbor() const;
  private:
  bool _internal_has_mac_rx_fail_unknown_neighbor() const;
  public:
  void clear_mac_rx_fail_unknown_neighbor();
  int32_t mac_rx_fail_unknown_neighbor() const;
  void set_mac_rx_fail_unknown_neighbor(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_unknown_neighbor() const;
  void _internal_set_mac_rx_fail_unknown_neighbor(int32_t value);
  public:

  // optional int32 mac_rx_fail_invalid_src_addr = 27;
  bool has_mac_rx_fail_invalid_src_addr() const;
  private:
  bool _internal_has_mac_rx_fail_invalid_src_addr() const;
  public:
  void clear_mac_rx_fail_invalid_src_addr();
  int32_t mac_rx_fail_invalid_src_addr() const;
  void set_mac_rx_fail_invalid_src_addr(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_invalid_src_addr() const;
  void _internal_set_mac_rx_fail_invalid_src_addr(int32_t value);
  public:

  // optional int32 mac_rx_fail_fcs = 28;
  bool has_mac_rx_fail_fcs() const;
  private:
  bool _internal_has_mac_rx_fail_fcs() const;
  public:
  void clear_mac_rx_fail_fcs();
  int32_t mac_rx_fail_fcs() const;
  void set_mac_rx_fail_fcs(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_fcs() const;
  void _internal_set_mac_rx_fail_fcs(int32_t value);
  public:

  // optional int32 mac_rx_fail_other = 29;
  bool has_mac_rx_fail_other() const;
  private:
  bool _internal_has_mac_rx_fail_other() const;
  public:
  void clear_mac_rx_fail_other();
  int32_t mac_rx_fail_other() const;
  void set_mac_rx_fail_other(int32_t value);
  private:
  int32_t _internal_mac_rx_fail_other() const;
  void _internal_set_mac_rx_fail_other(int32_t value);
  public:

  // optional int32 ip_tx_success = 30;
  bool has_ip_tx_success() const;
  private:
  bool _internal_has_ip_tx_success() const;
  public:
  void clear_ip_tx_success();
  int32_t ip_tx_success() const;
  void set_ip_tx_success(int32_t value);
  private:
  int32_t _internal_ip_tx_success() const;
  void _internal_set_ip_tx_success(int32_t value);
  public:

  // optional int32 ip_rx_success = 31;
  bool has_ip_rx_success() const;
  private:
  bool _internal_has_ip_rx_success() const;
  public:
  void clear_ip_rx_success();
  int32_t ip_rx_success() const;
  void set_ip_rx_success(int32_t value);
  private:
  int32_t _internal_ip_rx_success() const;
  void _internal_set_ip_rx_success(int32_t value);
  public:

  // optional int32 ip_tx_failure = 32;
  bool has_ip_tx_failure() const;
  private:
  bool _internal_has_ip_tx_failure() const;
  public:
  void clear_ip_tx_failure();
  int32_t ip_tx_failure() const;
  void set_ip_tx_failure(int32_t value);
  private:
  int32_t _internal_ip_tx_failure() const;
  void _internal_set_ip_tx_failure(int32_t value);
  public:

  // optional int32 ip_rx_failure = 33;
  bool has_ip_rx_failure() const;
  private:
  bool _internal_has_ip_rx_failure() const;
  public:
  void clear_ip_rx_failure();
  int32_t ip_rx_failure() const;
  void set_ip_rx_failure(int32_t value);
  private:
  int32_t _internal_ip_rx_failure() const;
  void _internal_set_ip_rx_failure(int32_t value);
  public:

  // optional uint32 node_type = 34;
  bool has_node_type() const;
  private:
  bool _internal_has_node_type() const;
  public:
  void clear_node_type();
  uint32_t node_type() const;
  void set_node_type(uint32_t value);
  private:
  uint32_t _internal_node_type() const;
  void _internal_set_node_type(uint32_t value);
  public:

  // optional uint32 channel = 35;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // optional int32 radio_tx_power = 36;
  bool has_radio_tx_power() const;
  private:
  bool _internal_has_radio_tx_power() const;
  public:
  void clear_radio_tx_power();
  int32_t radio_tx_power() const;
  void set_radio_tx_power(int32_t value);
  private:
  int32_t _internal_radio_tx_power() const;
  void _internal_set_radio_tx_power(int32_t value);
  public:

  // optional float mac_cca_fail_rate = 37;
  bool has_mac_cca_fail_rate() const;
  private:
  bool _internal_has_mac_cca_fail_rate() const;
  public:
  void clear_mac_cca_fail_rate();
  float mac_cca_fail_rate() const;
  void set_mac_cca_fail_rate(float value);
  private:
  float _internal_mac_cca_fail_rate() const;
  void _internal_set_mac_cca_fail_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.WpanStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t phy_rx_;
    int32_t phy_tx_;
    int32_t mac_unicast_rx_;
    int32_t mac_unicast_tx_;
    int32_t mac_broadcast_rx_;
    int32_t mac_broadcast_tx_;
    int32_t mac_tx_ack_req_;
    int32_t mac_tx_no_ack_req_;
    int32_t mac_tx_acked_;
    int32_t mac_tx_data_;
    int32_t mac_tx_data_poll_;
    int32_t mac_tx_beacon_;
    int32_t mac_tx_beacon_req_;
    int32_t mac_tx_other_pkt_;
    int32_t mac_tx_retry_;
    int32_t mac_rx_data_;
    int32_t mac_rx_data_poll_;
    int32_t mac_rx_beacon_;
    int32_t mac_rx_beacon_req_;
    int32_t mac_rx_other_pkt_;
    int32_t mac_rx_filter_whitelist_;
    int32_t mac_rx_filter_dest_addr_;
    int32_t mac_tx_fail_cca_;
    int32_t mac_rx_fail_decrypt_;
    int32_t mac_rx_fail_no_frame_;
    int32_t mac_rx_fail_unknown_neighbor_;
    int32_t mac_rx_fail_invalid_src_addr_;
    int32_t mac_rx_fail_fcs_;
    int32_t mac_rx_fail_other_;
    int32_t ip_tx_success_;
    int32_t ip_rx_success_;
    int32_t ip_tx_failure_;
    int32_t ip_rx_failure_;
    uint32_t node_type_;
    uint32_t channel_;
    int32_t radio_tx_power_;
    float mac_cca_fail_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_WpanTopoFull final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.WpanTopoFull) */ {
 public:
  inline TelemetryData_WpanTopoFull() : TelemetryData_WpanTopoFull(nullptr) {}
  ~TelemetryData_WpanTopoFull() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_WpanTopoFull(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_WpanTopoFull(const TelemetryData_WpanTopoFull& from);
  TelemetryData_WpanTopoFull(TelemetryData_WpanTopoFull&& from) noexcept
    : TelemetryData_WpanTopoFull() {
    *this = ::std::move(from);
  }

  inline TelemetryData_WpanTopoFull& operator=(const TelemetryData_WpanTopoFull& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_WpanTopoFull& operator=(TelemetryData_WpanTopoFull&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_WpanTopoFull& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_WpanTopoFull* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_WpanTopoFull*>(
               &_TelemetryData_WpanTopoFull_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TelemetryData_WpanTopoFull& a, TelemetryData_WpanTopoFull& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_WpanTopoFull* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_WpanTopoFull* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_WpanTopoFull* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_WpanTopoFull>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_WpanTopoFull& from);
  void MergeFrom(const TelemetryData_WpanTopoFull& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_WpanTopoFull* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.WpanTopoFull";
  }
  protected:
  explicit TelemetryData_WpanTopoFull(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderAddressFieldNumber = 5,
    kNetworkDataFieldNumber = 8,
    kStableNetworkDataFieldNumber = 10,
    kRloc16FieldNumber = 1,
    kRouterIdFieldNumber = 2,
    kLeaderRouterIdFieldNumber = 3,
    kLeaderWeightFieldNumber = 6,
    kLeaderLocalWeightFieldNumber = 7,
    kNetworkDataVersionFieldNumber = 9,
    kStableNetworkDataVersionFieldNumber = 11,
    kPreferredRouterIdFieldNumber = 12,
    kPartitionIdFieldNumber = 13,
    kChildTableSizeFieldNumber = 14,
    kNeighborTableSizeFieldNumber = 15,
    kInstantRssiFieldNumber = 16,
    kExtendedPanIdFieldNumber = 17,
  };
  // optional bytes leader_address = 5;
  bool has_leader_address() const;
  private:
  bool _internal_has_leader_address() const;
  public:
  void clear_leader_address();
  const std::string& leader_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader_address();
  PROTOBUF_NODISCARD std::string* release_leader_address();
  void set_allocated_leader_address(std::string* leader_address);
  private:
  const std::string& _internal_leader_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader_address(const std::string& value);
  std::string* _internal_mutable_leader_address();
  public:

  // optional bytes network_data = 8;
  bool has_network_data() const;
  private:
  bool _internal_has_network_data() const;
  public:
  void clear_network_data();
  const std::string& network_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_data();
  PROTOBUF_NODISCARD std::string* release_network_data();
  void set_allocated_network_data(std::string* network_data);
  private:
  const std::string& _internal_network_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_data(const std::string& value);
  std::string* _internal_mutable_network_data();
  public:

  // optional bytes stable_network_data = 10;
  bool has_stable_network_data() const;
  private:
  bool _internal_has_stable_network_data() const;
  public:
  void clear_stable_network_data();
  const std::string& stable_network_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stable_network_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stable_network_data();
  PROTOBUF_NODISCARD std::string* release_stable_network_data();
  void set_allocated_stable_network_data(std::string* stable_network_data);
  private:
  const std::string& _internal_stable_network_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stable_network_data(const std::string& value);
  std::string* _internal_mutable_stable_network_data();
  public:

  // optional uint32 rloc16 = 1;
  bool has_rloc16() const;
  private:
  bool _internal_has_rloc16() const;
  public:
  void clear_rloc16();
  uint32_t rloc16() const;
  void set_rloc16(uint32_t value);
  private:
  uint32_t _internal_rloc16() const;
  void _internal_set_rloc16(uint32_t value);
  public:

  // optional uint32 router_id = 2;
  bool has_router_id() const;
  private:
  bool _internal_has_router_id() const;
  public:
  void clear_router_id();
  uint32_t router_id() const;
  void set_router_id(uint32_t value);
  private:
  uint32_t _internal_router_id() const;
  void _internal_set_router_id(uint32_t value);
  public:

  // optional uint32 leader_router_id = 3;
  bool has_leader_router_id() const;
  private:
  bool _internal_has_leader_router_id() const;
  public:
  void clear_leader_router_id();
  uint32_t leader_router_id() const;
  void set_leader_router_id(uint32_t value);
  private:
  uint32_t _internal_leader_router_id() const;
  void _internal_set_leader_router_id(uint32_t value);
  public:

  // optional uint32 leader_weight = 6;
  bool has_leader_weight() const;
  private:
  bool _internal_has_leader_weight() const;
  public:
  void clear_leader_weight();
  uint32_t leader_weight() const;
  void set_leader_weight(uint32_t value);
  private:
  uint32_t _internal_leader_weight() const;
  void _internal_set_leader_weight(uint32_t value);
  public:

  // optional uint32 leader_local_weight = 7;
  bool has_leader_local_weight() const;
  private:
  bool _internal_has_leader_local_weight() const;
  public:
  void clear_leader_local_weight();
  uint32_t leader_local_weight() const;
  void set_leader_local_weight(uint32_t value);
  private:
  uint32_t _internal_leader_local_weight() const;
  void _internal_set_leader_local_weight(uint32_t value);
  public:

  // optional uint32 network_data_version = 9;
  bool has_network_data_version() const;
  private:
  bool _internal_has_network_data_version() const;
  public:
  void clear_network_data_version();
  uint32_t network_data_version() const;
  void set_network_data_version(uint32_t value);
  private:
  uint32_t _internal_network_data_version() const;
  void _internal_set_network_data_version(uint32_t value);
  public:

  // optional uint32 stable_network_data_version = 11;
  bool has_stable_network_data_version() const;
  private:
  bool _internal_has_stable_network_data_version() const;
  public:
  void clear_stable_network_data_version();
  uint32_t stable_network_data_version() const;
  void set_stable_network_data_version(uint32_t value);
  private:
  uint32_t _internal_stable_network_data_version() const;
  void _internal_set_stable_network_data_version(uint32_t value);
  public:

  // optional uint32 preferred_router_id = 12;
  bool has_preferred_router_id() const;
  private:
  bool _internal_has_preferred_router_id() const;
  public:
  void clear_preferred_router_id();
  uint32_t preferred_router_id() const;
  void set_preferred_router_id(uint32_t value);
  private:
  uint32_t _internal_preferred_router_id() const;
  void _internal_set_preferred_router_id(uint32_t value);
  public:

  // optional uint32 partition_id = 13;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  uint32_t partition_id() const;
  void set_partition_id(uint32_t value);
  private:
  uint32_t _internal_partition_id() const;
  void _internal_set_partition_id(uint32_t value);
  public:

  // optional uint32 child_table_size = 14;
  bool has_child_table_size() const;
  private:
  bool _internal_has_child_table_size() const;
  public:
  void clear_child_table_size();
  uint32_t child_table_size() const;
  void set_child_table_size(uint32_t value);
  private:
  uint32_t _internal_child_table_size() const;
  void _internal_set_child_table_size(uint32_t value);
  public:

  // optional uint32 neighbor_table_size = 15;
  bool has_neighbor_table_size() const;
  private:
  bool _internal_has_neighbor_table_size() const;
  public:
  void clear_neighbor_table_size();
  uint32_t neighbor_table_size() const;
  void set_neighbor_table_size(uint32_t value);
  private:
  uint32_t _internal_neighbor_table_size() const;
  void _internal_set_neighbor_table_size(uint32_t value);
  public:

  // optional int32 instant_rssi = 16;
  bool has_instant_rssi() const;
  private:
  bool _internal_has_instant_rssi() const;
  public:
  void clear_instant_rssi();
  int32_t instant_rssi() const;
  void set_instant_rssi(int32_t value);
  private:
  int32_t _internal_instant_rssi() const;
  void _internal_set_instant_rssi(int32_t value);
  public:

  // optional uint64 extended_pan_id = 17;
  bool has_extended_pan_id() const;
  private:
  bool _internal_has_extended_pan_id() const;
  public:
  void clear_extended_pan_id();
  uint64_t extended_pan_id() const;
  void set_extended_pan_id(uint64_t value);
  private:
  uint64_t _internal_extended_pan_id() const;
  void _internal_set_extended_pan_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.WpanTopoFull)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stable_network_data_;
    uint32_t rloc16_;
    uint32_t router_id_;
    uint32_t leader_router_id_;
    uint32_t leader_weight_;
    uint32_t leader_local_weight_;
    uint32_t network_data_version_;
    uint32_t stable_network_data_version_;
    uint32_t preferred_router_id_;
    uint32_t partition_id_;
    uint32_t child_table_size_;
    uint32_t neighbor_table_size_;
    int32_t instant_rssi_;
    uint64_t extended_pan_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_TopoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.TopoEntry) */ {
 public:
  inline TelemetryData_TopoEntry() : TelemetryData_TopoEntry(nullptr) {}
  ~TelemetryData_TopoEntry() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_TopoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_TopoEntry(const TelemetryData_TopoEntry& from);
  TelemetryData_TopoEntry(TelemetryData_TopoEntry&& from) noexcept
    : TelemetryData_TopoEntry() {
    *this = ::std::move(from);
  }

  inline TelemetryData_TopoEntry& operator=(const TelemetryData_TopoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_TopoEntry& operator=(TelemetryData_TopoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_TopoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_TopoEntry* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_TopoEntry*>(
               &_TelemetryData_TopoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TelemetryData_TopoEntry& a, TelemetryData_TopoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_TopoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_TopoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_TopoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_TopoEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_TopoEntry& from);
  void MergeFrom(const TelemetryData_TopoEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_TopoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.TopoEntry";
  }
  protected:
  explicit TelemetryData_TopoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgeFieldNumber = 5,
    kTimeoutFieldNumber = 14,
    kRloc16FieldNumber = 2,
    kLinkQualityInFieldNumber = 3,
    kAverageRssiFieldNumber = 4,
    kRxOnWhenIdleFieldNumber = 6,
    kFullFunctionFieldNumber = 7,
    kSecureDataRequestFieldNumber = 8,
    kFullNetworkDataFieldNumber = 9,
    kLastRssiFieldNumber = 10,
    kLinkFrameCounterFieldNumber = 11,
    kMleFrameCounterFieldNumber = 12,
    kIsChildFieldNumber = 13,
    kNetworkDataVersionFieldNumber = 15,
    kMacFrameErrorRateFieldNumber = 16,
    kIpMessageErrorRateFieldNumber = 17,
    kVersionFieldNumber = 18,
  };
  // optional .threadnetwork.TelemetryData.Duration age = 5;
  bool has_age() const;
  private:
  bool _internal_has_age() const;
  public:
  void clear_age();
  const ::threadnetwork::TelemetryData_Duration& age() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Duration* release_age();
  ::threadnetwork::TelemetryData_Duration* mutable_age();
  void set_allocated_age(::threadnetwork::TelemetryData_Duration* age);
  private:
  const ::threadnetwork::TelemetryData_Duration& _internal_age() const;
  ::threadnetwork::TelemetryData_Duration* _internal_mutable_age();
  public:
  void unsafe_arena_set_allocated_age(
      ::threadnetwork::TelemetryData_Duration* age);
  ::threadnetwork::TelemetryData_Duration* unsafe_arena_release_age();

  // optional .threadnetwork.TelemetryData.Duration timeout = 14;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::threadnetwork::TelemetryData_Duration& timeout() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Duration* release_timeout();
  ::threadnetwork::TelemetryData_Duration* mutable_timeout();
  void set_allocated_timeout(::threadnetwork::TelemetryData_Duration* timeout);
  private:
  const ::threadnetwork::TelemetryData_Duration& _internal_timeout() const;
  ::threadnetwork::TelemetryData_Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::threadnetwork::TelemetryData_Duration* timeout);
  ::threadnetwork::TelemetryData_Duration* unsafe_arena_release_timeout();

  // optional uint32 rloc16 = 2;
  bool has_rloc16() const;
  private:
  bool _internal_has_rloc16() const;
  public:
  void clear_rloc16();
  uint32_t rloc16() const;
  void set_rloc16(uint32_t value);
  private:
  uint32_t _internal_rloc16() const;
  void _internal_set_rloc16(uint32_t value);
  public:

  // optional uint32 link_quality_in = 3;
  bool has_link_quality_in() const;
  private:
  bool _internal_has_link_quality_in() const;
  public:
  void clear_link_quality_in();
  uint32_t link_quality_in() const;
  void set_link_quality_in(uint32_t value);
  private:
  uint32_t _internal_link_quality_in() const;
  void _internal_set_link_quality_in(uint32_t value);
  public:

  // optional int32 average_rssi = 4;
  bool has_average_rssi() const;
  private:
  bool _internal_has_average_rssi() const;
  public:
  void clear_average_rssi();
  int32_t average_rssi() const;
  void set_average_rssi(int32_t value);
  private:
  int32_t _internal_average_rssi() const;
  void _internal_set_average_rssi(int32_t value);
  public:

  // optional bool rx_on_when_idle = 6;
  bool has_rx_on_when_idle() const;
  private:
  bool _internal_has_rx_on_when_idle() const;
  public:
  void clear_rx_on_when_idle();
  bool rx_on_when_idle() const;
  void set_rx_on_when_idle(bool value);
  private:
  bool _internal_rx_on_when_idle() const;
  void _internal_set_rx_on_when_idle(bool value);
  public:

  // optional bool full_function = 7;
  bool has_full_function() const;
  private:
  bool _internal_has_full_function() const;
  public:
  void clear_full_function();
  bool full_function() const;
  void set_full_function(bool value);
  private:
  bool _internal_full_function() const;
  void _internal_set_full_function(bool value);
  public:

  // optional bool secure_data_request = 8;
  bool has_secure_data_request() const;
  private:
  bool _internal_has_secure_data_request() const;
  public:
  void clear_secure_data_request();
  bool secure_data_request() const;
  void set_secure_data_request(bool value);
  private:
  bool _internal_secure_data_request() const;
  void _internal_set_secure_data_request(bool value);
  public:

  // optional bool full_network_data = 9;
  bool has_full_network_data() const;
  private:
  bool _internal_has_full_network_data() const;
  public:
  void clear_full_network_data();
  bool full_network_data() const;
  void set_full_network_data(bool value);
  private:
  bool _internal_full_network_data() const;
  void _internal_set_full_network_data(bool value);
  public:

  // optional int32 last_rssi = 10;
  bool has_last_rssi() const;
  private:
  bool _internal_has_last_rssi() const;
  public:
  void clear_last_rssi();
  int32_t last_rssi() const;
  void set_last_rssi(int32_t value);
  private:
  int32_t _internal_last_rssi() const;
  void _internal_set_last_rssi(int32_t value);
  public:

  // optional uint32 link_frame_counter = 11;
  bool has_link_frame_counter() const;
  private:
  bool _internal_has_link_frame_counter() const;
  public:
  void clear_link_frame_counter();
  uint32_t link_frame_counter() const;
  void set_link_frame_counter(uint32_t value);
  private:
  uint32_t _internal_link_frame_counter() const;
  void _internal_set_link_frame_counter(uint32_t value);
  public:

  // optional uint32 mle_frame_counter = 12;
  bool has_mle_frame_counter() const;
  private:
  bool _internal_has_mle_frame_counter() const;
  public:
  void clear_mle_frame_counter();
  uint32_t mle_frame_counter() const;
  void set_mle_frame_counter(uint32_t value);
  private:
  uint32_t _internal_mle_frame_counter() const;
  void _internal_set_mle_frame_counter(uint32_t value);
  public:

  // optional bool is_child = 13;
  bool has_is_child() const;
  private:
  bool _internal_has_is_child() const;
  public:
  void clear_is_child();
  bool is_child() const;
  void set_is_child(bool value);
  private:
  bool _internal_is_child() const;
  void _internal_set_is_child(bool value);
  public:

  // optional uint32 network_data_version = 15;
  bool has_network_data_version() const;
  private:
  bool _internal_has_network_data_version() const;
  public:
  void clear_network_data_version();
  uint32_t network_data_version() const;
  void set_network_data_version(uint32_t value);
  private:
  uint32_t _internal_network_data_version() const;
  void _internal_set_network_data_version(uint32_t value);
  public:

  // optional float mac_frame_error_rate = 16;
  bool has_mac_frame_error_rate() const;
  private:
  bool _internal_has_mac_frame_error_rate() const;
  public:
  void clear_mac_frame_error_rate();
  float mac_frame_error_rate() const;
  void set_mac_frame_error_rate(float value);
  private:
  float _internal_mac_frame_error_rate() const;
  void _internal_set_mac_frame_error_rate(float value);
  public:

  // optional float ip_message_error_rate = 17;
  bool has_ip_message_error_rate() const;
  private:
  bool _internal_has_ip_message_error_rate() const;
  public:
  void clear_ip_message_error_rate();
  float ip_message_error_rate() const;
  void set_ip_message_error_rate(float value);
  private:
  float _internal_ip_message_error_rate() const;
  void _internal_set_ip_message_error_rate(float value);
  public:

  // optional int32 version = 18;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.TopoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_Duration* age_;
    ::threadnetwork::TelemetryData_Duration* timeout_;
    uint32_t rloc16_;
    uint32_t link_quality_in_;
    int32_t average_rssi_;
    bool rx_on_when_idle_;
    bool full_function_;
    bool secure_data_request_;
    bool full_network_data_;
    int32_t last_rssi_;
    uint32_t link_frame_counter_;
    uint32_t mle_frame_counter_;
    bool is_child_;
    uint32_t network_data_version_;
    float mac_frame_error_rate_;
    float ip_message_error_rate_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_PacketsAndBytes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.PacketsAndBytes) */ {
 public:
  inline TelemetryData_PacketsAndBytes() : TelemetryData_PacketsAndBytes(nullptr) {}
  ~TelemetryData_PacketsAndBytes() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_PacketsAndBytes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_PacketsAndBytes(const TelemetryData_PacketsAndBytes& from);
  TelemetryData_PacketsAndBytes(TelemetryData_PacketsAndBytes&& from) noexcept
    : TelemetryData_PacketsAndBytes() {
    *this = ::std::move(from);
  }

  inline TelemetryData_PacketsAndBytes& operator=(const TelemetryData_PacketsAndBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_PacketsAndBytes& operator=(TelemetryData_PacketsAndBytes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_PacketsAndBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_PacketsAndBytes* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_PacketsAndBytes*>(
               &_TelemetryData_PacketsAndBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TelemetryData_PacketsAndBytes& a, TelemetryData_PacketsAndBytes& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_PacketsAndBytes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_PacketsAndBytes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_PacketsAndBytes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_PacketsAndBytes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_PacketsAndBytes& from);
  void MergeFrom(const TelemetryData_PacketsAndBytes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_PacketsAndBytes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.PacketsAndBytes";
  }
  protected:
  explicit TelemetryData_PacketsAndBytes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketCountFieldNumber = 1,
    kByteCountFieldNumber = 2,
  };
  // optional int64 packet_count = 1;
  bool has_packet_count() const;
  private:
  bool _internal_has_packet_count() const;
  public:
  void clear_packet_count();
  int64_t packet_count() const;
  void set_packet_count(int64_t value);
  private:
  int64_t _internal_packet_count() const;
  void _internal_set_packet_count(int64_t value);
  public:

  // optional int64 byte_count = 2;
  bool has_byte_count() const;
  private:
  bool _internal_has_byte_count() const;
  public:
  void clear_byte_count();
  int64_t byte_count() const;
  void set_byte_count(int64_t value);
  private:
  int64_t _internal_byte_count() const;
  void _internal_set_byte_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.PacketsAndBytes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t packet_count_;
    int64_t byte_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_Nat64TrafficCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Nat64TrafficCounters) */ {
 public:
  inline TelemetryData_Nat64TrafficCounters() : TelemetryData_Nat64TrafficCounters(nullptr) {}
  ~TelemetryData_Nat64TrafficCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Nat64TrafficCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Nat64TrafficCounters(const TelemetryData_Nat64TrafficCounters& from);
  TelemetryData_Nat64TrafficCounters(TelemetryData_Nat64TrafficCounters&& from) noexcept
    : TelemetryData_Nat64TrafficCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Nat64TrafficCounters& operator=(const TelemetryData_Nat64TrafficCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Nat64TrafficCounters& operator=(TelemetryData_Nat64TrafficCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Nat64TrafficCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Nat64TrafficCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Nat64TrafficCounters*>(
               &_TelemetryData_Nat64TrafficCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TelemetryData_Nat64TrafficCounters& a, TelemetryData_Nat64TrafficCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Nat64TrafficCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Nat64TrafficCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Nat64TrafficCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Nat64TrafficCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Nat64TrafficCounters& from);
  void MergeFrom(const TelemetryData_Nat64TrafficCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Nat64TrafficCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Nat64TrafficCounters";
  }
  protected:
  explicit TelemetryData_Nat64TrafficCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpv4ToIpv6PacketsFieldNumber = 1,
    kIpv4ToIpv6BytesFieldNumber = 2,
    kIpv6ToIpv4PacketsFieldNumber = 3,
    kIpv6ToIpv4BytesFieldNumber = 4,
  };
  // optional int64 ipv4_to_ipv6_packets = 1;
  bool has_ipv4_to_ipv6_packets() const;
  private:
  bool _internal_has_ipv4_to_ipv6_packets() const;
  public:
  void clear_ipv4_to_ipv6_packets();
  int64_t ipv4_to_ipv6_packets() const;
  void set_ipv4_to_ipv6_packets(int64_t value);
  private:
  int64_t _internal_ipv4_to_ipv6_packets() const;
  void _internal_set_ipv4_to_ipv6_packets(int64_t value);
  public:

  // optional int64 ipv4_to_ipv6_bytes = 2;
  bool has_ipv4_to_ipv6_bytes() const;
  private:
  bool _internal_has_ipv4_to_ipv6_bytes() const;
  public:
  void clear_ipv4_to_ipv6_bytes();
  int64_t ipv4_to_ipv6_bytes() const;
  void set_ipv4_to_ipv6_bytes(int64_t value);
  private:
  int64_t _internal_ipv4_to_ipv6_bytes() const;
  void _internal_set_ipv4_to_ipv6_bytes(int64_t value);
  public:

  // optional int64 ipv6_to_ipv4_packets = 3;
  bool has_ipv6_to_ipv4_packets() const;
  private:
  bool _internal_has_ipv6_to_ipv4_packets() const;
  public:
  void clear_ipv6_to_ipv4_packets();
  int64_t ipv6_to_ipv4_packets() const;
  void set_ipv6_to_ipv4_packets(int64_t value);
  private:
  int64_t _internal_ipv6_to_ipv4_packets() const;
  void _internal_set_ipv6_to_ipv4_packets(int64_t value);
  public:

  // optional int64 ipv6_to_ipv4_bytes = 4;
  bool has_ipv6_to_ipv4_bytes() const;
  private:
  bool _internal_has_ipv6_to_ipv4_bytes() const;
  public:
  void clear_ipv6_to_ipv4_bytes();
  int64_t ipv6_to_ipv4_bytes() const;
  void set_ipv6_to_ipv4_bytes(int64_t value);
  private:
  int64_t _internal_ipv6_to_ipv4_bytes() const;
  void _internal_set_ipv6_to_ipv4_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Nat64TrafficCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t ipv4_to_ipv6_packets_;
    int64_t ipv4_to_ipv6_bytes_;
    int64_t ipv6_to_ipv4_packets_;
    int64_t ipv6_to_ipv4_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_Nat64ProtocolCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Nat64ProtocolCounters) */ {
 public:
  inline TelemetryData_Nat64ProtocolCounters() : TelemetryData_Nat64ProtocolCounters(nullptr) {}
  ~TelemetryData_Nat64ProtocolCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Nat64ProtocolCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Nat64ProtocolCounters(const TelemetryData_Nat64ProtocolCounters& from);
  TelemetryData_Nat64ProtocolCounters(TelemetryData_Nat64ProtocolCounters&& from) noexcept
    : TelemetryData_Nat64ProtocolCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Nat64ProtocolCounters& operator=(const TelemetryData_Nat64ProtocolCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Nat64ProtocolCounters& operator=(TelemetryData_Nat64ProtocolCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Nat64ProtocolCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Nat64ProtocolCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Nat64ProtocolCounters*>(
               &_TelemetryData_Nat64ProtocolCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TelemetryData_Nat64ProtocolCounters& a, TelemetryData_Nat64ProtocolCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Nat64ProtocolCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Nat64ProtocolCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Nat64ProtocolCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Nat64ProtocolCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Nat64ProtocolCounters& from);
  void MergeFrom(const TelemetryData_Nat64ProtocolCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Nat64ProtocolCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Nat64ProtocolCounters";
  }
  protected:
  explicit TelemetryData_Nat64ProtocolCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTcpFieldNumber = 1,
    kUdpFieldNumber = 2,
    kIcmpFieldNumber = 3,
  };
  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters tcp = 1;
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& tcp() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64TrafficCounters* release_tcp();
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* mutable_tcp();
  void set_allocated_tcp(::threadnetwork::TelemetryData_Nat64TrafficCounters* tcp);
  private:
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& _internal_tcp() const;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::threadnetwork::TelemetryData_Nat64TrafficCounters* tcp);
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* unsafe_arena_release_tcp();

  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters udp = 2;
  bool has_udp() const;
  private:
  bool _internal_has_udp() const;
  public:
  void clear_udp();
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& udp() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64TrafficCounters* release_udp();
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* mutable_udp();
  void set_allocated_udp(::threadnetwork::TelemetryData_Nat64TrafficCounters* udp);
  private:
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& _internal_udp() const;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _internal_mutable_udp();
  public:
  void unsafe_arena_set_allocated_udp(
      ::threadnetwork::TelemetryData_Nat64TrafficCounters* udp);
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* unsafe_arena_release_udp();

  // optional .threadnetwork.TelemetryData.Nat64TrafficCounters icmp = 3;
  bool has_icmp() const;
  private:
  bool _internal_has_icmp() const;
  public:
  void clear_icmp();
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& icmp() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64TrafficCounters* release_icmp();
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* mutable_icmp();
  void set_allocated_icmp(::threadnetwork::TelemetryData_Nat64TrafficCounters* icmp);
  private:
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters& _internal_icmp() const;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _internal_mutable_icmp();
  public:
  void unsafe_arena_set_allocated_icmp(
      ::threadnetwork::TelemetryData_Nat64TrafficCounters* icmp);
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* unsafe_arena_release_icmp();

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Nat64ProtocolCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* tcp_;
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* udp_;
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* icmp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_Nat64PacketCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Nat64PacketCounters) */ {
 public:
  inline TelemetryData_Nat64PacketCounters() : TelemetryData_Nat64PacketCounters(nullptr) {}
  ~TelemetryData_Nat64PacketCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Nat64PacketCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Nat64PacketCounters(const TelemetryData_Nat64PacketCounters& from);
  TelemetryData_Nat64PacketCounters(TelemetryData_Nat64PacketCounters&& from) noexcept
    : TelemetryData_Nat64PacketCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Nat64PacketCounters& operator=(const TelemetryData_Nat64PacketCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Nat64PacketCounters& operator=(TelemetryData_Nat64PacketCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Nat64PacketCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Nat64PacketCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Nat64PacketCounters*>(
               &_TelemetryData_Nat64PacketCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TelemetryData_Nat64PacketCounters& a, TelemetryData_Nat64PacketCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Nat64PacketCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Nat64PacketCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Nat64PacketCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Nat64PacketCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Nat64PacketCounters& from);
  void MergeFrom(const TelemetryData_Nat64PacketCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Nat64PacketCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Nat64PacketCounters";
  }
  protected:
  explicit TelemetryData_Nat64PacketCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpv4ToIpv6PacketsFieldNumber = 1,
    kIpv6ToIpv4PacketsFieldNumber = 2,
  };
  // optional int64 ipv4_to_ipv6_packets = 1;
  bool has_ipv4_to_ipv6_packets() const;
  private:
  bool _internal_has_ipv4_to_ipv6_packets() const;
  public:
  void clear_ipv4_to_ipv6_packets();
  int64_t ipv4_to_ipv6_packets() const;
  void set_ipv4_to_ipv6_packets(int64_t value);
  private:
  int64_t _internal_ipv4_to_ipv6_packets() const;
  void _internal_set_ipv4_to_ipv6_packets(int64_t value);
  public:

  // optional int64 ipv6_to_ipv4_packets = 2;
  bool has_ipv6_to_ipv4_packets() const;
  private:
  bool _internal_has_ipv6_to_ipv4_packets() const;
  public:
  void clear_ipv6_to_ipv4_packets();
  int64_t ipv6_to_ipv4_packets() const;
  void set_ipv6_to_ipv4_packets(int64_t value);
  private:
  int64_t _internal_ipv6_to_ipv4_packets() const;
  void _internal_set_ipv6_to_ipv4_packets(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Nat64PacketCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t ipv4_to_ipv6_packets_;
    int64_t ipv6_to_ipv4_packets_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_Nat64ErrorCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Nat64ErrorCounters) */ {
 public:
  inline TelemetryData_Nat64ErrorCounters() : TelemetryData_Nat64ErrorCounters(nullptr) {}
  ~TelemetryData_Nat64ErrorCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Nat64ErrorCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Nat64ErrorCounters(const TelemetryData_Nat64ErrorCounters& from);
  TelemetryData_Nat64ErrorCounters(TelemetryData_Nat64ErrorCounters&& from) noexcept
    : TelemetryData_Nat64ErrorCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Nat64ErrorCounters& operator=(const TelemetryData_Nat64ErrorCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Nat64ErrorCounters& operator=(TelemetryData_Nat64ErrorCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Nat64ErrorCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Nat64ErrorCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Nat64ErrorCounters*>(
               &_TelemetryData_Nat64ErrorCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TelemetryData_Nat64ErrorCounters& a, TelemetryData_Nat64ErrorCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Nat64ErrorCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Nat64ErrorCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Nat64ErrorCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Nat64ErrorCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Nat64ErrorCounters& from);
  void MergeFrom(const TelemetryData_Nat64ErrorCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Nat64ErrorCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Nat64ErrorCounters";
  }
  protected:
  explicit TelemetryData_Nat64ErrorCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnknownFieldNumber = 1,
    kIllegalPacketFieldNumber = 2,
    kUnsupportedProtocolFieldNumber = 3,
    kNoMappingFieldNumber = 4,
  };
  // optional .threadnetwork.TelemetryData.Nat64PacketCounters unknown = 1;
  bool has_unknown() const;
  private:
  bool _internal_has_unknown() const;
  public:
  void clear_unknown();
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& unknown() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64PacketCounters* release_unknown();
  ::threadnetwork::TelemetryData_Nat64PacketCounters* mutable_unknown();
  void set_allocated_unknown(::threadnetwork::TelemetryData_Nat64PacketCounters* unknown);
  private:
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& _internal_unknown() const;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _internal_mutable_unknown();
  public:
  void unsafe_arena_set_allocated_unknown(
      ::threadnetwork::TelemetryData_Nat64PacketCounters* unknown);
  ::threadnetwork::TelemetryData_Nat64PacketCounters* unsafe_arena_release_unknown();

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters illegal_packet = 2;
  bool has_illegal_packet() const;
  private:
  bool _internal_has_illegal_packet() const;
  public:
  void clear_illegal_packet();
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& illegal_packet() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64PacketCounters* release_illegal_packet();
  ::threadnetwork::TelemetryData_Nat64PacketCounters* mutable_illegal_packet();
  void set_allocated_illegal_packet(::threadnetwork::TelemetryData_Nat64PacketCounters* illegal_packet);
  private:
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& _internal_illegal_packet() const;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _internal_mutable_illegal_packet();
  public:
  void unsafe_arena_set_allocated_illegal_packet(
      ::threadnetwork::TelemetryData_Nat64PacketCounters* illegal_packet);
  ::threadnetwork::TelemetryData_Nat64PacketCounters* unsafe_arena_release_illegal_packet();

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters unsupported_protocol = 3;
  bool has_unsupported_protocol() const;
  private:
  bool _internal_has_unsupported_protocol() const;
  public:
  void clear_unsupported_protocol();
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& unsupported_protocol() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64PacketCounters* release_unsupported_protocol();
  ::threadnetwork::TelemetryData_Nat64PacketCounters* mutable_unsupported_protocol();
  void set_allocated_unsupported_protocol(::threadnetwork::TelemetryData_Nat64PacketCounters* unsupported_protocol);
  private:
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& _internal_unsupported_protocol() const;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _internal_mutable_unsupported_protocol();
  public:
  void unsafe_arena_set_allocated_unsupported_protocol(
      ::threadnetwork::TelemetryData_Nat64PacketCounters* unsupported_protocol);
  ::threadnetwork::TelemetryData_Nat64PacketCounters* unsafe_arena_release_unsupported_protocol();

  // optional .threadnetwork.TelemetryData.Nat64PacketCounters no_mapping = 4;
  bool has_no_mapping() const;
  private:
  bool _internal_has_no_mapping() const;
  public:
  void clear_no_mapping();
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& no_mapping() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64PacketCounters* release_no_mapping();
  ::threadnetwork::TelemetryData_Nat64PacketCounters* mutable_no_mapping();
  void set_allocated_no_mapping(::threadnetwork::TelemetryData_Nat64PacketCounters* no_mapping);
  private:
  const ::threadnetwork::TelemetryData_Nat64PacketCounters& _internal_no_mapping() const;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _internal_mutable_no_mapping();
  public:
  void unsafe_arena_set_allocated_no_mapping(
      ::threadnetwork::TelemetryData_Nat64PacketCounters* no_mapping);
  ::threadnetwork::TelemetryData_Nat64PacketCounters* unsafe_arena_release_no_mapping();

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Nat64ErrorCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_Nat64PacketCounters* unknown_;
    ::threadnetwork::TelemetryData_Nat64PacketCounters* illegal_packet_;
    ::threadnetwork::TelemetryData_Nat64PacketCounters* unsupported_protocol_;
    ::threadnetwork::TelemetryData_Nat64PacketCounters* no_mapping_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_BorderRoutingCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.BorderRoutingCounters) */ {
 public:
  inline TelemetryData_BorderRoutingCounters() : TelemetryData_BorderRoutingCounters(nullptr) {}
  ~TelemetryData_BorderRoutingCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_BorderRoutingCounters(const TelemetryData_BorderRoutingCounters& from);
  TelemetryData_BorderRoutingCounters(TelemetryData_BorderRoutingCounters&& from) noexcept
    : TelemetryData_BorderRoutingCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_BorderRoutingCounters& operator=(const TelemetryData_BorderRoutingCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_BorderRoutingCounters& operator=(TelemetryData_BorderRoutingCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_BorderRoutingCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_BorderRoutingCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_BorderRoutingCounters*>(
               &_TelemetryData_BorderRoutingCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TelemetryData_BorderRoutingCounters& a, TelemetryData_BorderRoutingCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_BorderRoutingCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_BorderRoutingCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_BorderRoutingCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_BorderRoutingCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_BorderRoutingCounters& from);
  void MergeFrom(const TelemetryData_BorderRoutingCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_BorderRoutingCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.BorderRoutingCounters";
  }
  protected:
  explicit TelemetryData_BorderRoutingCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInboundUnicastFieldNumber = 15,
    kInboundMulticastFieldNumber = 16,
    kOutboundUnicastFieldNumber = 17,
    kOutboundMulticastFieldNumber = 18,
    kNat64ProtocolCountersFieldNumber = 19,
    kNat64ErrorCountersFieldNumber = 20,
    kInboundInternetFieldNumber = 21,
    kOutboundInternetFieldNumber = 22,
    kRaRxFieldNumber = 9,
    kRaTxSuccessFieldNumber = 10,
    kRaTxFailureFieldNumber = 11,
    kRsRxFieldNumber = 12,
    kRsTxSuccessFieldNumber = 13,
    kRsTxFailureFieldNumber = 14,
  };
  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_unicast = 15;
  bool has_inbound_unicast() const;
  private:
  bool _internal_has_inbound_unicast() const;
  public:
  void clear_inbound_unicast();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_unicast() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_inbound_unicast();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_inbound_unicast();
  void set_allocated_inbound_unicast(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_unicast);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_inbound_unicast() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_inbound_unicast();
  public:
  void unsafe_arena_set_allocated_inbound_unicast(
      ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_unicast);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_inbound_unicast();

  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_multicast = 16;
  bool has_inbound_multicast() const;
  private:
  bool _internal_has_inbound_multicast() const;
  public:
  void clear_inbound_multicast();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_multicast() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_inbound_multicast();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_inbound_multicast();
  void set_allocated_inbound_multicast(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_multicast);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_inbound_multicast() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_inbound_multicast();
  public:
  void unsafe_arena_set_allocated_inbound_multicast(
      ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_multicast);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_inbound_multicast();

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_unicast = 17;
  bool has_outbound_unicast() const;
  private:
  bool _internal_has_outbound_unicast() const;
  public:
  void clear_outbound_unicast();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_unicast() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_outbound_unicast();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_outbound_unicast();
  void set_allocated_outbound_unicast(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_unicast);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_outbound_unicast() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_outbound_unicast();
  public:
  void unsafe_arena_set_allocated_outbound_unicast(
      ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_unicast);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_outbound_unicast();

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_multicast = 18;
  bool has_outbound_multicast() const;
  private:
  bool _internal_has_outbound_multicast() const;
  public:
  void clear_outbound_multicast();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_multicast() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_outbound_multicast();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_outbound_multicast();
  void set_allocated_outbound_multicast(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_multicast);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_outbound_multicast() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_outbound_multicast();
  public:
  void unsafe_arena_set_allocated_outbound_multicast(
      ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_multicast);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_outbound_multicast();

  // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters nat64_protocol_counters = 19;
  bool has_nat64_protocol_counters() const;
  private:
  bool _internal_has_nat64_protocol_counters() const;
  public:
  void clear_nat64_protocol_counters();
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& nat64_protocol_counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64ProtocolCounters* release_nat64_protocol_counters();
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* mutable_nat64_protocol_counters();
  void set_allocated_nat64_protocol_counters(::threadnetwork::TelemetryData_Nat64ProtocolCounters* nat64_protocol_counters);
  private:
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& _internal_nat64_protocol_counters() const;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* _internal_mutable_nat64_protocol_counters();
  public:
  void unsafe_arena_set_allocated_nat64_protocol_counters(
      ::threadnetwork::TelemetryData_Nat64ProtocolCounters* nat64_protocol_counters);
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* unsafe_arena_release_nat64_protocol_counters();

  // optional .threadnetwork.TelemetryData.Nat64ErrorCounters nat64_error_counters = 20;
  bool has_nat64_error_counters() const;
  private:
  bool _internal_has_nat64_error_counters() const;
  public:
  void clear_nat64_error_counters();
  const ::threadnetwork::TelemetryData_Nat64ErrorCounters& nat64_error_counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64ErrorCounters* release_nat64_error_counters();
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* mutable_nat64_error_counters();
  void set_allocated_nat64_error_counters(::threadnetwork::TelemetryData_Nat64ErrorCounters* nat64_error_counters);
  private:
  const ::threadnetwork::TelemetryData_Nat64ErrorCounters& _internal_nat64_error_counters() const;
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* _internal_mutable_nat64_error_counters();
  public:
  void unsafe_arena_set_allocated_nat64_error_counters(
      ::threadnetwork::TelemetryData_Nat64ErrorCounters* nat64_error_counters);
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* unsafe_arena_release_nat64_error_counters();

  // optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_internet = 21;
  bool has_inbound_internet() const;
  private:
  bool _internal_has_inbound_internet() const;
  public:
  void clear_inbound_internet();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& inbound_internet() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_inbound_internet();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_inbound_internet();
  void set_allocated_inbound_internet(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_internet);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_inbound_internet() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_inbound_internet();
  public:
  void unsafe_arena_set_allocated_inbound_internet(
      ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_internet);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_inbound_internet();

  // optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_internet = 22;
  bool has_outbound_internet() const;
  private:
  bool _internal_has_outbound_internet() const;
  public:
  void clear_outbound_internet();
  const ::threadnetwork::TelemetryData_PacketsAndBytes& outbound_internet() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PacketsAndBytes* release_outbound_internet();
  ::threadnetwork::TelemetryData_PacketsAndBytes* mutable_outbound_internet();
  void set_allocated_outbound_internet(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_internet);
  private:
  const ::threadnetwork::TelemetryData_PacketsAndBytes& _internal_outbound_internet() const;
  ::threadnetwork::TelemetryData_PacketsAndBytes* _internal_mutable_outbound_internet();
  public:
  void unsafe_arena_set_allocated_outbound_internet(
      ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_internet);
  ::threadnetwork::TelemetryData_PacketsAndBytes* unsafe_arena_release_outbound_internet();

  // optional int64 ra_rx = 9;
  bool has_ra_rx() const;
  private:
  bool _internal_has_ra_rx() const;
  public:
  void clear_ra_rx();
  int64_t ra_rx() const;
  void set_ra_rx(int64_t value);
  private:
  int64_t _internal_ra_rx() const;
  void _internal_set_ra_rx(int64_t value);
  public:

  // optional int64 ra_tx_success = 10;
  bool has_ra_tx_success() const;
  private:
  bool _internal_has_ra_tx_success() const;
  public:
  void clear_ra_tx_success();
  int64_t ra_tx_success() const;
  void set_ra_tx_success(int64_t value);
  private:
  int64_t _internal_ra_tx_success() const;
  void _internal_set_ra_tx_success(int64_t value);
  public:

  // optional int64 ra_tx_failure = 11;
  bool has_ra_tx_failure() const;
  private:
  bool _internal_has_ra_tx_failure() const;
  public:
  void clear_ra_tx_failure();
  int64_t ra_tx_failure() const;
  void set_ra_tx_failure(int64_t value);
  private:
  int64_t _internal_ra_tx_failure() const;
  void _internal_set_ra_tx_failure(int64_t value);
  public:

  // optional int64 rs_rx = 12;
  bool has_rs_rx() const;
  private:
  bool _internal_has_rs_rx() const;
  public:
  void clear_rs_rx();
  int64_t rs_rx() const;
  void set_rs_rx(int64_t value);
  private:
  int64_t _internal_rs_rx() const;
  void _internal_set_rs_rx(int64_t value);
  public:

  // optional int64 rs_tx_success = 13;
  bool has_rs_tx_success() const;
  private:
  bool _internal_has_rs_tx_success() const;
  public:
  void clear_rs_tx_success();
  int64_t rs_tx_success() const;
  void set_rs_tx_success(int64_t value);
  private:
  int64_t _internal_rs_tx_success() const;
  void _internal_set_rs_tx_success(int64_t value);
  public:

  // optional int64 rs_tx_failure = 14;
  bool has_rs_tx_failure() const;
  private:
  bool _internal_has_rs_tx_failure() const;
  public:
  void clear_rs_tx_failure();
  int64_t rs_tx_failure() const;
  void set_rs_tx_failure(int64_t value);
  private:
  int64_t _internal_rs_tx_failure() const;
  void _internal_set_rs_tx_failure(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.BorderRoutingCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_unicast_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_multicast_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_unicast_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_multicast_;
    ::threadnetwork::TelemetryData_Nat64ProtocolCounters* nat64_protocol_counters_;
    ::threadnetwork::TelemetryData_Nat64ErrorCounters* nat64_error_counters_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_internet_;
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_internet_;
    int64_t ra_rx_;
    int64_t ra_tx_success_;
    int64_t ra_tx_failure_;
    int64_t rs_rx_;
    int64_t rs_tx_success_;
    int64_t rs_tx_failure_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_PdProcessedRaInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.PdProcessedRaInfo) */ {
 public:
  inline TelemetryData_PdProcessedRaInfo() : TelemetryData_PdProcessedRaInfo(nullptr) {}
  ~TelemetryData_PdProcessedRaInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_PdProcessedRaInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_PdProcessedRaInfo(const TelemetryData_PdProcessedRaInfo& from);
  TelemetryData_PdProcessedRaInfo(TelemetryData_PdProcessedRaInfo&& from) noexcept
    : TelemetryData_PdProcessedRaInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_PdProcessedRaInfo& operator=(const TelemetryData_PdProcessedRaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_PdProcessedRaInfo& operator=(TelemetryData_PdProcessedRaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_PdProcessedRaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_PdProcessedRaInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_PdProcessedRaInfo*>(
               &_TelemetryData_PdProcessedRaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TelemetryData_PdProcessedRaInfo& a, TelemetryData_PdProcessedRaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_PdProcessedRaInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_PdProcessedRaInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_PdProcessedRaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_PdProcessedRaInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_PdProcessedRaInfo& from);
  void MergeFrom(const TelemetryData_PdProcessedRaInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_PdProcessedRaInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.PdProcessedRaInfo";
  }
  protected:
  explicit TelemetryData_PdProcessedRaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumPlatformRaReceivedFieldNumber = 1,
    kNumPlatformPioProcessedFieldNumber = 2,
    kLastPlatformRaMsecFieldNumber = 3,
  };
  // optional uint32 num_platform_ra_received = 1;
  bool has_num_platform_ra_received() const;
  private:
  bool _internal_has_num_platform_ra_received() const;
  public:
  void clear_num_platform_ra_received();
  uint32_t num_platform_ra_received() const;
  void set_num_platform_ra_received(uint32_t value);
  private:
  uint32_t _internal_num_platform_ra_received() const;
  void _internal_set_num_platform_ra_received(uint32_t value);
  public:

  // optional uint32 num_platform_pio_processed = 2;
  bool has_num_platform_pio_processed() const;
  private:
  bool _internal_has_num_platform_pio_processed() const;
  public:
  void clear_num_platform_pio_processed();
  uint32_t num_platform_pio_processed() const;
  void set_num_platform_pio_processed(uint32_t value);
  private:
  uint32_t _internal_num_platform_pio_processed() const;
  void _internal_set_num_platform_pio_processed(uint32_t value);
  public:

  // optional uint32 last_platform_ra_msec = 3;
  bool has_last_platform_ra_msec() const;
  private:
  bool _internal_has_last_platform_ra_msec() const;
  public:
  void clear_last_platform_ra_msec();
  uint32_t last_platform_ra_msec() const;
  void set_last_platform_ra_msec(uint32_t value);
  private:
  uint32_t _internal_last_platform_ra_msec() const;
  void _internal_set_last_platform_ra_msec(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.PdProcessedRaInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t num_platform_ra_received_;
    uint32_t num_platform_pio_processed_;
    uint32_t last_platform_ra_msec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_SrpServerRegistrationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.SrpServerRegistrationInfo) */ {
 public:
  inline TelemetryData_SrpServerRegistrationInfo() : TelemetryData_SrpServerRegistrationInfo(nullptr) {}
  ~TelemetryData_SrpServerRegistrationInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_SrpServerRegistrationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_SrpServerRegistrationInfo(const TelemetryData_SrpServerRegistrationInfo& from);
  TelemetryData_SrpServerRegistrationInfo(TelemetryData_SrpServerRegistrationInfo&& from) noexcept
    : TelemetryData_SrpServerRegistrationInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_SrpServerRegistrationInfo& operator=(const TelemetryData_SrpServerRegistrationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_SrpServerRegistrationInfo& operator=(TelemetryData_SrpServerRegistrationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_SrpServerRegistrationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_SrpServerRegistrationInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_SrpServerRegistrationInfo*>(
               &_TelemetryData_SrpServerRegistrationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TelemetryData_SrpServerRegistrationInfo& a, TelemetryData_SrpServerRegistrationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_SrpServerRegistrationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_SrpServerRegistrationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_SrpServerRegistrationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_SrpServerRegistrationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_SrpServerRegistrationInfo& from);
  void MergeFrom(const TelemetryData_SrpServerRegistrationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_SrpServerRegistrationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.SrpServerRegistrationInfo";
  }
  protected:
  explicit TelemetryData_SrpServerRegistrationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreshCountFieldNumber = 1,
    kDeletedCountFieldNumber = 2,
    kLeaseTimeTotalMsFieldNumber = 3,
    kKeyLeaseTimeTotalMsFieldNumber = 4,
    kRemainingLeaseTimeTotalMsFieldNumber = 5,
    kRemainingKeyLeaseTimeTotalMsFieldNumber = 6,
  };
  // optional uint32 fresh_count = 1;
  bool has_fresh_count() const;
  private:
  bool _internal_has_fresh_count() const;
  public:
  void clear_fresh_count();
  uint32_t fresh_count() const;
  void set_fresh_count(uint32_t value);
  private:
  uint32_t _internal_fresh_count() const;
  void _internal_set_fresh_count(uint32_t value);
  public:

  // optional uint32 deleted_count = 2;
  bool has_deleted_count() const;
  private:
  bool _internal_has_deleted_count() const;
  public:
  void clear_deleted_count();
  uint32_t deleted_count() const;
  void set_deleted_count(uint32_t value);
  private:
  uint32_t _internal_deleted_count() const;
  void _internal_set_deleted_count(uint32_t value);
  public:

  // optional uint64 lease_time_total_ms = 3;
  bool has_lease_time_total_ms() const;
  private:
  bool _internal_has_lease_time_total_ms() const;
  public:
  void clear_lease_time_total_ms();
  uint64_t lease_time_total_ms() const;
  void set_lease_time_total_ms(uint64_t value);
  private:
  uint64_t _internal_lease_time_total_ms() const;
  void _internal_set_lease_time_total_ms(uint64_t value);
  public:

  // optional uint64 key_lease_time_total_ms = 4;
  bool has_key_lease_time_total_ms() const;
  private:
  bool _internal_has_key_lease_time_total_ms() const;
  public:
  void clear_key_lease_time_total_ms();
  uint64_t key_lease_time_total_ms() const;
  void set_key_lease_time_total_ms(uint64_t value);
  private:
  uint64_t _internal_key_lease_time_total_ms() const;
  void _internal_set_key_lease_time_total_ms(uint64_t value);
  public:

  // optional uint64 remaining_lease_time_total_ms = 5;
  bool has_remaining_lease_time_total_ms() const;
  private:
  bool _internal_has_remaining_lease_time_total_ms() const;
  public:
  void clear_remaining_lease_time_total_ms();
  uint64_t remaining_lease_time_total_ms() const;
  void set_remaining_lease_time_total_ms(uint64_t value);
  private:
  uint64_t _internal_remaining_lease_time_total_ms() const;
  void _internal_set_remaining_lease_time_total_ms(uint64_t value);
  public:

  // optional uint64 remaining_key_lease_time_total_ms = 6;
  bool has_remaining_key_lease_time_total_ms() const;
  private:
  bool _internal_has_remaining_key_lease_time_total_ms() const;
  public:
  void clear_remaining_key_lease_time_total_ms();
  uint64_t remaining_key_lease_time_total_ms() const;
  void set_remaining_key_lease_time_total_ms(uint64_t value);
  private:
  uint64_t _internal_remaining_key_lease_time_total_ms() const;
  void _internal_set_remaining_key_lease_time_total_ms(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.SrpServerRegistrationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t fresh_count_;
    uint32_t deleted_count_;
    uint64_t lease_time_total_ms_;
    uint64_t key_lease_time_total_ms_;
    uint64_t remaining_lease_time_total_ms_;
    uint64_t remaining_key_lease_time_total_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_SrpServerResponseCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.SrpServerResponseCounters) */ {
 public:
  inline TelemetryData_SrpServerResponseCounters() : TelemetryData_SrpServerResponseCounters(nullptr) {}
  ~TelemetryData_SrpServerResponseCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_SrpServerResponseCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_SrpServerResponseCounters(const TelemetryData_SrpServerResponseCounters& from);
  TelemetryData_SrpServerResponseCounters(TelemetryData_SrpServerResponseCounters&& from) noexcept
    : TelemetryData_SrpServerResponseCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_SrpServerResponseCounters& operator=(const TelemetryData_SrpServerResponseCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_SrpServerResponseCounters& operator=(TelemetryData_SrpServerResponseCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_SrpServerResponseCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_SrpServerResponseCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_SrpServerResponseCounters*>(
               &_TelemetryData_SrpServerResponseCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TelemetryData_SrpServerResponseCounters& a, TelemetryData_SrpServerResponseCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_SrpServerResponseCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_SrpServerResponseCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_SrpServerResponseCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_SrpServerResponseCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_SrpServerResponseCounters& from);
  void MergeFrom(const TelemetryData_SrpServerResponseCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_SrpServerResponseCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.SrpServerResponseCounters";
  }
  protected:
  explicit TelemetryData_SrpServerResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessCountFieldNumber = 1,
    kServerFailureCountFieldNumber = 2,
    kFormatErrorCountFieldNumber = 3,
    kNameExistsCountFieldNumber = 4,
    kRefusedCountFieldNumber = 5,
    kOtherCountFieldNumber = 6,
  };
  // optional uint32 success_count = 1;
  bool has_success_count() const;
  private:
  bool _internal_has_success_count() const;
  public:
  void clear_success_count();
  uint32_t success_count() const;
  void set_success_count(uint32_t value);
  private:
  uint32_t _internal_success_count() const;
  void _internal_set_success_count(uint32_t value);
  public:

  // optional uint32 server_failure_count = 2;
  bool has_server_failure_count() const;
  private:
  bool _internal_has_server_failure_count() const;
  public:
  void clear_server_failure_count();
  uint32_t server_failure_count() const;
  void set_server_failure_count(uint32_t value);
  private:
  uint32_t _internal_server_failure_count() const;
  void _internal_set_server_failure_count(uint32_t value);
  public:

  // optional uint32 format_error_count = 3;
  bool has_format_error_count() const;
  private:
  bool _internal_has_format_error_count() const;
  public:
  void clear_format_error_count();
  uint32_t format_error_count() const;
  void set_format_error_count(uint32_t value);
  private:
  uint32_t _internal_format_error_count() const;
  void _internal_set_format_error_count(uint32_t value);
  public:

  // optional uint32 name_exists_count = 4;
  bool has_name_exists_count() const;
  private:
  bool _internal_has_name_exists_count() const;
  public:
  void clear_name_exists_count();
  uint32_t name_exists_count() const;
  void set_name_exists_count(uint32_t value);
  private:
  uint32_t _internal_name_exists_count() const;
  void _internal_set_name_exists_count(uint32_t value);
  public:

  // optional uint32 refused_count = 5;
  bool has_refused_count() const;
  private:
  bool _internal_has_refused_count() const;
  public:
  void clear_refused_count();
  uint32_t refused_count() const;
  void set_refused_count(uint32_t value);
  private:
  uint32_t _internal_refused_count() const;
  void _internal_set_refused_count(uint32_t value);
  public:

  // optional uint32 other_count = 6;
  bool has_other_count() const;
  private:
  bool _internal_has_other_count() const;
  public:
  void clear_other_count();
  uint32_t other_count() const;
  void set_other_count(uint32_t value);
  private:
  uint32_t _internal_other_count() const;
  void _internal_set_other_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.SrpServerResponseCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t success_count_;
    uint32_t server_failure_count_;
    uint32_t format_error_count_;
    uint32_t name_exists_count_;
    uint32_t refused_count_;
    uint32_t other_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_SrpServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.SrpServerInfo) */ {
 public:
  inline TelemetryData_SrpServerInfo() : TelemetryData_SrpServerInfo(nullptr) {}
  ~TelemetryData_SrpServerInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_SrpServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_SrpServerInfo(const TelemetryData_SrpServerInfo& from);
  TelemetryData_SrpServerInfo(TelemetryData_SrpServerInfo&& from) noexcept
    : TelemetryData_SrpServerInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_SrpServerInfo& operator=(const TelemetryData_SrpServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_SrpServerInfo& operator=(TelemetryData_SrpServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_SrpServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_SrpServerInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_SrpServerInfo*>(
               &_TelemetryData_SrpServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TelemetryData_SrpServerInfo& a, TelemetryData_SrpServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_SrpServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_SrpServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_SrpServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_SrpServerInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_SrpServerInfo& from);
  void MergeFrom(const TelemetryData_SrpServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_SrpServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.SrpServerInfo";
  }
  protected:
  explicit TelemetryData_SrpServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostsFieldNumber = 4,
    kServicesFieldNumber = 5,
    kResponseCountersFieldNumber = 6,
    kStateFieldNumber = 1,
    kPortFieldNumber = 2,
    kAddressModeFieldNumber = 3,
  };
  // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo hosts = 4;
  bool has_hosts() const;
  private:
  bool _internal_has_hosts() const;
  public:
  void clear_hosts();
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& hosts() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* release_hosts();
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* mutable_hosts();
  void set_allocated_hosts(::threadnetwork::TelemetryData_SrpServerRegistrationInfo* hosts);
  private:
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& _internal_hosts() const;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* _internal_mutable_hosts();
  public:
  void unsafe_arena_set_allocated_hosts(
      ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* hosts);
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* unsafe_arena_release_hosts();

  // optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo services = 5;
  bool has_services() const;
  private:
  bool _internal_has_services() const;
  public:
  void clear_services();
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& services() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* release_services();
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* mutable_services();
  void set_allocated_services(::threadnetwork::TelemetryData_SrpServerRegistrationInfo* services);
  private:
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& _internal_services() const;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* _internal_mutable_services();
  public:
  void unsafe_arena_set_allocated_services(
      ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* services);
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* unsafe_arena_release_services();

  // optional .threadnetwork.TelemetryData.SrpServerResponseCounters response_counters = 6;
  bool has_response_counters() const;
  private:
  bool _internal_has_response_counters() const;
  public:
  void clear_response_counters();
  const ::threadnetwork::TelemetryData_SrpServerResponseCounters& response_counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_SrpServerResponseCounters* release_response_counters();
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* mutable_response_counters();
  void set_allocated_response_counters(::threadnetwork::TelemetryData_SrpServerResponseCounters* response_counters);
  private:
  const ::threadnetwork::TelemetryData_SrpServerResponseCounters& _internal_response_counters() const;
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* _internal_mutable_response_counters();
  public:
  void unsafe_arena_set_allocated_response_counters(
      ::threadnetwork::TelemetryData_SrpServerResponseCounters* response_counters);
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* unsafe_arena_release_response_counters();

  // optional .threadnetwork.TelemetryData.SrpServerState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::threadnetwork::TelemetryData_SrpServerState state() const;
  void set_state(::threadnetwork::TelemetryData_SrpServerState value);
  private:
  ::threadnetwork::TelemetryData_SrpServerState _internal_state() const;
  void _internal_set_state(::threadnetwork::TelemetryData_SrpServerState value);
  public:

  // optional uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // optional .threadnetwork.TelemetryData.SrpServerAddressMode address_mode = 3;
  bool has_address_mode() const;
  private:
  bool _internal_has_address_mode() const;
  public:
  void clear_address_mode();
  ::threadnetwork::TelemetryData_SrpServerAddressMode address_mode() const;
  void set_address_mode(::threadnetwork::TelemetryData_SrpServerAddressMode value);
  private:
  ::threadnetwork::TelemetryData_SrpServerAddressMode _internal_address_mode() const;
  void _internal_set_address_mode(::threadnetwork::TelemetryData_SrpServerAddressMode value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.SrpServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* hosts_;
    ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* services_;
    ::threadnetwork::TelemetryData_SrpServerResponseCounters* response_counters_;
    int state_;
    uint32_t port_;
    int address_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_TrelPacketCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.TrelPacketCounters) */ {
 public:
  inline TelemetryData_TrelPacketCounters() : TelemetryData_TrelPacketCounters(nullptr) {}
  ~TelemetryData_TrelPacketCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_TrelPacketCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_TrelPacketCounters(const TelemetryData_TrelPacketCounters& from);
  TelemetryData_TrelPacketCounters(TelemetryData_TrelPacketCounters&& from) noexcept
    : TelemetryData_TrelPacketCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_TrelPacketCounters& operator=(const TelemetryData_TrelPacketCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_TrelPacketCounters& operator=(TelemetryData_TrelPacketCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_TrelPacketCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_TrelPacketCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_TrelPacketCounters*>(
               &_TelemetryData_TrelPacketCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TelemetryData_TrelPacketCounters& a, TelemetryData_TrelPacketCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_TrelPacketCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_TrelPacketCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_TrelPacketCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_TrelPacketCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_TrelPacketCounters& from);
  void MergeFrom(const TelemetryData_TrelPacketCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_TrelPacketCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.TrelPacketCounters";
  }
  protected:
  explicit TelemetryData_TrelPacketCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrelTxPacketsFieldNumber = 1,
    kTrelTxBytesFieldNumber = 2,
    kTrelTxPacketsFailedFieldNumber = 3,
    kTreRxPacketsFieldNumber = 4,
    kTrelRxBytesFieldNumber = 5,
  };
  // optional uint64 trel_tx_packets = 1;
  bool has_trel_tx_packets() const;
  private:
  bool _internal_has_trel_tx_packets() const;
  public:
  void clear_trel_tx_packets();
  uint64_t trel_tx_packets() const;
  void set_trel_tx_packets(uint64_t value);
  private:
  uint64_t _internal_trel_tx_packets() const;
  void _internal_set_trel_tx_packets(uint64_t value);
  public:

  // optional uint64 trel_tx_bytes = 2;
  bool has_trel_tx_bytes() const;
  private:
  bool _internal_has_trel_tx_bytes() const;
  public:
  void clear_trel_tx_bytes();
  uint64_t trel_tx_bytes() const;
  void set_trel_tx_bytes(uint64_t value);
  private:
  uint64_t _internal_trel_tx_bytes() const;
  void _internal_set_trel_tx_bytes(uint64_t value);
  public:

  // optional uint64 trel_tx_packets_failed = 3;
  bool has_trel_tx_packets_failed() const;
  private:
  bool _internal_has_trel_tx_packets_failed() const;
  public:
  void clear_trel_tx_packets_failed();
  uint64_t trel_tx_packets_failed() const;
  void set_trel_tx_packets_failed(uint64_t value);
  private:
  uint64_t _internal_trel_tx_packets_failed() const;
  void _internal_set_trel_tx_packets_failed(uint64_t value);
  public:

  // optional uint64 tre_rx_packets = 4;
  bool has_tre_rx_packets() const;
  private:
  bool _internal_has_tre_rx_packets() const;
  public:
  void clear_tre_rx_packets();
  uint64_t tre_rx_packets() const;
  void set_tre_rx_packets(uint64_t value);
  private:
  uint64_t _internal_tre_rx_packets() const;
  void _internal_set_tre_rx_packets(uint64_t value);
  public:

  // optional uint64 trel_rx_bytes = 5;
  bool has_trel_rx_bytes() const;
  private:
  bool _internal_has_trel_rx_bytes() const;
  public:
  void clear_trel_rx_bytes();
  uint64_t trel_rx_bytes() const;
  void set_trel_rx_bytes(uint64_t value);
  private:
  uint64_t _internal_trel_rx_bytes() const;
  void _internal_set_trel_rx_bytes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.TrelPacketCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t trel_tx_packets_;
    uint64_t trel_tx_bytes_;
    uint64_t trel_tx_packets_failed_;
    uint64_t tre_rx_packets_;
    uint64_t trel_rx_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_TrelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.TrelInfo) */ {
 public:
  inline TelemetryData_TrelInfo() : TelemetryData_TrelInfo(nullptr) {}
  ~TelemetryData_TrelInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_TrelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_TrelInfo(const TelemetryData_TrelInfo& from);
  TelemetryData_TrelInfo(TelemetryData_TrelInfo&& from) noexcept
    : TelemetryData_TrelInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_TrelInfo& operator=(const TelemetryData_TrelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_TrelInfo& operator=(TelemetryData_TrelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_TrelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_TrelInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_TrelInfo*>(
               &_TelemetryData_TrelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TelemetryData_TrelInfo& a, TelemetryData_TrelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_TrelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_TrelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_TrelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_TrelInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_TrelInfo& from);
  void MergeFrom(const TelemetryData_TrelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_TrelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.TrelInfo";
  }
  protected:
  explicit TelemetryData_TrelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountersFieldNumber = 3,
    kIsTrelEnabledFieldNumber = 1,
    kNumTrelPeersFieldNumber = 2,
  };
  // optional .threadnetwork.TelemetryData.TrelPacketCounters counters = 3;
  bool has_counters() const;
  private:
  bool _internal_has_counters() const;
  public:
  void clear_counters();
  const ::threadnetwork::TelemetryData_TrelPacketCounters& counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_TrelPacketCounters* release_counters();
  ::threadnetwork::TelemetryData_TrelPacketCounters* mutable_counters();
  void set_allocated_counters(::threadnetwork::TelemetryData_TrelPacketCounters* counters);
  private:
  const ::threadnetwork::TelemetryData_TrelPacketCounters& _internal_counters() const;
  ::threadnetwork::TelemetryData_TrelPacketCounters* _internal_mutable_counters();
  public:
  void unsafe_arena_set_allocated_counters(
      ::threadnetwork::TelemetryData_TrelPacketCounters* counters);
  ::threadnetwork::TelemetryData_TrelPacketCounters* unsafe_arena_release_counters();

  // optional bool is_trel_enabled = 1;
  bool has_is_trel_enabled() const;
  private:
  bool _internal_has_is_trel_enabled() const;
  public:
  void clear_is_trel_enabled();
  bool is_trel_enabled() const;
  void set_is_trel_enabled(bool value);
  private:
  bool _internal_is_trel_enabled() const;
  void _internal_set_is_trel_enabled(bool value);
  public:

  // optional uint32 num_trel_peers = 2;
  bool has_num_trel_peers() const;
  private:
  bool _internal_has_num_trel_peers() const;
  public:
  void clear_num_trel_peers();
  uint32_t num_trel_peers() const;
  void set_num_trel_peers(uint32_t value);
  private:
  uint32_t _internal_num_trel_peers() const;
  void _internal_set_num_trel_peers(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.TrelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_TrelPacketCounters* counters_;
    bool is_trel_enabled_;
    uint32_t num_trel_peers_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_DnsServerResponseCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.DnsServerResponseCounters) */ {
 public:
  inline TelemetryData_DnsServerResponseCounters() : TelemetryData_DnsServerResponseCounters(nullptr) {}
  ~TelemetryData_DnsServerResponseCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_DnsServerResponseCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_DnsServerResponseCounters(const TelemetryData_DnsServerResponseCounters& from);
  TelemetryData_DnsServerResponseCounters(TelemetryData_DnsServerResponseCounters&& from) noexcept
    : TelemetryData_DnsServerResponseCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_DnsServerResponseCounters& operator=(const TelemetryData_DnsServerResponseCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_DnsServerResponseCounters& operator=(TelemetryData_DnsServerResponseCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_DnsServerResponseCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_DnsServerResponseCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_DnsServerResponseCounters*>(
               &_TelemetryData_DnsServerResponseCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TelemetryData_DnsServerResponseCounters& a, TelemetryData_DnsServerResponseCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_DnsServerResponseCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_DnsServerResponseCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_DnsServerResponseCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_DnsServerResponseCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_DnsServerResponseCounters& from);
  void MergeFrom(const TelemetryData_DnsServerResponseCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_DnsServerResponseCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.DnsServerResponseCounters";
  }
  protected:
  explicit TelemetryData_DnsServerResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessCountFieldNumber = 1,
    kServerFailureCountFieldNumber = 2,
    kFormatErrorCountFieldNumber = 3,
    kNameErrorCountFieldNumber = 4,
    kNotImplementedCountFieldNumber = 5,
    kOtherCountFieldNumber = 6,
    kUpstreamDnsQueriesFieldNumber = 7,
    kUpstreamDnsResponsesFieldNumber = 8,
    kUpstreamDnsFailuresFieldNumber = 9,
  };
  // optional uint32 success_count = 1;
  bool has_success_count() const;
  private:
  bool _internal_has_success_count() const;
  public:
  void clear_success_count();
  uint32_t success_count() const;
  void set_success_count(uint32_t value);
  private:
  uint32_t _internal_success_count() const;
  void _internal_set_success_count(uint32_t value);
  public:

  // optional uint32 server_failure_count = 2;
  bool has_server_failure_count() const;
  private:
  bool _internal_has_server_failure_count() const;
  public:
  void clear_server_failure_count();
  uint32_t server_failure_count() const;
  void set_server_failure_count(uint32_t value);
  private:
  uint32_t _internal_server_failure_count() const;
  void _internal_set_server_failure_count(uint32_t value);
  public:

  // optional uint32 format_error_count = 3;
  bool has_format_error_count() const;
  private:
  bool _internal_has_format_error_count() const;
  public:
  void clear_format_error_count();
  uint32_t format_error_count() const;
  void set_format_error_count(uint32_t value);
  private:
  uint32_t _internal_format_error_count() const;
  void _internal_set_format_error_count(uint32_t value);
  public:

  // optional uint32 name_error_count = 4;
  bool has_name_error_count() const;
  private:
  bool _internal_has_name_error_count() const;
  public:
  void clear_name_error_count();
  uint32_t name_error_count() const;
  void set_name_error_count(uint32_t value);
  private:
  uint32_t _internal_name_error_count() const;
  void _internal_set_name_error_count(uint32_t value);
  public:

  // optional uint32 not_implemented_count = 5;
  bool has_not_implemented_count() const;
  private:
  bool _internal_has_not_implemented_count() const;
  public:
  void clear_not_implemented_count();
  uint32_t not_implemented_count() const;
  void set_not_implemented_count(uint32_t value);
  private:
  uint32_t _internal_not_implemented_count() const;
  void _internal_set_not_implemented_count(uint32_t value);
  public:

  // optional uint32 other_count = 6;
  bool has_other_count() const;
  private:
  bool _internal_has_other_count() const;
  public:
  void clear_other_count();
  uint32_t other_count() const;
  void set_other_count(uint32_t value);
  private:
  uint32_t _internal_other_count() const;
  void _internal_set_other_count(uint32_t value);
  public:

  // optional uint32 upstream_dns_queries = 7;
  bool has_upstream_dns_queries() const;
  private:
  bool _internal_has_upstream_dns_queries() const;
  public:
  void clear_upstream_dns_queries();
  uint32_t upstream_dns_queries() const;
  void set_upstream_dns_queries(uint32_t value);
  private:
  uint32_t _internal_upstream_dns_queries() const;
  void _internal_set_upstream_dns_queries(uint32_t value);
  public:

  // optional uint32 upstream_dns_responses = 8;
  bool has_upstream_dns_responses() const;
  private:
  bool _internal_has_upstream_dns_responses() const;
  public:
  void clear_upstream_dns_responses();
  uint32_t upstream_dns_responses() const;
  void set_upstream_dns_responses(uint32_t value);
  private:
  uint32_t _internal_upstream_dns_responses() const;
  void _internal_set_upstream_dns_responses(uint32_t value);
  public:

  // optional uint32 upstream_dns_failures = 9;
  bool has_upstream_dns_failures() const;
  private:
  bool _internal_has_upstream_dns_failures() const;
  public:
  void clear_upstream_dns_failures();
  uint32_t upstream_dns_failures() const;
  void set_upstream_dns_failures(uint32_t value);
  private:
  uint32_t _internal_upstream_dns_failures() const;
  void _internal_set_upstream_dns_failures(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.DnsServerResponseCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t success_count_;
    uint32_t server_failure_count_;
    uint32_t format_error_count_;
    uint32_t name_error_count_;
    uint32_t not_implemented_count_;
    uint32_t other_count_;
    uint32_t upstream_dns_queries_;
    uint32_t upstream_dns_responses_;
    uint32_t upstream_dns_failures_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_DnsServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.DnsServerInfo) */ {
 public:
  inline TelemetryData_DnsServerInfo() : TelemetryData_DnsServerInfo(nullptr) {}
  ~TelemetryData_DnsServerInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_DnsServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_DnsServerInfo(const TelemetryData_DnsServerInfo& from);
  TelemetryData_DnsServerInfo(TelemetryData_DnsServerInfo&& from) noexcept
    : TelemetryData_DnsServerInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_DnsServerInfo& operator=(const TelemetryData_DnsServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_DnsServerInfo& operator=(TelemetryData_DnsServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_DnsServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_DnsServerInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_DnsServerInfo*>(
               &_TelemetryData_DnsServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TelemetryData_DnsServerInfo& a, TelemetryData_DnsServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_DnsServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_DnsServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_DnsServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_DnsServerInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_DnsServerInfo& from);
  void MergeFrom(const TelemetryData_DnsServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_DnsServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.DnsServerInfo";
  }
  protected:
  explicit TelemetryData_DnsServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseCountersFieldNumber = 1,
    kResolvedByLocalSrpCountFieldNumber = 2,
    kUpstreamDnsQueryStateFieldNumber = 3,
  };
  // optional .threadnetwork.TelemetryData.DnsServerResponseCounters response_counters = 1;
  bool has_response_counters() const;
  private:
  bool _internal_has_response_counters() const;
  public:
  void clear_response_counters();
  const ::threadnetwork::TelemetryData_DnsServerResponseCounters& response_counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_DnsServerResponseCounters* release_response_counters();
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* mutable_response_counters();
  void set_allocated_response_counters(::threadnetwork::TelemetryData_DnsServerResponseCounters* response_counters);
  private:
  const ::threadnetwork::TelemetryData_DnsServerResponseCounters& _internal_response_counters() const;
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* _internal_mutable_response_counters();
  public:
  void unsafe_arena_set_allocated_response_counters(
      ::threadnetwork::TelemetryData_DnsServerResponseCounters* response_counters);
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* unsafe_arena_release_response_counters();

  // optional uint32 resolved_by_local_srp_count = 2;
  bool has_resolved_by_local_srp_count() const;
  private:
  bool _internal_has_resolved_by_local_srp_count() const;
  public:
  void clear_resolved_by_local_srp_count();
  uint32_t resolved_by_local_srp_count() const;
  void set_resolved_by_local_srp_count(uint32_t value);
  private:
  uint32_t _internal_resolved_by_local_srp_count() const;
  void _internal_set_resolved_by_local_srp_count(uint32_t value);
  public:

  // optional .threadnetwork.TelemetryData.UpstreamDnsQueryState upstream_dns_query_state = 3;
  bool has_upstream_dns_query_state() const;
  private:
  bool _internal_has_upstream_dns_query_state() const;
  public:
  void clear_upstream_dns_query_state();
  ::threadnetwork::TelemetryData_UpstreamDnsQueryState upstream_dns_query_state() const;
  void set_upstream_dns_query_state(::threadnetwork::TelemetryData_UpstreamDnsQueryState value);
  private:
  ::threadnetwork::TelemetryData_UpstreamDnsQueryState _internal_upstream_dns_query_state() const;
  void _internal_set_upstream_dns_query_state(::threadnetwork::TelemetryData_UpstreamDnsQueryState value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.DnsServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_DnsServerResponseCounters* response_counters_;
    uint32_t resolved_by_local_srp_count_;
    int upstream_dns_query_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_MdnsResponseCounters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.MdnsResponseCounters) */ {
 public:
  inline TelemetryData_MdnsResponseCounters() : TelemetryData_MdnsResponseCounters(nullptr) {}
  ~TelemetryData_MdnsResponseCounters() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_MdnsResponseCounters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_MdnsResponseCounters(const TelemetryData_MdnsResponseCounters& from);
  TelemetryData_MdnsResponseCounters(TelemetryData_MdnsResponseCounters&& from) noexcept
    : TelemetryData_MdnsResponseCounters() {
    *this = ::std::move(from);
  }

  inline TelemetryData_MdnsResponseCounters& operator=(const TelemetryData_MdnsResponseCounters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_MdnsResponseCounters& operator=(TelemetryData_MdnsResponseCounters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_MdnsResponseCounters& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_MdnsResponseCounters* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_MdnsResponseCounters*>(
               &_TelemetryData_MdnsResponseCounters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TelemetryData_MdnsResponseCounters& a, TelemetryData_MdnsResponseCounters& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_MdnsResponseCounters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_MdnsResponseCounters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_MdnsResponseCounters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_MdnsResponseCounters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_MdnsResponseCounters& from);
  void MergeFrom(const TelemetryData_MdnsResponseCounters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_MdnsResponseCounters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.MdnsResponseCounters";
  }
  protected:
  explicit TelemetryData_MdnsResponseCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessCountFieldNumber = 1,
    kNotFoundCountFieldNumber = 2,
    kInvalidArgsCountFieldNumber = 3,
    kDuplicatedCountFieldNumber = 4,
    kNotImplementedCountFieldNumber = 5,
    kUnknownErrorCountFieldNumber = 6,
    kAbortedCountFieldNumber = 7,
    kInvalidStateCountFieldNumber = 8,
  };
  // optional uint32 success_count = 1;
  bool has_success_count() const;
  private:
  bool _internal_has_success_count() const;
  public:
  void clear_success_count();
  uint32_t success_count() const;
  void set_success_count(uint32_t value);
  private:
  uint32_t _internal_success_count() const;
  void _internal_set_success_count(uint32_t value);
  public:

  // optional uint32 not_found_count = 2;
  bool has_not_found_count() const;
  private:
  bool _internal_has_not_found_count() const;
  public:
  void clear_not_found_count();
  uint32_t not_found_count() const;
  void set_not_found_count(uint32_t value);
  private:
  uint32_t _internal_not_found_count() const;
  void _internal_set_not_found_count(uint32_t value);
  public:

  // optional uint32 invalid_args_count = 3;
  bool has_invalid_args_count() const;
  private:
  bool _internal_has_invalid_args_count() const;
  public:
  void clear_invalid_args_count();
  uint32_t invalid_args_count() const;
  void set_invalid_args_count(uint32_t value);
  private:
  uint32_t _internal_invalid_args_count() const;
  void _internal_set_invalid_args_count(uint32_t value);
  public:

  // optional uint32 duplicated_count = 4;
  bool has_duplicated_count() const;
  private:
  bool _internal_has_duplicated_count() const;
  public:
  void clear_duplicated_count();
  uint32_t duplicated_count() const;
  void set_duplicated_count(uint32_t value);
  private:
  uint32_t _internal_duplicated_count() const;
  void _internal_set_duplicated_count(uint32_t value);
  public:

  // optional uint32 not_implemented_count = 5;
  bool has_not_implemented_count() const;
  private:
  bool _internal_has_not_implemented_count() const;
  public:
  void clear_not_implemented_count();
  uint32_t not_implemented_count() const;
  void set_not_implemented_count(uint32_t value);
  private:
  uint32_t _internal_not_implemented_count() const;
  void _internal_set_not_implemented_count(uint32_t value);
  public:

  // optional uint32 unknown_error_count = 6;
  bool has_unknown_error_count() const;
  private:
  bool _internal_has_unknown_error_count() const;
  public:
  void clear_unknown_error_count();
  uint32_t unknown_error_count() const;
  void set_unknown_error_count(uint32_t value);
  private:
  uint32_t _internal_unknown_error_count() const;
  void _internal_set_unknown_error_count(uint32_t value);
  public:

  // optional uint32 aborted_count = 7;
  bool has_aborted_count() const;
  private:
  bool _internal_has_aborted_count() const;
  public:
  void clear_aborted_count();
  uint32_t aborted_count() const;
  void set_aborted_count(uint32_t value);
  private:
  uint32_t _internal_aborted_count() const;
  void _internal_set_aborted_count(uint32_t value);
  public:

  // optional uint32 invalid_state_count = 8;
  bool has_invalid_state_count() const;
  private:
  bool _internal_has_invalid_state_count() const;
  public:
  void clear_invalid_state_count();
  uint32_t invalid_state_count() const;
  void set_invalid_state_count(uint32_t value);
  private:
  uint32_t _internal_invalid_state_count() const;
  void _internal_set_invalid_state_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.MdnsResponseCounters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t success_count_;
    uint32_t not_found_count_;
    uint32_t invalid_args_count_;
    uint32_t duplicated_count_;
    uint32_t not_implemented_count_;
    uint32_t unknown_error_count_;
    uint32_t aborted_count_;
    uint32_t invalid_state_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_MdnsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.MdnsInfo) */ {
 public:
  inline TelemetryData_MdnsInfo() : TelemetryData_MdnsInfo(nullptr) {}
  ~TelemetryData_MdnsInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_MdnsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_MdnsInfo(const TelemetryData_MdnsInfo& from);
  TelemetryData_MdnsInfo(TelemetryData_MdnsInfo&& from) noexcept
    : TelemetryData_MdnsInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_MdnsInfo& operator=(const TelemetryData_MdnsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_MdnsInfo& operator=(TelemetryData_MdnsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_MdnsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_MdnsInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_MdnsInfo*>(
               &_TelemetryData_MdnsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TelemetryData_MdnsInfo& a, TelemetryData_MdnsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_MdnsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_MdnsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_MdnsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_MdnsInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_MdnsInfo& from);
  void MergeFrom(const TelemetryData_MdnsInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_MdnsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.MdnsInfo";
  }
  protected:
  explicit TelemetryData_MdnsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostRegistrationResponsesFieldNumber = 1,
    kServiceRegistrationResponsesFieldNumber = 2,
    kHostResolutionResponsesFieldNumber = 3,
    kServiceResolutionResponsesFieldNumber = 4,
    kHostRegistrationEmaLatencyMsFieldNumber = 5,
    kServiceRegistrationEmaLatencyMsFieldNumber = 6,
    kHostResolutionEmaLatencyMsFieldNumber = 7,
    kServiceResolutionEmaLatencyMsFieldNumber = 8,
  };
  // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_registration_responses = 1;
  bool has_host_registration_responses() const;
  private:
  bool _internal_has_host_registration_responses() const;
  public:
  void clear_host_registration_responses();
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& host_registration_responses() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_MdnsResponseCounters* release_host_registration_responses();
  ::threadnetwork::TelemetryData_MdnsResponseCounters* mutable_host_registration_responses();
  void set_allocated_host_registration_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* host_registration_responses);
  private:
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& _internal_host_registration_responses() const;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _internal_mutable_host_registration_responses();
  public:
  void unsafe_arena_set_allocated_host_registration_responses(
      ::threadnetwork::TelemetryData_MdnsResponseCounters* host_registration_responses);
  ::threadnetwork::TelemetryData_MdnsResponseCounters* unsafe_arena_release_host_registration_responses();

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_registration_responses = 2;
  bool has_service_registration_responses() const;
  private:
  bool _internal_has_service_registration_responses() const;
  public:
  void clear_service_registration_responses();
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& service_registration_responses() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_MdnsResponseCounters* release_service_registration_responses();
  ::threadnetwork::TelemetryData_MdnsResponseCounters* mutable_service_registration_responses();
  void set_allocated_service_registration_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* service_registration_responses);
  private:
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& _internal_service_registration_responses() const;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _internal_mutable_service_registration_responses();
  public:
  void unsafe_arena_set_allocated_service_registration_responses(
      ::threadnetwork::TelemetryData_MdnsResponseCounters* service_registration_responses);
  ::threadnetwork::TelemetryData_MdnsResponseCounters* unsafe_arena_release_service_registration_responses();

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters host_resolution_responses = 3;
  bool has_host_resolution_responses() const;
  private:
  bool _internal_has_host_resolution_responses() const;
  public:
  void clear_host_resolution_responses();
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& host_resolution_responses() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_MdnsResponseCounters* release_host_resolution_responses();
  ::threadnetwork::TelemetryData_MdnsResponseCounters* mutable_host_resolution_responses();
  void set_allocated_host_resolution_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* host_resolution_responses);
  private:
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& _internal_host_resolution_responses() const;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _internal_mutable_host_resolution_responses();
  public:
  void unsafe_arena_set_allocated_host_resolution_responses(
      ::threadnetwork::TelemetryData_MdnsResponseCounters* host_resolution_responses);
  ::threadnetwork::TelemetryData_MdnsResponseCounters* unsafe_arena_release_host_resolution_responses();

  // optional .threadnetwork.TelemetryData.MdnsResponseCounters service_resolution_responses = 4;
  bool has_service_resolution_responses() const;
  private:
  bool _internal_has_service_resolution_responses() const;
  public:
  void clear_service_resolution_responses();
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& service_resolution_responses() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_MdnsResponseCounters* release_service_resolution_responses();
  ::threadnetwork::TelemetryData_MdnsResponseCounters* mutable_service_resolution_responses();
  void set_allocated_service_resolution_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* service_resolution_responses);
  private:
  const ::threadnetwork::TelemetryData_MdnsResponseCounters& _internal_service_resolution_responses() const;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _internal_mutable_service_resolution_responses();
  public:
  void unsafe_arena_set_allocated_service_resolution_responses(
      ::threadnetwork::TelemetryData_MdnsResponseCounters* service_resolution_responses);
  ::threadnetwork::TelemetryData_MdnsResponseCounters* unsafe_arena_release_service_resolution_responses();

  // optional uint32 host_registration_ema_latency_ms = 5;
  bool has_host_registration_ema_latency_ms() const;
  private:
  bool _internal_has_host_registration_ema_latency_ms() const;
  public:
  void clear_host_registration_ema_latency_ms();
  uint32_t host_registration_ema_latency_ms() const;
  void set_host_registration_ema_latency_ms(uint32_t value);
  private:
  uint32_t _internal_host_registration_ema_latency_ms() const;
  void _internal_set_host_registration_ema_latency_ms(uint32_t value);
  public:

  // optional uint32 service_registration_ema_latency_ms = 6;
  bool has_service_registration_ema_latency_ms() const;
  private:
  bool _internal_has_service_registration_ema_latency_ms() const;
  public:
  void clear_service_registration_ema_latency_ms();
  uint32_t service_registration_ema_latency_ms() const;
  void set_service_registration_ema_latency_ms(uint32_t value);
  private:
  uint32_t _internal_service_registration_ema_latency_ms() const;
  void _internal_set_service_registration_ema_latency_ms(uint32_t value);
  public:

  // optional uint32 host_resolution_ema_latency_ms = 7;
  bool has_host_resolution_ema_latency_ms() const;
  private:
  bool _internal_has_host_resolution_ema_latency_ms() const;
  public:
  void clear_host_resolution_ema_latency_ms();
  uint32_t host_resolution_ema_latency_ms() const;
  void set_host_resolution_ema_latency_ms(uint32_t value);
  private:
  uint32_t _internal_host_resolution_ema_latency_ms() const;
  void _internal_set_host_resolution_ema_latency_ms(uint32_t value);
  public:

  // optional uint32 service_resolution_ema_latency_ms = 8;
  bool has_service_resolution_ema_latency_ms() const;
  private:
  bool _internal_has_service_resolution_ema_latency_ms() const;
  public:
  void clear_service_resolution_ema_latency_ms();
  uint32_t service_resolution_ema_latency_ms() const;
  void set_service_resolution_ema_latency_ms(uint32_t value);
  private:
  uint32_t _internal_service_resolution_ema_latency_ms() const;
  void _internal_set_service_resolution_ema_latency_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.MdnsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_MdnsResponseCounters* host_registration_responses_;
    ::threadnetwork::TelemetryData_MdnsResponseCounters* service_registration_responses_;
    ::threadnetwork::TelemetryData_MdnsResponseCounters* host_resolution_responses_;
    ::threadnetwork::TelemetryData_MdnsResponseCounters* service_resolution_responses_;
    uint32_t host_registration_ema_latency_ms_;
    uint32_t service_registration_ema_latency_ms_;
    uint32_t host_resolution_ema_latency_ms_;
    uint32_t service_resolution_ema_latency_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_BorderRoutingNat64State final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.BorderRoutingNat64State) */ {
 public:
  inline TelemetryData_BorderRoutingNat64State() : TelemetryData_BorderRoutingNat64State(nullptr) {}
  ~TelemetryData_BorderRoutingNat64State() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_BorderRoutingNat64State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_BorderRoutingNat64State(const TelemetryData_BorderRoutingNat64State& from);
  TelemetryData_BorderRoutingNat64State(TelemetryData_BorderRoutingNat64State&& from) noexcept
    : TelemetryData_BorderRoutingNat64State() {
    *this = ::std::move(from);
  }

  inline TelemetryData_BorderRoutingNat64State& operator=(const TelemetryData_BorderRoutingNat64State& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_BorderRoutingNat64State& operator=(TelemetryData_BorderRoutingNat64State&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_BorderRoutingNat64State& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_BorderRoutingNat64State* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_BorderRoutingNat64State*>(
               &_TelemetryData_BorderRoutingNat64State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TelemetryData_BorderRoutingNat64State& a, TelemetryData_BorderRoutingNat64State& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_BorderRoutingNat64State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_BorderRoutingNat64State* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_BorderRoutingNat64State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_BorderRoutingNat64State>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_BorderRoutingNat64State& from);
  void MergeFrom(const TelemetryData_BorderRoutingNat64State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_BorderRoutingNat64State* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.BorderRoutingNat64State";
  }
  protected:
  explicit TelemetryData_BorderRoutingNat64State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixManagerStateFieldNumber = 1,
    kTranslatorStateFieldNumber = 2,
  };
  // optional .threadnetwork.TelemetryData.Nat64State prefix_manager_state = 1;
  bool has_prefix_manager_state() const;
  private:
  bool _internal_has_prefix_manager_state() const;
  public:
  void clear_prefix_manager_state();
  ::threadnetwork::TelemetryData_Nat64State prefix_manager_state() const;
  void set_prefix_manager_state(::threadnetwork::TelemetryData_Nat64State value);
  private:
  ::threadnetwork::TelemetryData_Nat64State _internal_prefix_manager_state() const;
  void _internal_set_prefix_manager_state(::threadnetwork::TelemetryData_Nat64State value);
  public:

  // optional .threadnetwork.TelemetryData.Nat64State translator_state = 2;
  bool has_translator_state() const;
  private:
  bool _internal_has_translator_state() const;
  public:
  void clear_translator_state();
  ::threadnetwork::TelemetryData_Nat64State translator_state() const;
  void set_translator_state(::threadnetwork::TelemetryData_Nat64State value);
  private:
  ::threadnetwork::TelemetryData_Nat64State _internal_translator_state() const;
  void _internal_set_translator_state(::threadnetwork::TelemetryData_Nat64State value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.BorderRoutingNat64State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int prefix_manager_state_;
    int translator_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_Nat64Mapping final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.Nat64Mapping) */ {
 public:
  inline TelemetryData_Nat64Mapping() : TelemetryData_Nat64Mapping(nullptr) {}
  ~TelemetryData_Nat64Mapping() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_Nat64Mapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_Nat64Mapping(const TelemetryData_Nat64Mapping& from);
  TelemetryData_Nat64Mapping(TelemetryData_Nat64Mapping&& from) noexcept
    : TelemetryData_Nat64Mapping() {
    *this = ::std::move(from);
  }

  inline TelemetryData_Nat64Mapping& operator=(const TelemetryData_Nat64Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_Nat64Mapping& operator=(TelemetryData_Nat64Mapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_Nat64Mapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_Nat64Mapping* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_Nat64Mapping*>(
               &_TelemetryData_Nat64Mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TelemetryData_Nat64Mapping& a, TelemetryData_Nat64Mapping& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_Nat64Mapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_Nat64Mapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_Nat64Mapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_Nat64Mapping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_Nat64Mapping& from);
  void MergeFrom(const TelemetryData_Nat64Mapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_Nat64Mapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.Nat64Mapping";
  }
  protected:
  explicit TelemetryData_Nat64Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashedIpv6AddressFieldNumber = 2,
    kCountersFieldNumber = 3,
    kMappingIdFieldNumber = 1,
  };
  // optional bytes hashed_ipv6_address = 2;
  bool has_hashed_ipv6_address() const;
  private:
  bool _internal_has_hashed_ipv6_address() const;
  public:
  void clear_hashed_ipv6_address();
  const std::string& hashed_ipv6_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashed_ipv6_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashed_ipv6_address();
  PROTOBUF_NODISCARD std::string* release_hashed_ipv6_address();
  void set_allocated_hashed_ipv6_address(std::string* hashed_ipv6_address);
  private:
  const std::string& _internal_hashed_ipv6_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed_ipv6_address(const std::string& value);
  std::string* _internal_mutable_hashed_ipv6_address();
  public:

  // optional .threadnetwork.TelemetryData.Nat64ProtocolCounters counters = 3;
  bool has_counters() const;
  private:
  bool _internal_has_counters() const;
  public:
  void clear_counters();
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_Nat64ProtocolCounters* release_counters();
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* mutable_counters();
  void set_allocated_counters(::threadnetwork::TelemetryData_Nat64ProtocolCounters* counters);
  private:
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& _internal_counters() const;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* _internal_mutable_counters();
  public:
  void unsafe_arena_set_allocated_counters(
      ::threadnetwork::TelemetryData_Nat64ProtocolCounters* counters);
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* unsafe_arena_release_counters();

  // optional uint64 mapping_id = 1;
  bool has_mapping_id() const;
  private:
  bool _internal_has_mapping_id() const;
  public:
  void clear_mapping_id();
  uint64_t mapping_id() const;
  void set_mapping_id(uint64_t value);
  private:
  uint64_t _internal_mapping_id() const;
  void _internal_set_mapping_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.Nat64Mapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_ipv6_address_;
    ::threadnetwork::TelemetryData_Nat64ProtocolCounters* counters_;
    uint64_t mapping_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_InfraLinkInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.InfraLinkInfo) */ {
 public:
  inline TelemetryData_InfraLinkInfo() : TelemetryData_InfraLinkInfo(nullptr) {}
  ~TelemetryData_InfraLinkInfo() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_InfraLinkInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_InfraLinkInfo(const TelemetryData_InfraLinkInfo& from);
  TelemetryData_InfraLinkInfo(TelemetryData_InfraLinkInfo&& from) noexcept
    : TelemetryData_InfraLinkInfo() {
    *this = ::std::move(from);
  }

  inline TelemetryData_InfraLinkInfo& operator=(const TelemetryData_InfraLinkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_InfraLinkInfo& operator=(TelemetryData_InfraLinkInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_InfraLinkInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_InfraLinkInfo* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_InfraLinkInfo*>(
               &_TelemetryData_InfraLinkInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TelemetryData_InfraLinkInfo& a, TelemetryData_InfraLinkInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_InfraLinkInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_InfraLinkInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_InfraLinkInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_InfraLinkInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_InfraLinkInfo& from);
  void MergeFrom(const TelemetryData_InfraLinkInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_InfraLinkInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.InfraLinkInfo";
  }
  protected:
  explicit TelemetryData_InfraLinkInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIsUpFieldNumber = 2,
    kIsRunningFieldNumber = 3,
    kIsMulticastFieldNumber = 4,
    kLinkLocalAddressCountFieldNumber = 5,
    kUniqueLocalAddressCountFieldNumber = 6,
    kGlobalUnicastAddressCountFieldNumber = 7,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool is_up = 2;
  bool has_is_up() const;
  private:
  bool _internal_has_is_up() const;
  public:
  void clear_is_up();
  bool is_up() const;
  void set_is_up(bool value);
  private:
  bool _internal_is_up() const;
  void _internal_set_is_up(bool value);
  public:

  // optional bool is_running = 3;
  bool has_is_running() const;
  private:
  bool _internal_has_is_running() const;
  public:
  void clear_is_running();
  bool is_running() const;
  void set_is_running(bool value);
  private:
  bool _internal_is_running() const;
  void _internal_set_is_running(bool value);
  public:

  // optional bool is_multicast = 4;
  bool has_is_multicast() const;
  private:
  bool _internal_has_is_multicast() const;
  public:
  void clear_is_multicast();
  bool is_multicast() const;
  void set_is_multicast(bool value);
  private:
  bool _internal_is_multicast() const;
  void _internal_set_is_multicast(bool value);
  public:

  // optional uint32 link_local_address_count = 5;
  bool has_link_local_address_count() const;
  private:
  bool _internal_has_link_local_address_count() const;
  public:
  void clear_link_local_address_count();
  uint32_t link_local_address_count() const;
  void set_link_local_address_count(uint32_t value);
  private:
  uint32_t _internal_link_local_address_count() const;
  void _internal_set_link_local_address_count(uint32_t value);
  public:

  // optional uint32 unique_local_address_count = 6;
  bool has_unique_local_address_count() const;
  private:
  bool _internal_has_unique_local_address_count() const;
  public:
  void clear_unique_local_address_count();
  uint32_t unique_local_address_count() const;
  void set_unique_local_address_count(uint32_t value);
  private:
  uint32_t _internal_unique_local_address_count() const;
  void _internal_set_unique_local_address_count(uint32_t value);
  public:

  // optional uint32 global_unicast_address_count = 7;
  bool has_global_unicast_address_count() const;
  private:
  bool _internal_has_global_unicast_address_count() const;
  public:
  void clear_global_unicast_address_count();
  uint32_t global_unicast_address_count() const;
  void set_global_unicast_address_count(uint32_t value);
  private:
  uint32_t _internal_global_unicast_address_count() const;
  void _internal_set_global_unicast_address_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.InfraLinkInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool is_up_;
    bool is_running_;
    bool is_multicast_;
    uint32_t link_local_address_count_;
    uint32_t unique_local_address_count_;
    uint32_t global_unicast_address_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_WpanBorderRouter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.WpanBorderRouter) */ {
 public:
  inline TelemetryData_WpanBorderRouter() : TelemetryData_WpanBorderRouter(nullptr) {}
  ~TelemetryData_WpanBorderRouter() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_WpanBorderRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_WpanBorderRouter(const TelemetryData_WpanBorderRouter& from);
  TelemetryData_WpanBorderRouter(TelemetryData_WpanBorderRouter&& from) noexcept
    : TelemetryData_WpanBorderRouter() {
    *this = ::std::move(from);
  }

  inline TelemetryData_WpanBorderRouter& operator=(const TelemetryData_WpanBorderRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_WpanBorderRouter& operator=(TelemetryData_WpanBorderRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_WpanBorderRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_WpanBorderRouter* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_WpanBorderRouter*>(
               &_TelemetryData_WpanBorderRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TelemetryData_WpanBorderRouter& a, TelemetryData_WpanBorderRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_WpanBorderRouter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_WpanBorderRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_WpanBorderRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_WpanBorderRouter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_WpanBorderRouter& from);
  void MergeFrom(const TelemetryData_WpanBorderRouter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_WpanBorderRouter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.WpanBorderRouter";
  }
  protected:
  explicit TelemetryData_WpanBorderRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNat64MappingsFieldNumber = 7,
    kHashedPdPrefixFieldNumber = 9,
    kBorderRoutingCountersFieldNumber = 1,
    kSrpServerFieldNumber = 2,
    kDnsServerFieldNumber = 3,
    kMdnsFieldNumber = 4,
    kNat64StateFieldNumber = 6,
    kPdProcessedRaInfoFieldNumber = 10,
    kTrelInfoFieldNumber = 11,
    kInfraLinkInfoFieldNumber = 12,
    kDhcp6PdStateFieldNumber = 8,
  };
  // repeated .threadnetwork.TelemetryData.Nat64Mapping nat64_mappings = 7;
  int nat64_mappings_size() const;
  private:
  int _internal_nat64_mappings_size() const;
  public:
  void clear_nat64_mappings();
  ::threadnetwork::TelemetryData_Nat64Mapping* mutable_nat64_mappings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_Nat64Mapping >*
      mutable_nat64_mappings();
  private:
  const ::threadnetwork::TelemetryData_Nat64Mapping& _internal_nat64_mappings(int index) const;
  ::threadnetwork::TelemetryData_Nat64Mapping* _internal_add_nat64_mappings();
  public:
  const ::threadnetwork::TelemetryData_Nat64Mapping& nat64_mappings(int index) const;
  ::threadnetwork::TelemetryData_Nat64Mapping* add_nat64_mappings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_Nat64Mapping >&
      nat64_mappings() const;

  // optional bytes hashed_pd_prefix = 9;
  bool has_hashed_pd_prefix() const;
  private:
  bool _internal_has_hashed_pd_prefix() const;
  public:
  void clear_hashed_pd_prefix();
  const std::string& hashed_pd_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashed_pd_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashed_pd_prefix();
  PROTOBUF_NODISCARD std::string* release_hashed_pd_prefix();
  void set_allocated_hashed_pd_prefix(std::string* hashed_pd_prefix);
  private:
  const std::string& _internal_hashed_pd_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed_pd_prefix(const std::string& value);
  std::string* _internal_mutable_hashed_pd_prefix();
  public:

  // optional .threadnetwork.TelemetryData.BorderRoutingCounters border_routing_counters = 1;
  bool has_border_routing_counters() const;
  private:
  bool _internal_has_border_routing_counters() const;
  public:
  void clear_border_routing_counters();
  const ::threadnetwork::TelemetryData_BorderRoutingCounters& border_routing_counters() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_BorderRoutingCounters* release_border_routing_counters();
  ::threadnetwork::TelemetryData_BorderRoutingCounters* mutable_border_routing_counters();
  void set_allocated_border_routing_counters(::threadnetwork::TelemetryData_BorderRoutingCounters* border_routing_counters);
  private:
  const ::threadnetwork::TelemetryData_BorderRoutingCounters& _internal_border_routing_counters() const;
  ::threadnetwork::TelemetryData_BorderRoutingCounters* _internal_mutable_border_routing_counters();
  public:
  void unsafe_arena_set_allocated_border_routing_counters(
      ::threadnetwork::TelemetryData_BorderRoutingCounters* border_routing_counters);
  ::threadnetwork::TelemetryData_BorderRoutingCounters* unsafe_arena_release_border_routing_counters();

  // optional .threadnetwork.TelemetryData.SrpServerInfo srp_server = 2;
  bool has_srp_server() const;
  private:
  bool _internal_has_srp_server() const;
  public:
  void clear_srp_server();
  const ::threadnetwork::TelemetryData_SrpServerInfo& srp_server() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_SrpServerInfo* release_srp_server();
  ::threadnetwork::TelemetryData_SrpServerInfo* mutable_srp_server();
  void set_allocated_srp_server(::threadnetwork::TelemetryData_SrpServerInfo* srp_server);
  private:
  const ::threadnetwork::TelemetryData_SrpServerInfo& _internal_srp_server() const;
  ::threadnetwork::TelemetryData_SrpServerInfo* _internal_mutable_srp_server();
  public:
  void unsafe_arena_set_allocated_srp_server(
      ::threadnetwork::TelemetryData_SrpServerInfo* srp_server);
  ::threadnetwork::TelemetryData_SrpServerInfo* unsafe_arena_release_srp_server();

  // optional .threadnetwork.TelemetryData.DnsServerInfo dns_server = 3;
  bool has_dns_server() const;
  private:
  bool _internal_has_dns_server() const;
  public:
  void clear_dns_server();
  const ::threadnetwork::TelemetryData_DnsServerInfo& dns_server() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_DnsServerInfo* release_dns_server();
  ::threadnetwork::TelemetryData_DnsServerInfo* mutable_dns_server();
  void set_allocated_dns_server(::threadnetwork::TelemetryData_DnsServerInfo* dns_server);
  private:
  const ::threadnetwork::TelemetryData_DnsServerInfo& _internal_dns_server() const;
  ::threadnetwork::TelemetryData_DnsServerInfo* _internal_mutable_dns_server();
  public:
  void unsafe_arena_set_allocated_dns_server(
      ::threadnetwork::TelemetryData_DnsServerInfo* dns_server);
  ::threadnetwork::TelemetryData_DnsServerInfo* unsafe_arena_release_dns_server();

  // optional .threadnetwork.TelemetryData.MdnsInfo mdns = 4;
  bool has_mdns() const;
  private:
  bool _internal_has_mdns() const;
  public:
  void clear_mdns();
  const ::threadnetwork::TelemetryData_MdnsInfo& mdns() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_MdnsInfo* release_mdns();
  ::threadnetwork::TelemetryData_MdnsInfo* mutable_mdns();
  void set_allocated_mdns(::threadnetwork::TelemetryData_MdnsInfo* mdns);
  private:
  const ::threadnetwork::TelemetryData_MdnsInfo& _internal_mdns() const;
  ::threadnetwork::TelemetryData_MdnsInfo* _internal_mutable_mdns();
  public:
  void unsafe_arena_set_allocated_mdns(
      ::threadnetwork::TelemetryData_MdnsInfo* mdns);
  ::threadnetwork::TelemetryData_MdnsInfo* unsafe_arena_release_mdns();

  // optional .threadnetwork.TelemetryData.BorderRoutingNat64State nat64_state = 6;
  bool has_nat64_state() const;
  private:
  bool _internal_has_nat64_state() const;
  public:
  void clear_nat64_state();
  const ::threadnetwork::TelemetryData_BorderRoutingNat64State& nat64_state() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_BorderRoutingNat64State* release_nat64_state();
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* mutable_nat64_state();
  void set_allocated_nat64_state(::threadnetwork::TelemetryData_BorderRoutingNat64State* nat64_state);
  private:
  const ::threadnetwork::TelemetryData_BorderRoutingNat64State& _internal_nat64_state() const;
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* _internal_mutable_nat64_state();
  public:
  void unsafe_arena_set_allocated_nat64_state(
      ::threadnetwork::TelemetryData_BorderRoutingNat64State* nat64_state);
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* unsafe_arena_release_nat64_state();

  // optional .threadnetwork.TelemetryData.PdProcessedRaInfo pd_processed_ra_info = 10;
  bool has_pd_processed_ra_info() const;
  private:
  bool _internal_has_pd_processed_ra_info() const;
  public:
  void clear_pd_processed_ra_info();
  const ::threadnetwork::TelemetryData_PdProcessedRaInfo& pd_processed_ra_info() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_PdProcessedRaInfo* release_pd_processed_ra_info();
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* mutable_pd_processed_ra_info();
  void set_allocated_pd_processed_ra_info(::threadnetwork::TelemetryData_PdProcessedRaInfo* pd_processed_ra_info);
  private:
  const ::threadnetwork::TelemetryData_PdProcessedRaInfo& _internal_pd_processed_ra_info() const;
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* _internal_mutable_pd_processed_ra_info();
  public:
  void unsafe_arena_set_allocated_pd_processed_ra_info(
      ::threadnetwork::TelemetryData_PdProcessedRaInfo* pd_processed_ra_info);
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* unsafe_arena_release_pd_processed_ra_info();

  // optional .threadnetwork.TelemetryData.TrelInfo trel_info = 11;
  bool has_trel_info() const;
  private:
  bool _internal_has_trel_info() const;
  public:
  void clear_trel_info();
  const ::threadnetwork::TelemetryData_TrelInfo& trel_info() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_TrelInfo* release_trel_info();
  ::threadnetwork::TelemetryData_TrelInfo* mutable_trel_info();
  void set_allocated_trel_info(::threadnetwork::TelemetryData_TrelInfo* trel_info);
  private:
  const ::threadnetwork::TelemetryData_TrelInfo& _internal_trel_info() const;
  ::threadnetwork::TelemetryData_TrelInfo* _internal_mutable_trel_info();
  public:
  void unsafe_arena_set_allocated_trel_info(
      ::threadnetwork::TelemetryData_TrelInfo* trel_info);
  ::threadnetwork::TelemetryData_TrelInfo* unsafe_arena_release_trel_info();

  // optional .threadnetwork.TelemetryData.InfraLinkInfo infra_link_info = 12;
  bool has_infra_link_info() const;
  private:
  bool _internal_has_infra_link_info() const;
  public:
  void clear_infra_link_info();
  const ::threadnetwork::TelemetryData_InfraLinkInfo& infra_link_info() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_InfraLinkInfo* release_infra_link_info();
  ::threadnetwork::TelemetryData_InfraLinkInfo* mutable_infra_link_info();
  void set_allocated_infra_link_info(::threadnetwork::TelemetryData_InfraLinkInfo* infra_link_info);
  private:
  const ::threadnetwork::TelemetryData_InfraLinkInfo& _internal_infra_link_info() const;
  ::threadnetwork::TelemetryData_InfraLinkInfo* _internal_mutable_infra_link_info();
  public:
  void unsafe_arena_set_allocated_infra_link_info(
      ::threadnetwork::TelemetryData_InfraLinkInfo* infra_link_info);
  ::threadnetwork::TelemetryData_InfraLinkInfo* unsafe_arena_release_infra_link_info();

  // optional .threadnetwork.TelemetryData.Dhcp6PdState dhcp6_pd_state = 8;
  bool has_dhcp6_pd_state() const;
  private:
  bool _internal_has_dhcp6_pd_state() const;
  public:
  void clear_dhcp6_pd_state();
  ::threadnetwork::TelemetryData_Dhcp6PdState dhcp6_pd_state() const;
  void set_dhcp6_pd_state(::threadnetwork::TelemetryData_Dhcp6PdState value);
  private:
  ::threadnetwork::TelemetryData_Dhcp6PdState _internal_dhcp6_pd_state() const;
  void _internal_set_dhcp6_pd_state(::threadnetwork::TelemetryData_Dhcp6PdState value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.WpanBorderRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_Nat64Mapping > nat64_mappings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_pd_prefix_;
    ::threadnetwork::TelemetryData_BorderRoutingCounters* border_routing_counters_;
    ::threadnetwork::TelemetryData_SrpServerInfo* srp_server_;
    ::threadnetwork::TelemetryData_DnsServerInfo* dns_server_;
    ::threadnetwork::TelemetryData_MdnsInfo* mdns_;
    ::threadnetwork::TelemetryData_BorderRoutingNat64State* nat64_state_;
    ::threadnetwork::TelemetryData_PdProcessedRaInfo* pd_processed_ra_info_;
    ::threadnetwork::TelemetryData_TrelInfo* trel_info_;
    ::threadnetwork::TelemetryData_InfraLinkInfo* infra_link_info_;
    int dhcp6_pd_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_RcpStabilityStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.RcpStabilityStatistics) */ {
 public:
  inline TelemetryData_RcpStabilityStatistics() : TelemetryData_RcpStabilityStatistics(nullptr) {}
  ~TelemetryData_RcpStabilityStatistics() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_RcpStabilityStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_RcpStabilityStatistics(const TelemetryData_RcpStabilityStatistics& from);
  TelemetryData_RcpStabilityStatistics(TelemetryData_RcpStabilityStatistics&& from) noexcept
    : TelemetryData_RcpStabilityStatistics() {
    *this = ::std::move(from);
  }

  inline TelemetryData_RcpStabilityStatistics& operator=(const TelemetryData_RcpStabilityStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_RcpStabilityStatistics& operator=(TelemetryData_RcpStabilityStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_RcpStabilityStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_RcpStabilityStatistics* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_RcpStabilityStatistics*>(
               &_TelemetryData_RcpStabilityStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TelemetryData_RcpStabilityStatistics& a, TelemetryData_RcpStabilityStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_RcpStabilityStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_RcpStabilityStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_RcpStabilityStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_RcpStabilityStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_RcpStabilityStatistics& from);
  void MergeFrom(const TelemetryData_RcpStabilityStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_RcpStabilityStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.RcpStabilityStatistics";
  }
  protected:
  explicit TelemetryData_RcpStabilityStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRcpTimeoutCountFieldNumber = 1,
    kRcpResetCountFieldNumber = 2,
    kRcpRestorationCountFieldNumber = 3,
    kSpinelParseErrorCountFieldNumber = 4,
    kRcpFirmwareUpdateCountFieldNumber = 5,
    kThreadStackUptimeFieldNumber = 6,
  };
  // optional uint32 rcp_timeout_count = 1;
  bool has_rcp_timeout_count() const;
  private:
  bool _internal_has_rcp_timeout_count() const;
  public:
  void clear_rcp_timeout_count();
  uint32_t rcp_timeout_count() const;
  void set_rcp_timeout_count(uint32_t value);
  private:
  uint32_t _internal_rcp_timeout_count() const;
  void _internal_set_rcp_timeout_count(uint32_t value);
  public:

  // optional uint32 rcp_reset_count = 2;
  bool has_rcp_reset_count() const;
  private:
  bool _internal_has_rcp_reset_count() const;
  public:
  void clear_rcp_reset_count();
  uint32_t rcp_reset_count() const;
  void set_rcp_reset_count(uint32_t value);
  private:
  uint32_t _internal_rcp_reset_count() const;
  void _internal_set_rcp_reset_count(uint32_t value);
  public:

  // optional uint32 rcp_restoration_count = 3;
  bool has_rcp_restoration_count() const;
  private:
  bool _internal_has_rcp_restoration_count() const;
  public:
  void clear_rcp_restoration_count();
  uint32_t rcp_restoration_count() const;
  void set_rcp_restoration_count(uint32_t value);
  private:
  uint32_t _internal_rcp_restoration_count() const;
  void _internal_set_rcp_restoration_count(uint32_t value);
  public:

  // optional uint32 spinel_parse_error_count = 4;
  bool has_spinel_parse_error_count() const;
  private:
  bool _internal_has_spinel_parse_error_count() const;
  public:
  void clear_spinel_parse_error_count();
  uint32_t spinel_parse_error_count() const;
  void set_spinel_parse_error_count(uint32_t value);
  private:
  uint32_t _internal_spinel_parse_error_count() const;
  void _internal_set_spinel_parse_error_count(uint32_t value);
  public:

  // optional int32 rcp_firmware_update_count = 5;
  bool has_rcp_firmware_update_count() const;
  private:
  bool _internal_has_rcp_firmware_update_count() const;
  public:
  void clear_rcp_firmware_update_count();
  int32_t rcp_firmware_update_count() const;
  void set_rcp_firmware_update_count(int32_t value);
  private:
  int32_t _internal_rcp_firmware_update_count() const;
  void _internal_set_rcp_firmware_update_count(int32_t value);
  public:

  // optional uint32 thread_stack_uptime = 6;
  bool has_thread_stack_uptime() const;
  private:
  bool _internal_has_thread_stack_uptime() const;
  public:
  void clear_thread_stack_uptime();
  uint32_t thread_stack_uptime() const;
  void set_thread_stack_uptime(uint32_t value);
  private:
  uint32_t _internal_thread_stack_uptime() const;
  void _internal_set_thread_stack_uptime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.RcpStabilityStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t rcp_timeout_count_;
    uint32_t rcp_reset_count_;
    uint32_t rcp_restoration_count_;
    uint32_t spinel_parse_error_count_;
    int32_t rcp_firmware_update_count_;
    uint32_t thread_stack_uptime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_RcpInterfaceStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.RcpInterfaceStatistics) */ {
 public:
  inline TelemetryData_RcpInterfaceStatistics() : TelemetryData_RcpInterfaceStatistics(nullptr) {}
  ~TelemetryData_RcpInterfaceStatistics() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_RcpInterfaceStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_RcpInterfaceStatistics(const TelemetryData_RcpInterfaceStatistics& from);
  TelemetryData_RcpInterfaceStatistics(TelemetryData_RcpInterfaceStatistics&& from) noexcept
    : TelemetryData_RcpInterfaceStatistics() {
    *this = ::std::move(from);
  }

  inline TelemetryData_RcpInterfaceStatistics& operator=(const TelemetryData_RcpInterfaceStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_RcpInterfaceStatistics& operator=(TelemetryData_RcpInterfaceStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_RcpInterfaceStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_RcpInterfaceStatistics* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_RcpInterfaceStatistics*>(
               &_TelemetryData_RcpInterfaceStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TelemetryData_RcpInterfaceStatistics& a, TelemetryData_RcpInterfaceStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_RcpInterfaceStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_RcpInterfaceStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_RcpInterfaceStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_RcpInterfaceStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_RcpInterfaceStatistics& from);
  void MergeFrom(const TelemetryData_RcpInterfaceStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_RcpInterfaceStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.RcpInterfaceStatistics";
  }
  protected:
  explicit TelemetryData_RcpInterfaceStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransferredFramesCountFieldNumber = 2,
    kTransferredValidFramesCountFieldNumber = 3,
    kTransferredGarbageFramesCountFieldNumber = 4,
    kRxFramesCountFieldNumber = 5,
    kRxBytesCountFieldNumber = 6,
    kTxFramesCountFieldNumber = 7,
    kTxBytesCountFieldNumber = 8,
    kRcpInterfaceTypeFieldNumber = 1,
  };
  // optional uint64 transferred_frames_count = 2;
  bool has_transferred_frames_count() const;
  private:
  bool _internal_has_transferred_frames_count() const;
  public:
  void clear_transferred_frames_count();
  uint64_t transferred_frames_count() const;
  void set_transferred_frames_count(uint64_t value);
  private:
  uint64_t _internal_transferred_frames_count() const;
  void _internal_set_transferred_frames_count(uint64_t value);
  public:

  // optional uint64 transferred_valid_frames_count = 3;
  bool has_transferred_valid_frames_count() const;
  private:
  bool _internal_has_transferred_valid_frames_count() const;
  public:
  void clear_transferred_valid_frames_count();
  uint64_t transferred_valid_frames_count() const;
  void set_transferred_valid_frames_count(uint64_t value);
  private:
  uint64_t _internal_transferred_valid_frames_count() const;
  void _internal_set_transferred_valid_frames_count(uint64_t value);
  public:

  // optional uint64 transferred_garbage_frames_count = 4;
  bool has_transferred_garbage_frames_count() const;
  private:
  bool _internal_has_transferred_garbage_frames_count() const;
  public:
  void clear_transferred_garbage_frames_count();
  uint64_t transferred_garbage_frames_count() const;
  void set_transferred_garbage_frames_count(uint64_t value);
  private:
  uint64_t _internal_transferred_garbage_frames_count() const;
  void _internal_set_transferred_garbage_frames_count(uint64_t value);
  public:

  // optional uint64 rx_frames_count = 5;
  bool has_rx_frames_count() const;
  private:
  bool _internal_has_rx_frames_count() const;
  public:
  void clear_rx_frames_count();
  uint64_t rx_frames_count() const;
  void set_rx_frames_count(uint64_t value);
  private:
  uint64_t _internal_rx_frames_count() const;
  void _internal_set_rx_frames_count(uint64_t value);
  public:

  // optional uint64 rx_bytes_count = 6;
  bool has_rx_bytes_count() const;
  private:
  bool _internal_has_rx_bytes_count() const;
  public:
  void clear_rx_bytes_count();
  uint64_t rx_bytes_count() const;
  void set_rx_bytes_count(uint64_t value);
  private:
  uint64_t _internal_rx_bytes_count() const;
  void _internal_set_rx_bytes_count(uint64_t value);
  public:

  // optional uint64 tx_frames_count = 7;
  bool has_tx_frames_count() const;
  private:
  bool _internal_has_tx_frames_count() const;
  public:
  void clear_tx_frames_count();
  uint64_t tx_frames_count() const;
  void set_tx_frames_count(uint64_t value);
  private:
  uint64_t _internal_tx_frames_count() const;
  void _internal_set_tx_frames_count(uint64_t value);
  public:

  // optional uint64 tx_bytes_count = 8;
  bool has_tx_bytes_count() const;
  private:
  bool _internal_has_tx_bytes_count() const;
  public:
  void clear_tx_bytes_count();
  uint64_t tx_bytes_count() const;
  void set_tx_bytes_count(uint64_t value);
  private:
  uint64_t _internal_tx_bytes_count() const;
  void _internal_set_tx_bytes_count(uint64_t value);
  public:

  // optional uint32 rcp_interface_type = 1;
  bool has_rcp_interface_type() const;
  private:
  bool _internal_has_rcp_interface_type() const;
  public:
  void clear_rcp_interface_type();
  uint32_t rcp_interface_type() const;
  void set_rcp_interface_type(uint32_t value);
  private:
  uint32_t _internal_rcp_interface_type() const;
  void _internal_set_rcp_interface_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.RcpInterfaceStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t transferred_frames_count_;
    uint64_t transferred_valid_frames_count_;
    uint64_t transferred_garbage_frames_count_;
    uint64_t rx_frames_count_;
    uint64_t rx_bytes_count_;
    uint64_t tx_frames_count_;
    uint64_t tx_bytes_count_;
    uint32_t rcp_interface_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_WpanRcp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.WpanRcp) */ {
 public:
  inline TelemetryData_WpanRcp() : TelemetryData_WpanRcp(nullptr) {}
  ~TelemetryData_WpanRcp() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_WpanRcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_WpanRcp(const TelemetryData_WpanRcp& from);
  TelemetryData_WpanRcp(TelemetryData_WpanRcp&& from) noexcept
    : TelemetryData_WpanRcp() {
    *this = ::std::move(from);
  }

  inline TelemetryData_WpanRcp& operator=(const TelemetryData_WpanRcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_WpanRcp& operator=(TelemetryData_WpanRcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_WpanRcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_WpanRcp* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_WpanRcp*>(
               &_TelemetryData_WpanRcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TelemetryData_WpanRcp& a, TelemetryData_WpanRcp& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_WpanRcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_WpanRcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_WpanRcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_WpanRcp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_WpanRcp& from);
  void MergeFrom(const TelemetryData_WpanRcp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_WpanRcp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.WpanRcp";
  }
  protected:
  explicit TelemetryData_WpanRcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRcpStabilityStatisticsFieldNumber = 1,
    kRcpInterfaceStatisticsFieldNumber = 2,
  };
  // optional .threadnetwork.TelemetryData.RcpStabilityStatistics rcp_stability_statistics = 1;
  bool has_rcp_stability_statistics() const;
  private:
  bool _internal_has_rcp_stability_statistics() const;
  public:
  void clear_rcp_stability_statistics();
  const ::threadnetwork::TelemetryData_RcpStabilityStatistics& rcp_stability_statistics() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_RcpStabilityStatistics* release_rcp_stability_statistics();
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* mutable_rcp_stability_statistics();
  void set_allocated_rcp_stability_statistics(::threadnetwork::TelemetryData_RcpStabilityStatistics* rcp_stability_statistics);
  private:
  const ::threadnetwork::TelemetryData_RcpStabilityStatistics& _internal_rcp_stability_statistics() const;
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* _internal_mutable_rcp_stability_statistics();
  public:
  void unsafe_arena_set_allocated_rcp_stability_statistics(
      ::threadnetwork::TelemetryData_RcpStabilityStatistics* rcp_stability_statistics);
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* unsafe_arena_release_rcp_stability_statistics();

  // optional .threadnetwork.TelemetryData.RcpInterfaceStatistics rcp_interface_statistics = 2;
  bool has_rcp_interface_statistics() const;
  private:
  bool _internal_has_rcp_interface_statistics() const;
  public:
  void clear_rcp_interface_statistics();
  const ::threadnetwork::TelemetryData_RcpInterfaceStatistics& rcp_interface_statistics() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_RcpInterfaceStatistics* release_rcp_interface_statistics();
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* mutable_rcp_interface_statistics();
  void set_allocated_rcp_interface_statistics(::threadnetwork::TelemetryData_RcpInterfaceStatistics* rcp_interface_statistics);
  private:
  const ::threadnetwork::TelemetryData_RcpInterfaceStatistics& _internal_rcp_interface_statistics() const;
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* _internal_mutable_rcp_interface_statistics();
  public:
  void unsafe_arena_set_allocated_rcp_interface_statistics(
      ::threadnetwork::TelemetryData_RcpInterfaceStatistics* rcp_interface_statistics);
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* unsafe_arena_release_rcp_interface_statistics();

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.WpanRcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::threadnetwork::TelemetryData_RcpStabilityStatistics* rcp_stability_statistics_;
    ::threadnetwork::TelemetryData_RcpInterfaceStatistics* rcp_interface_statistics_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_CoexMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.CoexMetrics) */ {
 public:
  inline TelemetryData_CoexMetrics() : TelemetryData_CoexMetrics(nullptr) {}
  ~TelemetryData_CoexMetrics() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_CoexMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_CoexMetrics(const TelemetryData_CoexMetrics& from);
  TelemetryData_CoexMetrics(TelemetryData_CoexMetrics&& from) noexcept
    : TelemetryData_CoexMetrics() {
    *this = ::std::move(from);
  }

  inline TelemetryData_CoexMetrics& operator=(const TelemetryData_CoexMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_CoexMetrics& operator=(TelemetryData_CoexMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_CoexMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_CoexMetrics* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_CoexMetrics*>(
               &_TelemetryData_CoexMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TelemetryData_CoexMetrics& a, TelemetryData_CoexMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_CoexMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_CoexMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_CoexMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_CoexMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_CoexMetrics& from);
  void MergeFrom(const TelemetryData_CoexMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_CoexMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.CoexMetrics";
  }
  protected:
  explicit TelemetryData_CoexMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountTxRequestFieldNumber = 1,
    kCountTxGrantImmediateFieldNumber = 2,
    kCountTxGrantWaitFieldNumber = 3,
    kCountTxGrantWaitActivatedFieldNumber = 4,
    kCountTxGrantWaitTimeoutFieldNumber = 5,
    kCountTxGrantDeactivatedDuringRequestFieldNumber = 6,
    kTxAverageRequestToGrantTimeUsFieldNumber = 7,
    kCountRxRequestFieldNumber = 8,
    kCountRxGrantImmediateFieldNumber = 9,
    kCountRxGrantWaitFieldNumber = 10,
    kCountRxGrantWaitActivatedFieldNumber = 11,
    kCountRxGrantWaitTimeoutFieldNumber = 12,
    kCountRxGrantDeactivatedDuringRequestFieldNumber = 13,
    kCountRxGrantNoneFieldNumber = 14,
    kRxAverageRequestToGrantTimeUsFieldNumber = 15,
  };
  // optional uint32 count_tx_request = 1;
  bool has_count_tx_request() const;
  private:
  bool _internal_has_count_tx_request() const;
  public:
  void clear_count_tx_request();
  uint32_t count_tx_request() const;
  void set_count_tx_request(uint32_t value);
  private:
  uint32_t _internal_count_tx_request() const;
  void _internal_set_count_tx_request(uint32_t value);
  public:

  // optional uint32 count_tx_grant_immediate = 2;
  bool has_count_tx_grant_immediate() const;
  private:
  bool _internal_has_count_tx_grant_immediate() const;
  public:
  void clear_count_tx_grant_immediate();
  uint32_t count_tx_grant_immediate() const;
  void set_count_tx_grant_immediate(uint32_t value);
  private:
  uint32_t _internal_count_tx_grant_immediate() const;
  void _internal_set_count_tx_grant_immediate(uint32_t value);
  public:

  // optional uint32 count_tx_grant_wait = 3;
  bool has_count_tx_grant_wait() const;
  private:
  bool _internal_has_count_tx_grant_wait() const;
  public:
  void clear_count_tx_grant_wait();
  uint32_t count_tx_grant_wait() const;
  void set_count_tx_grant_wait(uint32_t value);
  private:
  uint32_t _internal_count_tx_grant_wait() const;
  void _internal_set_count_tx_grant_wait(uint32_t value);
  public:

  // optional uint32 count_tx_grant_wait_activated = 4;
  bool has_count_tx_grant_wait_activated() const;
  private:
  bool _internal_has_count_tx_grant_wait_activated() const;
  public:
  void clear_count_tx_grant_wait_activated();
  uint32_t count_tx_grant_wait_activated() const;
  void set_count_tx_grant_wait_activated(uint32_t value);
  private:
  uint32_t _internal_count_tx_grant_wait_activated() const;
  void _internal_set_count_tx_grant_wait_activated(uint32_t value);
  public:

  // optional uint32 count_tx_grant_wait_timeout = 5;
  bool has_count_tx_grant_wait_timeout() const;
  private:
  bool _internal_has_count_tx_grant_wait_timeout() const;
  public:
  void clear_count_tx_grant_wait_timeout();
  uint32_t count_tx_grant_wait_timeout() const;
  void set_count_tx_grant_wait_timeout(uint32_t value);
  private:
  uint32_t _internal_count_tx_grant_wait_timeout() const;
  void _internal_set_count_tx_grant_wait_timeout(uint32_t value);
  public:

  // optional uint32 count_tx_grant_deactivated_during_request = 6;
  bool has_count_tx_grant_deactivated_during_request() const;
  private:
  bool _internal_has_count_tx_grant_deactivated_during_request() const;
  public:
  void clear_count_tx_grant_deactivated_during_request();
  uint32_t count_tx_grant_deactivated_during_request() const;
  void set_count_tx_grant_deactivated_during_request(uint32_t value);
  private:
  uint32_t _internal_count_tx_grant_deactivated_during_request() const;
  void _internal_set_count_tx_grant_deactivated_during_request(uint32_t value);
  public:

  // optional uint32 tx_average_request_to_grant_time_us = 7;
  bool has_tx_average_request_to_grant_time_us() const;
  private:
  bool _internal_has_tx_average_request_to_grant_time_us() const;
  public:
  void clear_tx_average_request_to_grant_time_us();
  uint32_t tx_average_request_to_grant_time_us() const;
  void set_tx_average_request_to_grant_time_us(uint32_t value);
  private:
  uint32_t _internal_tx_average_request_to_grant_time_us() const;
  void _internal_set_tx_average_request_to_grant_time_us(uint32_t value);
  public:

  // optional uint32 count_rx_request = 8;
  bool has_count_rx_request() const;
  private:
  bool _internal_has_count_rx_request() const;
  public:
  void clear_count_rx_request();
  uint32_t count_rx_request() const;
  void set_count_rx_request(uint32_t value);
  private:
  uint32_t _internal_count_rx_request() const;
  void _internal_set_count_rx_request(uint32_t value);
  public:

  // optional uint32 count_rx_grant_immediate = 9;
  bool has_count_rx_grant_immediate() const;
  private:
  bool _internal_has_count_rx_grant_immediate() const;
  public:
  void clear_count_rx_grant_immediate();
  uint32_t count_rx_grant_immediate() const;
  void set_count_rx_grant_immediate(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_immediate() const;
  void _internal_set_count_rx_grant_immediate(uint32_t value);
  public:

  // optional uint32 count_rx_grant_wait = 10;
  bool has_count_rx_grant_wait() const;
  private:
  bool _internal_has_count_rx_grant_wait() const;
  public:
  void clear_count_rx_grant_wait();
  uint32_t count_rx_grant_wait() const;
  void set_count_rx_grant_wait(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_wait() const;
  void _internal_set_count_rx_grant_wait(uint32_t value);
  public:

  // optional uint32 count_rx_grant_wait_activated = 11;
  bool has_count_rx_grant_wait_activated() const;
  private:
  bool _internal_has_count_rx_grant_wait_activated() const;
  public:
  void clear_count_rx_grant_wait_activated();
  uint32_t count_rx_grant_wait_activated() const;
  void set_count_rx_grant_wait_activated(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_wait_activated() const;
  void _internal_set_count_rx_grant_wait_activated(uint32_t value);
  public:

  // optional uint32 count_rx_grant_wait_timeout = 12;
  bool has_count_rx_grant_wait_timeout() const;
  private:
  bool _internal_has_count_rx_grant_wait_timeout() const;
  public:
  void clear_count_rx_grant_wait_timeout();
  uint32_t count_rx_grant_wait_timeout() const;
  void set_count_rx_grant_wait_timeout(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_wait_timeout() const;
  void _internal_set_count_rx_grant_wait_timeout(uint32_t value);
  public:

  // optional uint32 count_rx_grant_deactivated_during_request = 13;
  bool has_count_rx_grant_deactivated_during_request() const;
  private:
  bool _internal_has_count_rx_grant_deactivated_during_request() const;
  public:
  void clear_count_rx_grant_deactivated_during_request();
  uint32_t count_rx_grant_deactivated_during_request() const;
  void set_count_rx_grant_deactivated_during_request(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_deactivated_during_request() const;
  void _internal_set_count_rx_grant_deactivated_during_request(uint32_t value);
  public:

  // optional uint32 count_rx_grant_none = 14;
  bool has_count_rx_grant_none() const;
  private:
  bool _internal_has_count_rx_grant_none() const;
  public:
  void clear_count_rx_grant_none();
  uint32_t count_rx_grant_none() const;
  void set_count_rx_grant_none(uint32_t value);
  private:
  uint32_t _internal_count_rx_grant_none() const;
  void _internal_set_count_rx_grant_none(uint32_t value);
  public:

  // optional uint32 rx_average_request_to_grant_time_us = 15;
  bool has_rx_average_request_to_grant_time_us() const;
  private:
  bool _internal_has_rx_average_request_to_grant_time_us() const;
  public:
  void clear_rx_average_request_to_grant_time_us();
  uint32_t rx_average_request_to_grant_time_us() const;
  void set_rx_average_request_to_grant_time_us(uint32_t value);
  private:
  uint32_t _internal_rx_average_request_to_grant_time_us() const;
  void _internal_set_rx_average_request_to_grant_time_us(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.CoexMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t count_tx_request_;
    uint32_t count_tx_grant_immediate_;
    uint32_t count_tx_grant_wait_;
    uint32_t count_tx_grant_wait_activated_;
    uint32_t count_tx_grant_wait_timeout_;
    uint32_t count_tx_grant_deactivated_during_request_;
    uint32_t tx_average_request_to_grant_time_us_;
    uint32_t count_rx_request_;
    uint32_t count_rx_grant_immediate_;
    uint32_t count_rx_grant_wait_;
    uint32_t count_rx_grant_wait_activated_;
    uint32_t count_rx_grant_wait_timeout_;
    uint32_t count_rx_grant_deactivated_during_request_;
    uint32_t count_rx_grant_none_;
    uint32_t rx_average_request_to_grant_time_us_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_LinkMetricsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.LinkMetricsEntry) */ {
 public:
  inline TelemetryData_LinkMetricsEntry() : TelemetryData_LinkMetricsEntry(nullptr) {}
  ~TelemetryData_LinkMetricsEntry() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_LinkMetricsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_LinkMetricsEntry(const TelemetryData_LinkMetricsEntry& from);
  TelemetryData_LinkMetricsEntry(TelemetryData_LinkMetricsEntry&& from) noexcept
    : TelemetryData_LinkMetricsEntry() {
    *this = ::std::move(from);
  }

  inline TelemetryData_LinkMetricsEntry& operator=(const TelemetryData_LinkMetricsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_LinkMetricsEntry& operator=(TelemetryData_LinkMetricsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_LinkMetricsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_LinkMetricsEntry* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_LinkMetricsEntry*>(
               &_TelemetryData_LinkMetricsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TelemetryData_LinkMetricsEntry& a, TelemetryData_LinkMetricsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_LinkMetricsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_LinkMetricsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_LinkMetricsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_LinkMetricsEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_LinkMetricsEntry& from);
  void MergeFrom(const TelemetryData_LinkMetricsEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_LinkMetricsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.LinkMetricsEntry";
  }
  protected:
  explicit TelemetryData_LinkMetricsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkMarginFieldNumber = 1,
    kRssiFieldNumber = 2,
  };
  // optional int32 link_margin = 1;
  bool has_link_margin() const;
  private:
  bool _internal_has_link_margin() const;
  public:
  void clear_link_margin();
  int32_t link_margin() const;
  void set_link_margin(int32_t value);
  private:
  int32_t _internal_link_margin() const;
  void _internal_set_link_margin(int32_t value);
  public:

  // optional int32 rssi = 2;
  bool has_rssi() const;
  private:
  bool _internal_has_rssi() const;
  public:
  void clear_rssi();
  int32_t rssi() const;
  void set_rssi(int32_t value);
  private:
  int32_t _internal_rssi() const;
  void _internal_set_rssi(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.LinkMetricsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t link_margin_;
    int32_t rssi_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData_LowPowerMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData.LowPowerMetrics) */ {
 public:
  inline TelemetryData_LowPowerMetrics() : TelemetryData_LowPowerMetrics(nullptr) {}
  ~TelemetryData_LowPowerMetrics() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData_LowPowerMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData_LowPowerMetrics(const TelemetryData_LowPowerMetrics& from);
  TelemetryData_LowPowerMetrics(TelemetryData_LowPowerMetrics&& from) noexcept
    : TelemetryData_LowPowerMetrics() {
    *this = ::std::move(from);
  }

  inline TelemetryData_LowPowerMetrics& operator=(const TelemetryData_LowPowerMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData_LowPowerMetrics& operator=(TelemetryData_LowPowerMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData_LowPowerMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData_LowPowerMetrics* internal_default_instance() {
    return reinterpret_cast<const TelemetryData_LowPowerMetrics*>(
               &_TelemetryData_LowPowerMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TelemetryData_LowPowerMetrics& a, TelemetryData_LowPowerMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData_LowPowerMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData_LowPowerMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData_LowPowerMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData_LowPowerMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData_LowPowerMetrics& from);
  void MergeFrom(const TelemetryData_LowPowerMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData_LowPowerMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData.LowPowerMetrics";
  }
  protected:
  explicit TelemetryData_LowPowerMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkMetricsEntriesFieldNumber = 1,
  };
  // repeated .threadnetwork.TelemetryData.LinkMetricsEntry link_metrics_entries = 1;
  int link_metrics_entries_size() const;
  private:
  int _internal_link_metrics_entries_size() const;
  public:
  void clear_link_metrics_entries();
  ::threadnetwork::TelemetryData_LinkMetricsEntry* mutable_link_metrics_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_LinkMetricsEntry >*
      mutable_link_metrics_entries();
  private:
  const ::threadnetwork::TelemetryData_LinkMetricsEntry& _internal_link_metrics_entries(int index) const;
  ::threadnetwork::TelemetryData_LinkMetricsEntry* _internal_add_link_metrics_entries();
  public:
  const ::threadnetwork::TelemetryData_LinkMetricsEntry& link_metrics_entries(int index) const;
  ::threadnetwork::TelemetryData_LinkMetricsEntry* add_link_metrics_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_LinkMetricsEntry >&
      link_metrics_entries() const;

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData.LowPowerMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_LinkMetricsEntry > link_metrics_entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:threadnetwork.TelemetryData) */ {
 public:
  inline TelemetryData() : TelemetryData(nullptr) {}
  ~TelemetryData() override;
  explicit PROTOBUF_CONSTEXPR TelemetryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryData(const TelemetryData& from);
  TelemetryData(TelemetryData&& from) noexcept
    : TelemetryData() {
    *this = ::std::move(from);
  }

  inline TelemetryData& operator=(const TelemetryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData& operator=(TelemetryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TelemetryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryData* internal_default_instance() {
    return reinterpret_cast<const TelemetryData*>(
               &_TelemetryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TelemetryData& a, TelemetryData& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TelemetryData& from);
  void MergeFrom(const TelemetryData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TelemetryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "threadnetwork.TelemetryData";
  }
  protected:
  explicit TelemetryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TelemetryData_Duration Duration;
  typedef TelemetryData_WpanStats WpanStats;
  typedef TelemetryData_WpanTopoFull WpanTopoFull;
  typedef TelemetryData_TopoEntry TopoEntry;
  typedef TelemetryData_PacketsAndBytes PacketsAndBytes;
  typedef TelemetryData_Nat64TrafficCounters Nat64TrafficCounters;
  typedef TelemetryData_Nat64ProtocolCounters Nat64ProtocolCounters;
  typedef TelemetryData_Nat64PacketCounters Nat64PacketCounters;
  typedef TelemetryData_Nat64ErrorCounters Nat64ErrorCounters;
  typedef TelemetryData_BorderRoutingCounters BorderRoutingCounters;
  typedef TelemetryData_PdProcessedRaInfo PdProcessedRaInfo;
  typedef TelemetryData_SrpServerRegistrationInfo SrpServerRegistrationInfo;
  typedef TelemetryData_SrpServerResponseCounters SrpServerResponseCounters;
  typedef TelemetryData_SrpServerInfo SrpServerInfo;
  typedef TelemetryData_TrelPacketCounters TrelPacketCounters;
  typedef TelemetryData_TrelInfo TrelInfo;
  typedef TelemetryData_DnsServerResponseCounters DnsServerResponseCounters;
  typedef TelemetryData_DnsServerInfo DnsServerInfo;
  typedef TelemetryData_MdnsResponseCounters MdnsResponseCounters;
  typedef TelemetryData_MdnsInfo MdnsInfo;
  typedef TelemetryData_BorderRoutingNat64State BorderRoutingNat64State;
  typedef TelemetryData_Nat64Mapping Nat64Mapping;
  typedef TelemetryData_InfraLinkInfo InfraLinkInfo;
  typedef TelemetryData_WpanBorderRouter WpanBorderRouter;
  typedef TelemetryData_RcpStabilityStatistics RcpStabilityStatistics;
  typedef TelemetryData_RcpInterfaceStatistics RcpInterfaceStatistics;
  typedef TelemetryData_WpanRcp WpanRcp;
  typedef TelemetryData_CoexMetrics CoexMetrics;
  typedef TelemetryData_LinkMetricsEntry LinkMetricsEntry;
  typedef TelemetryData_LowPowerMetrics LowPowerMetrics;

  typedef TelemetryData_NodeType NodeType;
  static constexpr NodeType NODE_TYPE_UNSPECIFIED =
    TelemetryData_NodeType_NODE_TYPE_UNSPECIFIED;
  static constexpr NodeType NODE_TYPE_ROUTER =
    TelemetryData_NodeType_NODE_TYPE_ROUTER;
  static constexpr NodeType NODE_TYPE_END =
    TelemetryData_NodeType_NODE_TYPE_END;
  static constexpr NodeType NODE_TYPE_SLEEPY_END =
    TelemetryData_NodeType_NODE_TYPE_SLEEPY_END;
  static constexpr NodeType NODE_TYPE_MINIMAL_END =
    TelemetryData_NodeType_NODE_TYPE_MINIMAL_END;
  static constexpr NodeType NODE_TYPE_OFFLINE =
    TelemetryData_NodeType_NODE_TYPE_OFFLINE;
  static constexpr NodeType NODE_TYPE_DISABLED =
    TelemetryData_NodeType_NODE_TYPE_DISABLED;
  static constexpr NodeType NODE_TYPE_DETACHED =
    TelemetryData_NodeType_NODE_TYPE_DETACHED;
  static constexpr NodeType NODE_TYPE_NL_LURKER =
    TelemetryData_NodeType_NODE_TYPE_NL_LURKER;
  static constexpr NodeType NODE_TYPE_COMMISSIONER =
    TelemetryData_NodeType_NODE_TYPE_COMMISSIONER;
  static constexpr NodeType NODE_TYPE_LEADER =
    TelemetryData_NodeType_NODE_TYPE_LEADER;
  static inline bool NodeType_IsValid(int value) {
    return TelemetryData_NodeType_IsValid(value);
  }
  static constexpr NodeType NodeType_MIN =
    TelemetryData_NodeType_NodeType_MIN;
  static constexpr NodeType NodeType_MAX =
    TelemetryData_NodeType_NodeType_MAX;
  static constexpr int NodeType_ARRAYSIZE =
    TelemetryData_NodeType_NodeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& NodeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NodeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NodeType_Name.");
    return TelemetryData_NodeType_Name(enum_t_value);
  }
  static inline bool NodeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NodeType* value) {
    return TelemetryData_NodeType_Parse(name, value);
  }

  typedef TelemetryData_Dhcp6PdState Dhcp6PdState;
  static constexpr Dhcp6PdState DHCP6_PD_STATE_UNSPECIFIED =
    TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_UNSPECIFIED;
  static constexpr Dhcp6PdState DHCP6_PD_STATE_DISABLED =
    TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_DISABLED;
  static constexpr Dhcp6PdState DHCP6_PD_STATE_STOPPED =
    TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_STOPPED;
  static constexpr Dhcp6PdState DHCP6_PD_STATE_RUNNING =
    TelemetryData_Dhcp6PdState_DHCP6_PD_STATE_RUNNING;
  static inline bool Dhcp6PdState_IsValid(int value) {
    return TelemetryData_Dhcp6PdState_IsValid(value);
  }
  static constexpr Dhcp6PdState Dhcp6PdState_MIN =
    TelemetryData_Dhcp6PdState_Dhcp6PdState_MIN;
  static constexpr Dhcp6PdState Dhcp6PdState_MAX =
    TelemetryData_Dhcp6PdState_Dhcp6PdState_MAX;
  static constexpr int Dhcp6PdState_ARRAYSIZE =
    TelemetryData_Dhcp6PdState_Dhcp6PdState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Dhcp6PdState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Dhcp6PdState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Dhcp6PdState_Name.");
    return TelemetryData_Dhcp6PdState_Name(enum_t_value);
  }
  static inline bool Dhcp6PdState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Dhcp6PdState* value) {
    return TelemetryData_Dhcp6PdState_Parse(name, value);
  }

  typedef TelemetryData_SrpServerState SrpServerState;
  static constexpr SrpServerState SRP_SERVER_STATE_UNSPECIFIED =
    TelemetryData_SrpServerState_SRP_SERVER_STATE_UNSPECIFIED;
  static constexpr SrpServerState SRP_SERVER_STATE_DISABLED =
    TelemetryData_SrpServerState_SRP_SERVER_STATE_DISABLED;
  static constexpr SrpServerState SRP_SERVER_STATE_RUNNING =
    TelemetryData_SrpServerState_SRP_SERVER_STATE_RUNNING;
  static constexpr SrpServerState SRP_SERVER_STATE_STOPPED =
    TelemetryData_SrpServerState_SRP_SERVER_STATE_STOPPED;
  static inline bool SrpServerState_IsValid(int value) {
    return TelemetryData_SrpServerState_IsValid(value);
  }
  static constexpr SrpServerState SrpServerState_MIN =
    TelemetryData_SrpServerState_SrpServerState_MIN;
  static constexpr SrpServerState SrpServerState_MAX =
    TelemetryData_SrpServerState_SrpServerState_MAX;
  static constexpr int SrpServerState_ARRAYSIZE =
    TelemetryData_SrpServerState_SrpServerState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SrpServerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SrpServerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SrpServerState_Name.");
    return TelemetryData_SrpServerState_Name(enum_t_value);
  }
  static inline bool SrpServerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SrpServerState* value) {
    return TelemetryData_SrpServerState_Parse(name, value);
  }

  typedef TelemetryData_SrpServerAddressMode SrpServerAddressMode;
  static constexpr SrpServerAddressMode SRP_SERVER_ADDRESS_MODE_UNSPECIFIED =
    TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_UNSPECIFIED;
  static constexpr SrpServerAddressMode SRP_SERVER_ADDRESS_MODE_UNICAST =
    TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_UNICAST;
  static constexpr SrpServerAddressMode SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST =
    TelemetryData_SrpServerAddressMode_SRP_SERVER_ADDRESS_MODE_STATE_ANYCAST;
  static inline bool SrpServerAddressMode_IsValid(int value) {
    return TelemetryData_SrpServerAddressMode_IsValid(value);
  }
  static constexpr SrpServerAddressMode SrpServerAddressMode_MIN =
    TelemetryData_SrpServerAddressMode_SrpServerAddressMode_MIN;
  static constexpr SrpServerAddressMode SrpServerAddressMode_MAX =
    TelemetryData_SrpServerAddressMode_SrpServerAddressMode_MAX;
  static constexpr int SrpServerAddressMode_ARRAYSIZE =
    TelemetryData_SrpServerAddressMode_SrpServerAddressMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SrpServerAddressMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SrpServerAddressMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SrpServerAddressMode_Name.");
    return TelemetryData_SrpServerAddressMode_Name(enum_t_value);
  }
  static inline bool SrpServerAddressMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SrpServerAddressMode* value) {
    return TelemetryData_SrpServerAddressMode_Parse(name, value);
  }

  typedef TelemetryData_UpstreamDnsQueryState UpstreamDnsQueryState;
  static constexpr UpstreamDnsQueryState UPSTREAMDNS_QUERY_STATE_UNSPECIFIED =
    TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_UNSPECIFIED;
  static constexpr UpstreamDnsQueryState UPSTREAMDNS_QUERY_STATE_ENABLED =
    TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_ENABLED;
  static constexpr UpstreamDnsQueryState UPSTREAMDNS_QUERY_STATE_DISABLED =
    TelemetryData_UpstreamDnsQueryState_UPSTREAMDNS_QUERY_STATE_DISABLED;
  static inline bool UpstreamDnsQueryState_IsValid(int value) {
    return TelemetryData_UpstreamDnsQueryState_IsValid(value);
  }
  static constexpr UpstreamDnsQueryState UpstreamDnsQueryState_MIN =
    TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_MIN;
  static constexpr UpstreamDnsQueryState UpstreamDnsQueryState_MAX =
    TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_MAX;
  static constexpr int UpstreamDnsQueryState_ARRAYSIZE =
    TelemetryData_UpstreamDnsQueryState_UpstreamDnsQueryState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UpstreamDnsQueryState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpstreamDnsQueryState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpstreamDnsQueryState_Name.");
    return TelemetryData_UpstreamDnsQueryState_Name(enum_t_value);
  }
  static inline bool UpstreamDnsQueryState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpstreamDnsQueryState* value) {
    return TelemetryData_UpstreamDnsQueryState_Parse(name, value);
  }

  typedef TelemetryData_Nat64State Nat64State;
  static constexpr Nat64State NAT64_STATE_UNSPECIFIED =
    TelemetryData_Nat64State_NAT64_STATE_UNSPECIFIED;
  static constexpr Nat64State NAT64_STATE_DISABLED =
    TelemetryData_Nat64State_NAT64_STATE_DISABLED;
  static constexpr Nat64State NAT64_STATE_NOT_RUNNING =
    TelemetryData_Nat64State_NAT64_STATE_NOT_RUNNING;
  static constexpr Nat64State NAT64_STATE_IDLE =
    TelemetryData_Nat64State_NAT64_STATE_IDLE;
  static constexpr Nat64State NAT64_STATE_ACTIVE =
    TelemetryData_Nat64State_NAT64_STATE_ACTIVE;
  static inline bool Nat64State_IsValid(int value) {
    return TelemetryData_Nat64State_IsValid(value);
  }
  static constexpr Nat64State Nat64State_MIN =
    TelemetryData_Nat64State_Nat64State_MIN;
  static constexpr Nat64State Nat64State_MAX =
    TelemetryData_Nat64State_Nat64State_MAX;
  static constexpr int Nat64State_ARRAYSIZE =
    TelemetryData_Nat64State_Nat64State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Nat64State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Nat64State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Nat64State_Name.");
    return TelemetryData_Nat64State_Name(enum_t_value);
  }
  static inline bool Nat64State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Nat64State* value) {
    return TelemetryData_Nat64State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTopoEntriesFieldNumber = 3,
    kWpanStatsFieldNumber = 1,
    kWpanTopoFullFieldNumber = 2,
    kWpanBorderRouterFieldNumber = 4,
    kWpanRcpFieldNumber = 5,
    kCoexMetricsFieldNumber = 7,
    kLowPowerMetricsFieldNumber = 8,
  };
  // repeated .threadnetwork.TelemetryData.TopoEntry topo_entries = 3;
  int topo_entries_size() const;
  private:
  int _internal_topo_entries_size() const;
  public:
  void clear_topo_entries();
  ::threadnetwork::TelemetryData_TopoEntry* mutable_topo_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_TopoEntry >*
      mutable_topo_entries();
  private:
  const ::threadnetwork::TelemetryData_TopoEntry& _internal_topo_entries(int index) const;
  ::threadnetwork::TelemetryData_TopoEntry* _internal_add_topo_entries();
  public:
  const ::threadnetwork::TelemetryData_TopoEntry& topo_entries(int index) const;
  ::threadnetwork::TelemetryData_TopoEntry* add_topo_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_TopoEntry >&
      topo_entries() const;

  // optional .threadnetwork.TelemetryData.WpanStats wpan_stats = 1;
  bool has_wpan_stats() const;
  private:
  bool _internal_has_wpan_stats() const;
  public:
  void clear_wpan_stats();
  const ::threadnetwork::TelemetryData_WpanStats& wpan_stats() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_WpanStats* release_wpan_stats();
  ::threadnetwork::TelemetryData_WpanStats* mutable_wpan_stats();
  void set_allocated_wpan_stats(::threadnetwork::TelemetryData_WpanStats* wpan_stats);
  private:
  const ::threadnetwork::TelemetryData_WpanStats& _internal_wpan_stats() const;
  ::threadnetwork::TelemetryData_WpanStats* _internal_mutable_wpan_stats();
  public:
  void unsafe_arena_set_allocated_wpan_stats(
      ::threadnetwork::TelemetryData_WpanStats* wpan_stats);
  ::threadnetwork::TelemetryData_WpanStats* unsafe_arena_release_wpan_stats();

  // optional .threadnetwork.TelemetryData.WpanTopoFull wpan_topo_full = 2;
  bool has_wpan_topo_full() const;
  private:
  bool _internal_has_wpan_topo_full() const;
  public:
  void clear_wpan_topo_full();
  const ::threadnetwork::TelemetryData_WpanTopoFull& wpan_topo_full() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_WpanTopoFull* release_wpan_topo_full();
  ::threadnetwork::TelemetryData_WpanTopoFull* mutable_wpan_topo_full();
  void set_allocated_wpan_topo_full(::threadnetwork::TelemetryData_WpanTopoFull* wpan_topo_full);
  private:
  const ::threadnetwork::TelemetryData_WpanTopoFull& _internal_wpan_topo_full() const;
  ::threadnetwork::TelemetryData_WpanTopoFull* _internal_mutable_wpan_topo_full();
  public:
  void unsafe_arena_set_allocated_wpan_topo_full(
      ::threadnetwork::TelemetryData_WpanTopoFull* wpan_topo_full);
  ::threadnetwork::TelemetryData_WpanTopoFull* unsafe_arena_release_wpan_topo_full();

  // optional .threadnetwork.TelemetryData.WpanBorderRouter wpan_border_router = 4;
  bool has_wpan_border_router() const;
  private:
  bool _internal_has_wpan_border_router() const;
  public:
  void clear_wpan_border_router();
  const ::threadnetwork::TelemetryData_WpanBorderRouter& wpan_border_router() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_WpanBorderRouter* release_wpan_border_router();
  ::threadnetwork::TelemetryData_WpanBorderRouter* mutable_wpan_border_router();
  void set_allocated_wpan_border_router(::threadnetwork::TelemetryData_WpanBorderRouter* wpan_border_router);
  private:
  const ::threadnetwork::TelemetryData_WpanBorderRouter& _internal_wpan_border_router() const;
  ::threadnetwork::TelemetryData_WpanBorderRouter* _internal_mutable_wpan_border_router();
  public:
  void unsafe_arena_set_allocated_wpan_border_router(
      ::threadnetwork::TelemetryData_WpanBorderRouter* wpan_border_router);
  ::threadnetwork::TelemetryData_WpanBorderRouter* unsafe_arena_release_wpan_border_router();

  // optional .threadnetwork.TelemetryData.WpanRcp wpan_rcp = 5;
  bool has_wpan_rcp() const;
  private:
  bool _internal_has_wpan_rcp() const;
  public:
  void clear_wpan_rcp();
  const ::threadnetwork::TelemetryData_WpanRcp& wpan_rcp() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_WpanRcp* release_wpan_rcp();
  ::threadnetwork::TelemetryData_WpanRcp* mutable_wpan_rcp();
  void set_allocated_wpan_rcp(::threadnetwork::TelemetryData_WpanRcp* wpan_rcp);
  private:
  const ::threadnetwork::TelemetryData_WpanRcp& _internal_wpan_rcp() const;
  ::threadnetwork::TelemetryData_WpanRcp* _internal_mutable_wpan_rcp();
  public:
  void unsafe_arena_set_allocated_wpan_rcp(
      ::threadnetwork::TelemetryData_WpanRcp* wpan_rcp);
  ::threadnetwork::TelemetryData_WpanRcp* unsafe_arena_release_wpan_rcp();

  // optional .threadnetwork.TelemetryData.CoexMetrics coex_metrics = 7;
  bool has_coex_metrics() const;
  private:
  bool _internal_has_coex_metrics() const;
  public:
  void clear_coex_metrics();
  const ::threadnetwork::TelemetryData_CoexMetrics& coex_metrics() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_CoexMetrics* release_coex_metrics();
  ::threadnetwork::TelemetryData_CoexMetrics* mutable_coex_metrics();
  void set_allocated_coex_metrics(::threadnetwork::TelemetryData_CoexMetrics* coex_metrics);
  private:
  const ::threadnetwork::TelemetryData_CoexMetrics& _internal_coex_metrics() const;
  ::threadnetwork::TelemetryData_CoexMetrics* _internal_mutable_coex_metrics();
  public:
  void unsafe_arena_set_allocated_coex_metrics(
      ::threadnetwork::TelemetryData_CoexMetrics* coex_metrics);
  ::threadnetwork::TelemetryData_CoexMetrics* unsafe_arena_release_coex_metrics();

  // optional .threadnetwork.TelemetryData.LowPowerMetrics low_power_metrics = 8;
  bool has_low_power_metrics() const;
  private:
  bool _internal_has_low_power_metrics() const;
  public:
  void clear_low_power_metrics();
  const ::threadnetwork::TelemetryData_LowPowerMetrics& low_power_metrics() const;
  PROTOBUF_NODISCARD ::threadnetwork::TelemetryData_LowPowerMetrics* release_low_power_metrics();
  ::threadnetwork::TelemetryData_LowPowerMetrics* mutable_low_power_metrics();
  void set_allocated_low_power_metrics(::threadnetwork::TelemetryData_LowPowerMetrics* low_power_metrics);
  private:
  const ::threadnetwork::TelemetryData_LowPowerMetrics& _internal_low_power_metrics() const;
  ::threadnetwork::TelemetryData_LowPowerMetrics* _internal_mutable_low_power_metrics();
  public:
  void unsafe_arena_set_allocated_low_power_metrics(
      ::threadnetwork::TelemetryData_LowPowerMetrics* low_power_metrics);
  ::threadnetwork::TelemetryData_LowPowerMetrics* unsafe_arena_release_low_power_metrics();

  // @@protoc_insertion_point(class_scope:threadnetwork.TelemetryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_TopoEntry > topo_entries_;
    ::threadnetwork::TelemetryData_WpanStats* wpan_stats_;
    ::threadnetwork::TelemetryData_WpanTopoFull* wpan_topo_full_;
    ::threadnetwork::TelemetryData_WpanBorderRouter* wpan_border_router_;
    ::threadnetwork::TelemetryData_WpanRcp* wpan_rcp_;
    ::threadnetwork::TelemetryData_CoexMetrics* coex_metrics_;
    ::threadnetwork::TelemetryData_LowPowerMetrics* low_power_metrics_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thread_5ftelemetry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TelemetryData_Duration

// optional int64 seconds = 1;
inline bool TelemetryData_Duration::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_Duration::has_seconds() const {
  return _internal_has_seconds();
}
inline void TelemetryData_Duration::clear_seconds() {
  _impl_.seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TelemetryData_Duration::_internal_seconds() const {
  return _impl_.seconds_;
}
inline int64_t TelemetryData_Duration::seconds() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Duration.seconds)
  return _internal_seconds();
}
inline void TelemetryData_Duration::_internal_set_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seconds_ = value;
}
inline void TelemetryData_Duration::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Duration.seconds)
}

// optional int32 nanos = 2;
inline bool TelemetryData_Duration::_internal_has_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_Duration::has_nanos() const {
  return _internal_has_nanos();
}
inline void TelemetryData_Duration::clear_nanos() {
  _impl_.nanos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TelemetryData_Duration::_internal_nanos() const {
  return _impl_.nanos_;
}
inline int32_t TelemetryData_Duration::nanos() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Duration.nanos)
  return _internal_nanos();
}
inline void TelemetryData_Duration::_internal_set_nanos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nanos_ = value;
}
inline void TelemetryData_Duration::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Duration.nanos)
}

// -------------------------------------------------------------------

// TelemetryData_WpanStats

// optional int32 phy_rx = 1;
inline bool TelemetryData_WpanStats::_internal_has_phy_rx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_phy_rx() const {
  return _internal_has_phy_rx();
}
inline void TelemetryData_WpanStats::clear_phy_rx() {
  _impl_.phy_rx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TelemetryData_WpanStats::_internal_phy_rx() const {
  return _impl_.phy_rx_;
}
inline int32_t TelemetryData_WpanStats::phy_rx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.phy_rx)
  return _internal_phy_rx();
}
inline void TelemetryData_WpanStats::_internal_set_phy_rx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phy_rx_ = value;
}
inline void TelemetryData_WpanStats::set_phy_rx(int32_t value) {
  _internal_set_phy_rx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.phy_rx)
}

// optional int32 phy_tx = 2;
inline bool TelemetryData_WpanStats::_internal_has_phy_tx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_phy_tx() const {
  return _internal_has_phy_tx();
}
inline void TelemetryData_WpanStats::clear_phy_tx() {
  _impl_.phy_tx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TelemetryData_WpanStats::_internal_phy_tx() const {
  return _impl_.phy_tx_;
}
inline int32_t TelemetryData_WpanStats::phy_tx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.phy_tx)
  return _internal_phy_tx();
}
inline void TelemetryData_WpanStats::_internal_set_phy_tx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phy_tx_ = value;
}
inline void TelemetryData_WpanStats::set_phy_tx(int32_t value) {
  _internal_set_phy_tx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.phy_tx)
}

// optional int32 mac_unicast_rx = 3;
inline bool TelemetryData_WpanStats::_internal_has_mac_unicast_rx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_unicast_rx() const {
  return _internal_has_mac_unicast_rx();
}
inline void TelemetryData_WpanStats::clear_mac_unicast_rx() {
  _impl_.mac_unicast_rx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_unicast_rx() const {
  return _impl_.mac_unicast_rx_;
}
inline int32_t TelemetryData_WpanStats::mac_unicast_rx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_unicast_rx)
  return _internal_mac_unicast_rx();
}
inline void TelemetryData_WpanStats::_internal_set_mac_unicast_rx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mac_unicast_rx_ = value;
}
inline void TelemetryData_WpanStats::set_mac_unicast_rx(int32_t value) {
  _internal_set_mac_unicast_rx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_unicast_rx)
}

// optional int32 mac_unicast_tx = 4;
inline bool TelemetryData_WpanStats::_internal_has_mac_unicast_tx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_unicast_tx() const {
  return _internal_has_mac_unicast_tx();
}
inline void TelemetryData_WpanStats::clear_mac_unicast_tx() {
  _impl_.mac_unicast_tx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_unicast_tx() const {
  return _impl_.mac_unicast_tx_;
}
inline int32_t TelemetryData_WpanStats::mac_unicast_tx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_unicast_tx)
  return _internal_mac_unicast_tx();
}
inline void TelemetryData_WpanStats::_internal_set_mac_unicast_tx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mac_unicast_tx_ = value;
}
inline void TelemetryData_WpanStats::set_mac_unicast_tx(int32_t value) {
  _internal_set_mac_unicast_tx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_unicast_tx)
}

// optional int32 mac_broadcast_rx = 5;
inline bool TelemetryData_WpanStats::_internal_has_mac_broadcast_rx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_broadcast_rx() const {
  return _internal_has_mac_broadcast_rx();
}
inline void TelemetryData_WpanStats::clear_mac_broadcast_rx() {
  _impl_.mac_broadcast_rx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_broadcast_rx() const {
  return _impl_.mac_broadcast_rx_;
}
inline int32_t TelemetryData_WpanStats::mac_broadcast_rx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_broadcast_rx)
  return _internal_mac_broadcast_rx();
}
inline void TelemetryData_WpanStats::_internal_set_mac_broadcast_rx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mac_broadcast_rx_ = value;
}
inline void TelemetryData_WpanStats::set_mac_broadcast_rx(int32_t value) {
  _internal_set_mac_broadcast_rx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_broadcast_rx)
}

// optional int32 mac_broadcast_tx = 6;
inline bool TelemetryData_WpanStats::_internal_has_mac_broadcast_tx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_broadcast_tx() const {
  return _internal_has_mac_broadcast_tx();
}
inline void TelemetryData_WpanStats::clear_mac_broadcast_tx() {
  _impl_.mac_broadcast_tx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_broadcast_tx() const {
  return _impl_.mac_broadcast_tx_;
}
inline int32_t TelemetryData_WpanStats::mac_broadcast_tx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_broadcast_tx)
  return _internal_mac_broadcast_tx();
}
inline void TelemetryData_WpanStats::_internal_set_mac_broadcast_tx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mac_broadcast_tx_ = value;
}
inline void TelemetryData_WpanStats::set_mac_broadcast_tx(int32_t value) {
  _internal_set_mac_broadcast_tx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_broadcast_tx)
}

// optional int32 mac_tx_ack_req = 7;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_ack_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_ack_req() const {
  return _internal_has_mac_tx_ack_req();
}
inline void TelemetryData_WpanStats::clear_mac_tx_ack_req() {
  _impl_.mac_tx_ack_req_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_ack_req() const {
  return _impl_.mac_tx_ack_req_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_ack_req() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_ack_req)
  return _internal_mac_tx_ack_req();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_ack_req(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.mac_tx_ack_req_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_ack_req(int32_t value) {
  _internal_set_mac_tx_ack_req(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_ack_req)
}

// optional int32 mac_tx_no_ack_req = 8;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_no_ack_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_no_ack_req() const {
  return _internal_has_mac_tx_no_ack_req();
}
inline void TelemetryData_WpanStats::clear_mac_tx_no_ack_req() {
  _impl_.mac_tx_no_ack_req_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_no_ack_req() const {
  return _impl_.mac_tx_no_ack_req_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_no_ack_req() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_no_ack_req)
  return _internal_mac_tx_no_ack_req();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_no_ack_req(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.mac_tx_no_ack_req_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_no_ack_req(int32_t value) {
  _internal_set_mac_tx_no_ack_req(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_no_ack_req)
}

// optional int32 mac_tx_acked = 9;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_acked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_acked() const {
  return _internal_has_mac_tx_acked();
}
inline void TelemetryData_WpanStats::clear_mac_tx_acked() {
  _impl_.mac_tx_acked_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_acked() const {
  return _impl_.mac_tx_acked_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_acked() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_acked)
  return _internal_mac_tx_acked();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_acked(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.mac_tx_acked_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_acked(int32_t value) {
  _internal_set_mac_tx_acked(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_acked)
}

// optional int32 mac_tx_data = 10;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_data() const {
  return _internal_has_mac_tx_data();
}
inline void TelemetryData_WpanStats::clear_mac_tx_data() {
  _impl_.mac_tx_data_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_data() const {
  return _impl_.mac_tx_data_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_data() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_data)
  return _internal_mac_tx_data();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_data(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mac_tx_data_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_data(int32_t value) {
  _internal_set_mac_tx_data(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_data)
}

// optional int32 mac_tx_data_poll = 11;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_data_poll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_data_poll() const {
  return _internal_has_mac_tx_data_poll();
}
inline void TelemetryData_WpanStats::clear_mac_tx_data_poll() {
  _impl_.mac_tx_data_poll_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_data_poll() const {
  return _impl_.mac_tx_data_poll_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_data_poll() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_data_poll)
  return _internal_mac_tx_data_poll();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_data_poll(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.mac_tx_data_poll_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_data_poll(int32_t value) {
  _internal_set_mac_tx_data_poll(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_data_poll)
}

// optional int32 mac_tx_beacon = 12;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_beacon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_beacon() const {
  return _internal_has_mac_tx_beacon();
}
inline void TelemetryData_WpanStats::clear_mac_tx_beacon() {
  _impl_.mac_tx_beacon_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_beacon() const {
  return _impl_.mac_tx_beacon_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_beacon() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_beacon)
  return _internal_mac_tx_beacon();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_beacon(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.mac_tx_beacon_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_beacon(int32_t value) {
  _internal_set_mac_tx_beacon(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_beacon)
}

// optional int32 mac_tx_beacon_req = 13;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_beacon_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_beacon_req() const {
  return _internal_has_mac_tx_beacon_req();
}
inline void TelemetryData_WpanStats::clear_mac_tx_beacon_req() {
  _impl_.mac_tx_beacon_req_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_beacon_req() const {
  return _impl_.mac_tx_beacon_req_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_beacon_req() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_beacon_req)
  return _internal_mac_tx_beacon_req();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_beacon_req(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.mac_tx_beacon_req_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_beacon_req(int32_t value) {
  _internal_set_mac_tx_beacon_req(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_beacon_req)
}

// optional int32 mac_tx_other_pkt = 14;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_other_pkt() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_other_pkt() const {
  return _internal_has_mac_tx_other_pkt();
}
inline void TelemetryData_WpanStats::clear_mac_tx_other_pkt() {
  _impl_.mac_tx_other_pkt_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_other_pkt() const {
  return _impl_.mac_tx_other_pkt_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_other_pkt() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_other_pkt)
  return _internal_mac_tx_other_pkt();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_other_pkt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.mac_tx_other_pkt_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_other_pkt(int32_t value) {
  _internal_set_mac_tx_other_pkt(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_other_pkt)
}

// optional int32 mac_tx_retry = 15;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_retry() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_retry() const {
  return _internal_has_mac_tx_retry();
}
inline void TelemetryData_WpanStats::clear_mac_tx_retry() {
  _impl_.mac_tx_retry_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_retry() const {
  return _impl_.mac_tx_retry_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_retry() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_retry)
  return _internal_mac_tx_retry();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_retry(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.mac_tx_retry_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_retry(int32_t value) {
  _internal_set_mac_tx_retry(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_retry)
}

// optional int32 mac_rx_data = 16;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_data() const {
  return _internal_has_mac_rx_data();
}
inline void TelemetryData_WpanStats::clear_mac_rx_data() {
  _impl_.mac_rx_data_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_data() const {
  return _impl_.mac_rx_data_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_data() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_data)
  return _internal_mac_rx_data();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_data(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.mac_rx_data_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_data(int32_t value) {
  _internal_set_mac_rx_data(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_data)
}

// optional int32 mac_rx_data_poll = 17;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_data_poll() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_data_poll() const {
  return _internal_has_mac_rx_data_poll();
}
inline void TelemetryData_WpanStats::clear_mac_rx_data_poll() {
  _impl_.mac_rx_data_poll_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_data_poll() const {
  return _impl_.mac_rx_data_poll_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_data_poll() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_data_poll)
  return _internal_mac_rx_data_poll();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_data_poll(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.mac_rx_data_poll_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_data_poll(int32_t value) {
  _internal_set_mac_rx_data_poll(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_data_poll)
}

// optional int32 mac_rx_beacon = 18;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_beacon() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_beacon() const {
  return _internal_has_mac_rx_beacon();
}
inline void TelemetryData_WpanStats::clear_mac_rx_beacon() {
  _impl_.mac_rx_beacon_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_beacon() const {
  return _impl_.mac_rx_beacon_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_beacon() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_beacon)
  return _internal_mac_rx_beacon();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_beacon(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.mac_rx_beacon_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_beacon(int32_t value) {
  _internal_set_mac_rx_beacon(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_beacon)
}

// optional int32 mac_rx_beacon_req = 19;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_beacon_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_beacon_req() const {
  return _internal_has_mac_rx_beacon_req();
}
inline void TelemetryData_WpanStats::clear_mac_rx_beacon_req() {
  _impl_.mac_rx_beacon_req_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_beacon_req() const {
  return _impl_.mac_rx_beacon_req_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_beacon_req() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_beacon_req)
  return _internal_mac_rx_beacon_req();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_beacon_req(int32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.mac_rx_beacon_req_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_beacon_req(int32_t value) {
  _internal_set_mac_rx_beacon_req(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_beacon_req)
}

// optional int32 mac_rx_other_pkt = 20;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_other_pkt() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_other_pkt() const {
  return _internal_has_mac_rx_other_pkt();
}
inline void TelemetryData_WpanStats::clear_mac_rx_other_pkt() {
  _impl_.mac_rx_other_pkt_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_other_pkt() const {
  return _impl_.mac_rx_other_pkt_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_other_pkt() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_other_pkt)
  return _internal_mac_rx_other_pkt();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_other_pkt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.mac_rx_other_pkt_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_other_pkt(int32_t value) {
  _internal_set_mac_rx_other_pkt(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_other_pkt)
}

// optional int32 mac_rx_filter_whitelist = 21;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_filter_whitelist() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_filter_whitelist() const {
  return _internal_has_mac_rx_filter_whitelist();
}
inline void TelemetryData_WpanStats::clear_mac_rx_filter_whitelist() {
  _impl_.mac_rx_filter_whitelist_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_filter_whitelist() const {
  return _impl_.mac_rx_filter_whitelist_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_filter_whitelist() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_filter_whitelist)
  return _internal_mac_rx_filter_whitelist();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_filter_whitelist(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.mac_rx_filter_whitelist_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_filter_whitelist(int32_t value) {
  _internal_set_mac_rx_filter_whitelist(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_filter_whitelist)
}

// optional int32 mac_rx_filter_dest_addr = 22;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_filter_dest_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_filter_dest_addr() const {
  return _internal_has_mac_rx_filter_dest_addr();
}
inline void TelemetryData_WpanStats::clear_mac_rx_filter_dest_addr() {
  _impl_.mac_rx_filter_dest_addr_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_filter_dest_addr() const {
  return _impl_.mac_rx_filter_dest_addr_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_filter_dest_addr() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_filter_dest_addr)
  return _internal_mac_rx_filter_dest_addr();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_filter_dest_addr(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.mac_rx_filter_dest_addr_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_filter_dest_addr(int32_t value) {
  _internal_set_mac_rx_filter_dest_addr(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_filter_dest_addr)
}

// optional int32 mac_tx_fail_cca = 23;
inline bool TelemetryData_WpanStats::_internal_has_mac_tx_fail_cca() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_tx_fail_cca() const {
  return _internal_has_mac_tx_fail_cca();
}
inline void TelemetryData_WpanStats::clear_mac_tx_fail_cca() {
  _impl_.mac_tx_fail_cca_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_tx_fail_cca() const {
  return _impl_.mac_tx_fail_cca_;
}
inline int32_t TelemetryData_WpanStats::mac_tx_fail_cca() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_tx_fail_cca)
  return _internal_mac_tx_fail_cca();
}
inline void TelemetryData_WpanStats::_internal_set_mac_tx_fail_cca(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.mac_tx_fail_cca_ = value;
}
inline void TelemetryData_WpanStats::set_mac_tx_fail_cca(int32_t value) {
  _internal_set_mac_tx_fail_cca(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_tx_fail_cca)
}

// optional int32 mac_rx_fail_decrypt = 24;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_decrypt() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_decrypt() const {
  return _internal_has_mac_rx_fail_decrypt();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_decrypt() {
  _impl_.mac_rx_fail_decrypt_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_decrypt() const {
  return _impl_.mac_rx_fail_decrypt_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_decrypt() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_decrypt)
  return _internal_mac_rx_fail_decrypt();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_decrypt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.mac_rx_fail_decrypt_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_decrypt(int32_t value) {
  _internal_set_mac_rx_fail_decrypt(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_decrypt)
}

// optional int32 mac_rx_fail_no_frame = 25;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_no_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_no_frame() const {
  return _internal_has_mac_rx_fail_no_frame();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_no_frame() {
  _impl_.mac_rx_fail_no_frame_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_no_frame() const {
  return _impl_.mac_rx_fail_no_frame_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_no_frame() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_no_frame)
  return _internal_mac_rx_fail_no_frame();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_no_frame(int32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.mac_rx_fail_no_frame_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_no_frame(int32_t value) {
  _internal_set_mac_rx_fail_no_frame(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_no_frame)
}

// optional int32 mac_rx_fail_unknown_neighbor = 26;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_unknown_neighbor() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_unknown_neighbor() const {
  return _internal_has_mac_rx_fail_unknown_neighbor();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_unknown_neighbor() {
  _impl_.mac_rx_fail_unknown_neighbor_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_unknown_neighbor() const {
  return _impl_.mac_rx_fail_unknown_neighbor_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_unknown_neighbor() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_unknown_neighbor)
  return _internal_mac_rx_fail_unknown_neighbor();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_unknown_neighbor(int32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.mac_rx_fail_unknown_neighbor_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_unknown_neighbor(int32_t value) {
  _internal_set_mac_rx_fail_unknown_neighbor(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_unknown_neighbor)
}

// optional int32 mac_rx_fail_invalid_src_addr = 27;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_invalid_src_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_invalid_src_addr() const {
  return _internal_has_mac_rx_fail_invalid_src_addr();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_invalid_src_addr() {
  _impl_.mac_rx_fail_invalid_src_addr_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_invalid_src_addr() const {
  return _impl_.mac_rx_fail_invalid_src_addr_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_invalid_src_addr() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_invalid_src_addr)
  return _internal_mac_rx_fail_invalid_src_addr();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_invalid_src_addr(int32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.mac_rx_fail_invalid_src_addr_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_invalid_src_addr(int32_t value) {
  _internal_set_mac_rx_fail_invalid_src_addr(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_invalid_src_addr)
}

// optional int32 mac_rx_fail_fcs = 28;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_fcs() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_fcs() const {
  return _internal_has_mac_rx_fail_fcs();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_fcs() {
  _impl_.mac_rx_fail_fcs_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_fcs() const {
  return _impl_.mac_rx_fail_fcs_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_fcs() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_fcs)
  return _internal_mac_rx_fail_fcs();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_fcs(int32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.mac_rx_fail_fcs_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_fcs(int32_t value) {
  _internal_set_mac_rx_fail_fcs(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_fcs)
}

// optional int32 mac_rx_fail_other = 29;
inline bool TelemetryData_WpanStats::_internal_has_mac_rx_fail_other() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_rx_fail_other() const {
  return _internal_has_mac_rx_fail_other();
}
inline void TelemetryData_WpanStats::clear_mac_rx_fail_other() {
  _impl_.mac_rx_fail_other_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_mac_rx_fail_other() const {
  return _impl_.mac_rx_fail_other_;
}
inline int32_t TelemetryData_WpanStats::mac_rx_fail_other() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_other)
  return _internal_mac_rx_fail_other();
}
inline void TelemetryData_WpanStats::_internal_set_mac_rx_fail_other(int32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.mac_rx_fail_other_ = value;
}
inline void TelemetryData_WpanStats::set_mac_rx_fail_other(int32_t value) {
  _internal_set_mac_rx_fail_other(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_rx_fail_other)
}

// optional int32 ip_tx_success = 30;
inline bool TelemetryData_WpanStats::_internal_has_ip_tx_success() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_ip_tx_success() const {
  return _internal_has_ip_tx_success();
}
inline void TelemetryData_WpanStats::clear_ip_tx_success() {
  _impl_.ip_tx_success_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_ip_tx_success() const {
  return _impl_.ip_tx_success_;
}
inline int32_t TelemetryData_WpanStats::ip_tx_success() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.ip_tx_success)
  return _internal_ip_tx_success();
}
inline void TelemetryData_WpanStats::_internal_set_ip_tx_success(int32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.ip_tx_success_ = value;
}
inline void TelemetryData_WpanStats::set_ip_tx_success(int32_t value) {
  _internal_set_ip_tx_success(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.ip_tx_success)
}

// optional int32 ip_rx_success = 31;
inline bool TelemetryData_WpanStats::_internal_has_ip_rx_success() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_ip_rx_success() const {
  return _internal_has_ip_rx_success();
}
inline void TelemetryData_WpanStats::clear_ip_rx_success() {
  _impl_.ip_rx_success_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_ip_rx_success() const {
  return _impl_.ip_rx_success_;
}
inline int32_t TelemetryData_WpanStats::ip_rx_success() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.ip_rx_success)
  return _internal_ip_rx_success();
}
inline void TelemetryData_WpanStats::_internal_set_ip_rx_success(int32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.ip_rx_success_ = value;
}
inline void TelemetryData_WpanStats::set_ip_rx_success(int32_t value) {
  _internal_set_ip_rx_success(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.ip_rx_success)
}

// optional int32 ip_tx_failure = 32;
inline bool TelemetryData_WpanStats::_internal_has_ip_tx_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_ip_tx_failure() const {
  return _internal_has_ip_tx_failure();
}
inline void TelemetryData_WpanStats::clear_ip_tx_failure() {
  _impl_.ip_tx_failure_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline int32_t TelemetryData_WpanStats::_internal_ip_tx_failure() const {
  return _impl_.ip_tx_failure_;
}
inline int32_t TelemetryData_WpanStats::ip_tx_failure() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.ip_tx_failure)
  return _internal_ip_tx_failure();
}
inline void TelemetryData_WpanStats::_internal_set_ip_tx_failure(int32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.ip_tx_failure_ = value;
}
inline void TelemetryData_WpanStats::set_ip_tx_failure(int32_t value) {
  _internal_set_ip_tx_failure(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.ip_tx_failure)
}

// optional int32 ip_rx_failure = 33;
inline bool TelemetryData_WpanStats::_internal_has_ip_rx_failure() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_ip_rx_failure() const {
  return _internal_has_ip_rx_failure();
}
inline void TelemetryData_WpanStats::clear_ip_rx_failure() {
  _impl_.ip_rx_failure_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline int32_t TelemetryData_WpanStats::_internal_ip_rx_failure() const {
  return _impl_.ip_rx_failure_;
}
inline int32_t TelemetryData_WpanStats::ip_rx_failure() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.ip_rx_failure)
  return _internal_ip_rx_failure();
}
inline void TelemetryData_WpanStats::_internal_set_ip_rx_failure(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.ip_rx_failure_ = value;
}
inline void TelemetryData_WpanStats::set_ip_rx_failure(int32_t value) {
  _internal_set_ip_rx_failure(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.ip_rx_failure)
}

// optional uint32 node_type = 34;
inline bool TelemetryData_WpanStats::_internal_has_node_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_node_type() const {
  return _internal_has_node_type();
}
inline void TelemetryData_WpanStats::clear_node_type() {
  _impl_.node_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t TelemetryData_WpanStats::_internal_node_type() const {
  return _impl_.node_type_;
}
inline uint32_t TelemetryData_WpanStats::node_type() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.node_type)
  return _internal_node_type();
}
inline void TelemetryData_WpanStats::_internal_set_node_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.node_type_ = value;
}
inline void TelemetryData_WpanStats::set_node_type(uint32_t value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.node_type)
}

// optional uint32 channel = 35;
inline bool TelemetryData_WpanStats::_internal_has_channel() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_channel() const {
  return _internal_has_channel();
}
inline void TelemetryData_WpanStats::clear_channel() {
  _impl_.channel_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t TelemetryData_WpanStats::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t TelemetryData_WpanStats::channel() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.channel)
  return _internal_channel();
}
inline void TelemetryData_WpanStats::_internal_set_channel(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.channel_ = value;
}
inline void TelemetryData_WpanStats::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.channel)
}

// optional int32 radio_tx_power = 36;
inline bool TelemetryData_WpanStats::_internal_has_radio_tx_power() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_radio_tx_power() const {
  return _internal_has_radio_tx_power();
}
inline void TelemetryData_WpanStats::clear_radio_tx_power() {
  _impl_.radio_tx_power_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline int32_t TelemetryData_WpanStats::_internal_radio_tx_power() const {
  return _impl_.radio_tx_power_;
}
inline int32_t TelemetryData_WpanStats::radio_tx_power() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.radio_tx_power)
  return _internal_radio_tx_power();
}
inline void TelemetryData_WpanStats::_internal_set_radio_tx_power(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.radio_tx_power_ = value;
}
inline void TelemetryData_WpanStats::set_radio_tx_power(int32_t value) {
  _internal_set_radio_tx_power(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.radio_tx_power)
}

// optional float mac_cca_fail_rate = 37;
inline bool TelemetryData_WpanStats::_internal_has_mac_cca_fail_rate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_WpanStats::has_mac_cca_fail_rate() const {
  return _internal_has_mac_cca_fail_rate();
}
inline void TelemetryData_WpanStats::clear_mac_cca_fail_rate() {
  _impl_.mac_cca_fail_rate_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline float TelemetryData_WpanStats::_internal_mac_cca_fail_rate() const {
  return _impl_.mac_cca_fail_rate_;
}
inline float TelemetryData_WpanStats::mac_cca_fail_rate() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanStats.mac_cca_fail_rate)
  return _internal_mac_cca_fail_rate();
}
inline void TelemetryData_WpanStats::_internal_set_mac_cca_fail_rate(float value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.mac_cca_fail_rate_ = value;
}
inline void TelemetryData_WpanStats::set_mac_cca_fail_rate(float value) {
  _internal_set_mac_cca_fail_rate(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanStats.mac_cca_fail_rate)
}

// -------------------------------------------------------------------

// TelemetryData_WpanTopoFull

// optional uint32 rloc16 = 1;
inline bool TelemetryData_WpanTopoFull::_internal_has_rloc16() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_rloc16() const {
  return _internal_has_rloc16();
}
inline void TelemetryData_WpanTopoFull::clear_rloc16() {
  _impl_.rloc16_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_rloc16() const {
  return _impl_.rloc16_;
}
inline uint32_t TelemetryData_WpanTopoFull::rloc16() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.rloc16)
  return _internal_rloc16();
}
inline void TelemetryData_WpanTopoFull::_internal_set_rloc16(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rloc16_ = value;
}
inline void TelemetryData_WpanTopoFull::set_rloc16(uint32_t value) {
  _internal_set_rloc16(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.rloc16)
}

// optional uint32 router_id = 2;
inline bool TelemetryData_WpanTopoFull::_internal_has_router_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_router_id() const {
  return _internal_has_router_id();
}
inline void TelemetryData_WpanTopoFull::clear_router_id() {
  _impl_.router_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_router_id() const {
  return _impl_.router_id_;
}
inline uint32_t TelemetryData_WpanTopoFull::router_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.router_id)
  return _internal_router_id();
}
inline void TelemetryData_WpanTopoFull::_internal_set_router_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.router_id_ = value;
}
inline void TelemetryData_WpanTopoFull::set_router_id(uint32_t value) {
  _internal_set_router_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.router_id)
}

// optional uint32 leader_router_id = 3;
inline bool TelemetryData_WpanTopoFull::_internal_has_leader_router_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_leader_router_id() const {
  return _internal_has_leader_router_id();
}
inline void TelemetryData_WpanTopoFull::clear_leader_router_id() {
  _impl_.leader_router_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_leader_router_id() const {
  return _impl_.leader_router_id_;
}
inline uint32_t TelemetryData_WpanTopoFull::leader_router_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.leader_router_id)
  return _internal_leader_router_id();
}
inline void TelemetryData_WpanTopoFull::_internal_set_leader_router_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.leader_router_id_ = value;
}
inline void TelemetryData_WpanTopoFull::set_leader_router_id(uint32_t value) {
  _internal_set_leader_router_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.leader_router_id)
}

// optional bytes leader_address = 5;
inline bool TelemetryData_WpanTopoFull::_internal_has_leader_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_leader_address() const {
  return _internal_has_leader_address();
}
inline void TelemetryData_WpanTopoFull::clear_leader_address() {
  _impl_.leader_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryData_WpanTopoFull::leader_address() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.leader_address)
  return _internal_leader_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_WpanTopoFull::set_leader_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.leader_address)
}
inline std::string* TelemetryData_WpanTopoFull::mutable_leader_address() {
  std::string* _s = _internal_mutable_leader_address();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanTopoFull.leader_address)
  return _s;
}
inline const std::string& TelemetryData_WpanTopoFull::_internal_leader_address() const {
  return _impl_.leader_address_.Get();
}
inline void TelemetryData_WpanTopoFull::_internal_set_leader_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::_internal_mutable_leader_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::release_leader_address() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanTopoFull.leader_address)
  if (!_internal_has_leader_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_address_.IsDefault()) {
    _impl_.leader_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_WpanTopoFull::set_allocated_leader_address(std::string* leader_address) {
  if (leader_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_address_.SetAllocated(leader_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_address_.IsDefault()) {
    _impl_.leader_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanTopoFull.leader_address)
}

// optional uint32 leader_weight = 6;
inline bool TelemetryData_WpanTopoFull::_internal_has_leader_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_leader_weight() const {
  return _internal_has_leader_weight();
}
inline void TelemetryData_WpanTopoFull::clear_leader_weight() {
  _impl_.leader_weight_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_leader_weight() const {
  return _impl_.leader_weight_;
}
inline uint32_t TelemetryData_WpanTopoFull::leader_weight() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.leader_weight)
  return _internal_leader_weight();
}
inline void TelemetryData_WpanTopoFull::_internal_set_leader_weight(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.leader_weight_ = value;
}
inline void TelemetryData_WpanTopoFull::set_leader_weight(uint32_t value) {
  _internal_set_leader_weight(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.leader_weight)
}

// optional uint32 leader_local_weight = 7;
inline bool TelemetryData_WpanTopoFull::_internal_has_leader_local_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_leader_local_weight() const {
  return _internal_has_leader_local_weight();
}
inline void TelemetryData_WpanTopoFull::clear_leader_local_weight() {
  _impl_.leader_local_weight_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_leader_local_weight() const {
  return _impl_.leader_local_weight_;
}
inline uint32_t TelemetryData_WpanTopoFull::leader_local_weight() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.leader_local_weight)
  return _internal_leader_local_weight();
}
inline void TelemetryData_WpanTopoFull::_internal_set_leader_local_weight(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.leader_local_weight_ = value;
}
inline void TelemetryData_WpanTopoFull::set_leader_local_weight(uint32_t value) {
  _internal_set_leader_local_weight(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.leader_local_weight)
}

// optional bytes network_data = 8;
inline bool TelemetryData_WpanTopoFull::_internal_has_network_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_network_data() const {
  return _internal_has_network_data();
}
inline void TelemetryData_WpanTopoFull::clear_network_data() {
  _impl_.network_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TelemetryData_WpanTopoFull::network_data() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.network_data)
  return _internal_network_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_WpanTopoFull::set_network_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.network_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.network_data)
}
inline std::string* TelemetryData_WpanTopoFull::mutable_network_data() {
  std::string* _s = _internal_mutable_network_data();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanTopoFull.network_data)
  return _s;
}
inline const std::string& TelemetryData_WpanTopoFull::_internal_network_data() const {
  return _impl_.network_data_.Get();
}
inline void TelemetryData_WpanTopoFull::_internal_set_network_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.network_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::_internal_mutable_network_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.network_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::release_network_data() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanTopoFull.network_data)
  if (!_internal_has_network_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.network_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_data_.IsDefault()) {
    _impl_.network_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_WpanTopoFull::set_allocated_network_data(std::string* network_data) {
  if (network_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.network_data_.SetAllocated(network_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_data_.IsDefault()) {
    _impl_.network_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanTopoFull.network_data)
}

// optional uint32 network_data_version = 9;
inline bool TelemetryData_WpanTopoFull::_internal_has_network_data_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_network_data_version() const {
  return _internal_has_network_data_version();
}
inline void TelemetryData_WpanTopoFull::clear_network_data_version() {
  _impl_.network_data_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_network_data_version() const {
  return _impl_.network_data_version_;
}
inline uint32_t TelemetryData_WpanTopoFull::network_data_version() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.network_data_version)
  return _internal_network_data_version();
}
inline void TelemetryData_WpanTopoFull::_internal_set_network_data_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.network_data_version_ = value;
}
inline void TelemetryData_WpanTopoFull::set_network_data_version(uint32_t value) {
  _internal_set_network_data_version(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.network_data_version)
}

// optional bytes stable_network_data = 10;
inline bool TelemetryData_WpanTopoFull::_internal_has_stable_network_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_stable_network_data() const {
  return _internal_has_stable_network_data();
}
inline void TelemetryData_WpanTopoFull::clear_stable_network_data() {
  _impl_.stable_network_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TelemetryData_WpanTopoFull::stable_network_data() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data)
  return _internal_stable_network_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_WpanTopoFull::set_stable_network_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.stable_network_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data)
}
inline std::string* TelemetryData_WpanTopoFull::mutable_stable_network_data() {
  std::string* _s = _internal_mutable_stable_network_data();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data)
  return _s;
}
inline const std::string& TelemetryData_WpanTopoFull::_internal_stable_network_data() const {
  return _impl_.stable_network_data_.Get();
}
inline void TelemetryData_WpanTopoFull::_internal_set_stable_network_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stable_network_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::_internal_mutable_stable_network_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stable_network_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanTopoFull::release_stable_network_data() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data)
  if (!_internal_has_stable_network_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.stable_network_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stable_network_data_.IsDefault()) {
    _impl_.stable_network_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_WpanTopoFull::set_allocated_stable_network_data(std::string* stable_network_data) {
  if (stable_network_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stable_network_data_.SetAllocated(stable_network_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stable_network_data_.IsDefault()) {
    _impl_.stable_network_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data)
}

// optional uint32 stable_network_data_version = 11;
inline bool TelemetryData_WpanTopoFull::_internal_has_stable_network_data_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_stable_network_data_version() const {
  return _internal_has_stable_network_data_version();
}
inline void TelemetryData_WpanTopoFull::clear_stable_network_data_version() {
  _impl_.stable_network_data_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_stable_network_data_version() const {
  return _impl_.stable_network_data_version_;
}
inline uint32_t TelemetryData_WpanTopoFull::stable_network_data_version() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data_version)
  return _internal_stable_network_data_version();
}
inline void TelemetryData_WpanTopoFull::_internal_set_stable_network_data_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.stable_network_data_version_ = value;
}
inline void TelemetryData_WpanTopoFull::set_stable_network_data_version(uint32_t value) {
  _internal_set_stable_network_data_version(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.stable_network_data_version)
}

// optional uint32 preferred_router_id = 12;
inline bool TelemetryData_WpanTopoFull::_internal_has_preferred_router_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_preferred_router_id() const {
  return _internal_has_preferred_router_id();
}
inline void TelemetryData_WpanTopoFull::clear_preferred_router_id() {
  _impl_.preferred_router_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_preferred_router_id() const {
  return _impl_.preferred_router_id_;
}
inline uint32_t TelemetryData_WpanTopoFull::preferred_router_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.preferred_router_id)
  return _internal_preferred_router_id();
}
inline void TelemetryData_WpanTopoFull::_internal_set_preferred_router_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.preferred_router_id_ = value;
}
inline void TelemetryData_WpanTopoFull::set_preferred_router_id(uint32_t value) {
  _internal_set_preferred_router_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.preferred_router_id)
}

// optional uint32 partition_id = 13;
inline bool TelemetryData_WpanTopoFull::_internal_has_partition_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void TelemetryData_WpanTopoFull::clear_partition_id() {
  _impl_.partition_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_partition_id() const {
  return _impl_.partition_id_;
}
inline uint32_t TelemetryData_WpanTopoFull::partition_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.partition_id)
  return _internal_partition_id();
}
inline void TelemetryData_WpanTopoFull::_internal_set_partition_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.partition_id_ = value;
}
inline void TelemetryData_WpanTopoFull::set_partition_id(uint32_t value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.partition_id)
}

// optional uint32 child_table_size = 14;
inline bool TelemetryData_WpanTopoFull::_internal_has_child_table_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_child_table_size() const {
  return _internal_has_child_table_size();
}
inline void TelemetryData_WpanTopoFull::clear_child_table_size() {
  _impl_.child_table_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_child_table_size() const {
  return _impl_.child_table_size_;
}
inline uint32_t TelemetryData_WpanTopoFull::child_table_size() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.child_table_size)
  return _internal_child_table_size();
}
inline void TelemetryData_WpanTopoFull::_internal_set_child_table_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.child_table_size_ = value;
}
inline void TelemetryData_WpanTopoFull::set_child_table_size(uint32_t value) {
  _internal_set_child_table_size(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.child_table_size)
}

// optional uint32 neighbor_table_size = 15;
inline bool TelemetryData_WpanTopoFull::_internal_has_neighbor_table_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_neighbor_table_size() const {
  return _internal_has_neighbor_table_size();
}
inline void TelemetryData_WpanTopoFull::clear_neighbor_table_size() {
  _impl_.neighbor_table_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t TelemetryData_WpanTopoFull::_internal_neighbor_table_size() const {
  return _impl_.neighbor_table_size_;
}
inline uint32_t TelemetryData_WpanTopoFull::neighbor_table_size() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.neighbor_table_size)
  return _internal_neighbor_table_size();
}
inline void TelemetryData_WpanTopoFull::_internal_set_neighbor_table_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.neighbor_table_size_ = value;
}
inline void TelemetryData_WpanTopoFull::set_neighbor_table_size(uint32_t value) {
  _internal_set_neighbor_table_size(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.neighbor_table_size)
}

// optional int32 instant_rssi = 16;
inline bool TelemetryData_WpanTopoFull::_internal_has_instant_rssi() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_instant_rssi() const {
  return _internal_has_instant_rssi();
}
inline void TelemetryData_WpanTopoFull::clear_instant_rssi() {
  _impl_.instant_rssi_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t TelemetryData_WpanTopoFull::_internal_instant_rssi() const {
  return _impl_.instant_rssi_;
}
inline int32_t TelemetryData_WpanTopoFull::instant_rssi() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.instant_rssi)
  return _internal_instant_rssi();
}
inline void TelemetryData_WpanTopoFull::_internal_set_instant_rssi(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.instant_rssi_ = value;
}
inline void TelemetryData_WpanTopoFull::set_instant_rssi(int32_t value) {
  _internal_set_instant_rssi(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.instant_rssi)
}

// optional uint64 extended_pan_id = 17;
inline bool TelemetryData_WpanTopoFull::_internal_has_extended_pan_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TelemetryData_WpanTopoFull::has_extended_pan_id() const {
  return _internal_has_extended_pan_id();
}
inline void TelemetryData_WpanTopoFull::clear_extended_pan_id() {
  _impl_.extended_pan_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint64_t TelemetryData_WpanTopoFull::_internal_extended_pan_id() const {
  return _impl_.extended_pan_id_;
}
inline uint64_t TelemetryData_WpanTopoFull::extended_pan_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanTopoFull.extended_pan_id)
  return _internal_extended_pan_id();
}
inline void TelemetryData_WpanTopoFull::_internal_set_extended_pan_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.extended_pan_id_ = value;
}
inline void TelemetryData_WpanTopoFull::set_extended_pan_id(uint64_t value) {
  _internal_set_extended_pan_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanTopoFull.extended_pan_id)
}

// -------------------------------------------------------------------

// TelemetryData_TopoEntry

// optional uint32 rloc16 = 2;
inline bool TelemetryData_TopoEntry::_internal_has_rloc16() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_rloc16() const {
  return _internal_has_rloc16();
}
inline void TelemetryData_TopoEntry::clear_rloc16() {
  _impl_.rloc16_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_TopoEntry::_internal_rloc16() const {
  return _impl_.rloc16_;
}
inline uint32_t TelemetryData_TopoEntry::rloc16() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.rloc16)
  return _internal_rloc16();
}
inline void TelemetryData_TopoEntry::_internal_set_rloc16(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rloc16_ = value;
}
inline void TelemetryData_TopoEntry::set_rloc16(uint32_t value) {
  _internal_set_rloc16(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.rloc16)
}

// optional uint32 link_quality_in = 3;
inline bool TelemetryData_TopoEntry::_internal_has_link_quality_in() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_link_quality_in() const {
  return _internal_has_link_quality_in();
}
inline void TelemetryData_TopoEntry::clear_link_quality_in() {
  _impl_.link_quality_in_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_TopoEntry::_internal_link_quality_in() const {
  return _impl_.link_quality_in_;
}
inline uint32_t TelemetryData_TopoEntry::link_quality_in() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.link_quality_in)
  return _internal_link_quality_in();
}
inline void TelemetryData_TopoEntry::_internal_set_link_quality_in(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.link_quality_in_ = value;
}
inline void TelemetryData_TopoEntry::set_link_quality_in(uint32_t value) {
  _internal_set_link_quality_in(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.link_quality_in)
}

// optional int32 average_rssi = 4;
inline bool TelemetryData_TopoEntry::_internal_has_average_rssi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_average_rssi() const {
  return _internal_has_average_rssi();
}
inline void TelemetryData_TopoEntry::clear_average_rssi() {
  _impl_.average_rssi_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TelemetryData_TopoEntry::_internal_average_rssi() const {
  return _impl_.average_rssi_;
}
inline int32_t TelemetryData_TopoEntry::average_rssi() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.average_rssi)
  return _internal_average_rssi();
}
inline void TelemetryData_TopoEntry::_internal_set_average_rssi(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.average_rssi_ = value;
}
inline void TelemetryData_TopoEntry::set_average_rssi(int32_t value) {
  _internal_set_average_rssi(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.average_rssi)
}

// optional .threadnetwork.TelemetryData.Duration age = 5;
inline bool TelemetryData_TopoEntry::_internal_has_age() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.age_ != nullptr);
  return value;
}
inline bool TelemetryData_TopoEntry::has_age() const {
  return _internal_has_age();
}
inline void TelemetryData_TopoEntry::clear_age() {
  if (_impl_.age_ != nullptr) _impl_.age_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_Duration& TelemetryData_TopoEntry::_internal_age() const {
  const ::threadnetwork::TelemetryData_Duration* p = _impl_.age_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Duration&>(
      ::threadnetwork::_TelemetryData_Duration_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Duration& TelemetryData_TopoEntry::age() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.age)
  return _internal_age();
}
inline void TelemetryData_TopoEntry::unsafe_arena_set_allocated_age(
    ::threadnetwork::TelemetryData_Duration* age) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.age_);
  }
  _impl_.age_ = age;
  if (age) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.TopoEntry.age)
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::release_age() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Duration* temp = _impl_.age_;
  _impl_.age_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::unsafe_arena_release_age() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.TopoEntry.age)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Duration* temp = _impl_.age_;
  _impl_.age_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::_internal_mutable_age() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.age_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Duration>(GetArenaForAllocation());
    _impl_.age_ = p;
  }
  return _impl_.age_;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::mutable_age() {
  ::threadnetwork::TelemetryData_Duration* _msg = _internal_mutable_age();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.TopoEntry.age)
  return _msg;
}
inline void TelemetryData_TopoEntry::set_allocated_age(::threadnetwork::TelemetryData_Duration* age) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.age_;
  }
  if (age) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(age);
    if (message_arena != submessage_arena) {
      age = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, age, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.age_ = age;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.TopoEntry.age)
}

// optional bool rx_on_when_idle = 6;
inline bool TelemetryData_TopoEntry::_internal_has_rx_on_when_idle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_rx_on_when_idle() const {
  return _internal_has_rx_on_when_idle();
}
inline void TelemetryData_TopoEntry::clear_rx_on_when_idle() {
  _impl_.rx_on_when_idle_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TelemetryData_TopoEntry::_internal_rx_on_when_idle() const {
  return _impl_.rx_on_when_idle_;
}
inline bool TelemetryData_TopoEntry::rx_on_when_idle() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.rx_on_when_idle)
  return _internal_rx_on_when_idle();
}
inline void TelemetryData_TopoEntry::_internal_set_rx_on_when_idle(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.rx_on_when_idle_ = value;
}
inline void TelemetryData_TopoEntry::set_rx_on_when_idle(bool value) {
  _internal_set_rx_on_when_idle(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.rx_on_when_idle)
}

// optional bool full_function = 7;
inline bool TelemetryData_TopoEntry::_internal_has_full_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_full_function() const {
  return _internal_has_full_function();
}
inline void TelemetryData_TopoEntry::clear_full_function() {
  _impl_.full_function_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TelemetryData_TopoEntry::_internal_full_function() const {
  return _impl_.full_function_;
}
inline bool TelemetryData_TopoEntry::full_function() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.full_function)
  return _internal_full_function();
}
inline void TelemetryData_TopoEntry::_internal_set_full_function(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.full_function_ = value;
}
inline void TelemetryData_TopoEntry::set_full_function(bool value) {
  _internal_set_full_function(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.full_function)
}

// optional bool secure_data_request = 8;
inline bool TelemetryData_TopoEntry::_internal_has_secure_data_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_secure_data_request() const {
  return _internal_has_secure_data_request();
}
inline void TelemetryData_TopoEntry::clear_secure_data_request() {
  _impl_.secure_data_request_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool TelemetryData_TopoEntry::_internal_secure_data_request() const {
  return _impl_.secure_data_request_;
}
inline bool TelemetryData_TopoEntry::secure_data_request() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.secure_data_request)
  return _internal_secure_data_request();
}
inline void TelemetryData_TopoEntry::_internal_set_secure_data_request(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.secure_data_request_ = value;
}
inline void TelemetryData_TopoEntry::set_secure_data_request(bool value) {
  _internal_set_secure_data_request(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.secure_data_request)
}

// optional bool full_network_data = 9;
inline bool TelemetryData_TopoEntry::_internal_has_full_network_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_full_network_data() const {
  return _internal_has_full_network_data();
}
inline void TelemetryData_TopoEntry::clear_full_network_data() {
  _impl_.full_network_data_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TelemetryData_TopoEntry::_internal_full_network_data() const {
  return _impl_.full_network_data_;
}
inline bool TelemetryData_TopoEntry::full_network_data() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.full_network_data)
  return _internal_full_network_data();
}
inline void TelemetryData_TopoEntry::_internal_set_full_network_data(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.full_network_data_ = value;
}
inline void TelemetryData_TopoEntry::set_full_network_data(bool value) {
  _internal_set_full_network_data(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.full_network_data)
}

// optional int32 last_rssi = 10;
inline bool TelemetryData_TopoEntry::_internal_has_last_rssi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_last_rssi() const {
  return _internal_has_last_rssi();
}
inline void TelemetryData_TopoEntry::clear_last_rssi() {
  _impl_.last_rssi_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t TelemetryData_TopoEntry::_internal_last_rssi() const {
  return _impl_.last_rssi_;
}
inline int32_t TelemetryData_TopoEntry::last_rssi() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.last_rssi)
  return _internal_last_rssi();
}
inline void TelemetryData_TopoEntry::_internal_set_last_rssi(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.last_rssi_ = value;
}
inline void TelemetryData_TopoEntry::set_last_rssi(int32_t value) {
  _internal_set_last_rssi(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.last_rssi)
}

// optional uint32 link_frame_counter = 11;
inline bool TelemetryData_TopoEntry::_internal_has_link_frame_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_link_frame_counter() const {
  return _internal_has_link_frame_counter();
}
inline void TelemetryData_TopoEntry::clear_link_frame_counter() {
  _impl_.link_frame_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t TelemetryData_TopoEntry::_internal_link_frame_counter() const {
  return _impl_.link_frame_counter_;
}
inline uint32_t TelemetryData_TopoEntry::link_frame_counter() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.link_frame_counter)
  return _internal_link_frame_counter();
}
inline void TelemetryData_TopoEntry::_internal_set_link_frame_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.link_frame_counter_ = value;
}
inline void TelemetryData_TopoEntry::set_link_frame_counter(uint32_t value) {
  _internal_set_link_frame_counter(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.link_frame_counter)
}

// optional uint32 mle_frame_counter = 12;
inline bool TelemetryData_TopoEntry::_internal_has_mle_frame_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_mle_frame_counter() const {
  return _internal_has_mle_frame_counter();
}
inline void TelemetryData_TopoEntry::clear_mle_frame_counter() {
  _impl_.mle_frame_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t TelemetryData_TopoEntry::_internal_mle_frame_counter() const {
  return _impl_.mle_frame_counter_;
}
inline uint32_t TelemetryData_TopoEntry::mle_frame_counter() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.mle_frame_counter)
  return _internal_mle_frame_counter();
}
inline void TelemetryData_TopoEntry::_internal_set_mle_frame_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.mle_frame_counter_ = value;
}
inline void TelemetryData_TopoEntry::set_mle_frame_counter(uint32_t value) {
  _internal_set_mle_frame_counter(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.mle_frame_counter)
}

// optional bool is_child = 13;
inline bool TelemetryData_TopoEntry::_internal_has_is_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_is_child() const {
  return _internal_has_is_child();
}
inline void TelemetryData_TopoEntry::clear_is_child() {
  _impl_.is_child_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool TelemetryData_TopoEntry::_internal_is_child() const {
  return _impl_.is_child_;
}
inline bool TelemetryData_TopoEntry::is_child() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.is_child)
  return _internal_is_child();
}
inline void TelemetryData_TopoEntry::_internal_set_is_child(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.is_child_ = value;
}
inline void TelemetryData_TopoEntry::set_is_child(bool value) {
  _internal_set_is_child(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.is_child)
}

// optional .threadnetwork.TelemetryData.Duration timeout = 14;
inline bool TelemetryData_TopoEntry::_internal_has_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeout_ != nullptr);
  return value;
}
inline bool TelemetryData_TopoEntry::has_timeout() const {
  return _internal_has_timeout();
}
inline void TelemetryData_TopoEntry::clear_timeout() {
  if (_impl_.timeout_ != nullptr) _impl_.timeout_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_Duration& TelemetryData_TopoEntry::_internal_timeout() const {
  const ::threadnetwork::TelemetryData_Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Duration&>(
      ::threadnetwork::_TelemetryData_Duration_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Duration& TelemetryData_TopoEntry::timeout() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.timeout)
  return _internal_timeout();
}
inline void TelemetryData_TopoEntry::unsafe_arena_set_allocated_timeout(
    ::threadnetwork::TelemetryData_Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = timeout;
  if (timeout) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.TopoEntry.timeout)
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::release_timeout() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.TopoEntry.timeout)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::_internal_mutable_timeout() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Duration>(GetArenaForAllocation());
    _impl_.timeout_ = p;
  }
  return _impl_.timeout_;
}
inline ::threadnetwork::TelemetryData_Duration* TelemetryData_TopoEntry::mutable_timeout() {
  ::threadnetwork::TelemetryData_Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.TopoEntry.timeout)
  return _msg;
}
inline void TelemetryData_TopoEntry::set_allocated_timeout(::threadnetwork::TelemetryData_Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timeout_;
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timeout);
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.TopoEntry.timeout)
}

// optional uint32 network_data_version = 15;
inline bool TelemetryData_TopoEntry::_internal_has_network_data_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_network_data_version() const {
  return _internal_has_network_data_version();
}
inline void TelemetryData_TopoEntry::clear_network_data_version() {
  _impl_.network_data_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t TelemetryData_TopoEntry::_internal_network_data_version() const {
  return _impl_.network_data_version_;
}
inline uint32_t TelemetryData_TopoEntry::network_data_version() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.network_data_version)
  return _internal_network_data_version();
}
inline void TelemetryData_TopoEntry::_internal_set_network_data_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.network_data_version_ = value;
}
inline void TelemetryData_TopoEntry::set_network_data_version(uint32_t value) {
  _internal_set_network_data_version(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.network_data_version)
}

// optional float mac_frame_error_rate = 16;
inline bool TelemetryData_TopoEntry::_internal_has_mac_frame_error_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_mac_frame_error_rate() const {
  return _internal_has_mac_frame_error_rate();
}
inline void TelemetryData_TopoEntry::clear_mac_frame_error_rate() {
  _impl_.mac_frame_error_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float TelemetryData_TopoEntry::_internal_mac_frame_error_rate() const {
  return _impl_.mac_frame_error_rate_;
}
inline float TelemetryData_TopoEntry::mac_frame_error_rate() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.mac_frame_error_rate)
  return _internal_mac_frame_error_rate();
}
inline void TelemetryData_TopoEntry::_internal_set_mac_frame_error_rate(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.mac_frame_error_rate_ = value;
}
inline void TelemetryData_TopoEntry::set_mac_frame_error_rate(float value) {
  _internal_set_mac_frame_error_rate(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.mac_frame_error_rate)
}

// optional float ip_message_error_rate = 17;
inline bool TelemetryData_TopoEntry::_internal_has_ip_message_error_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_ip_message_error_rate() const {
  return _internal_has_ip_message_error_rate();
}
inline void TelemetryData_TopoEntry::clear_ip_message_error_rate() {
  _impl_.ip_message_error_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float TelemetryData_TopoEntry::_internal_ip_message_error_rate() const {
  return _impl_.ip_message_error_rate_;
}
inline float TelemetryData_TopoEntry::ip_message_error_rate() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.ip_message_error_rate)
  return _internal_ip_message_error_rate();
}
inline void TelemetryData_TopoEntry::_internal_set_ip_message_error_rate(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.ip_message_error_rate_ = value;
}
inline void TelemetryData_TopoEntry::set_ip_message_error_rate(float value) {
  _internal_set_ip_message_error_rate(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.ip_message_error_rate)
}

// optional int32 version = 18;
inline bool TelemetryData_TopoEntry::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TelemetryData_TopoEntry::has_version() const {
  return _internal_has_version();
}
inline void TelemetryData_TopoEntry::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t TelemetryData_TopoEntry::_internal_version() const {
  return _impl_.version_;
}
inline int32_t TelemetryData_TopoEntry::version() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TopoEntry.version)
  return _internal_version();
}
inline void TelemetryData_TopoEntry::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.version_ = value;
}
inline void TelemetryData_TopoEntry::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TopoEntry.version)
}

// -------------------------------------------------------------------

// TelemetryData_PacketsAndBytes

// optional int64 packet_count = 1;
inline bool TelemetryData_PacketsAndBytes::_internal_has_packet_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_PacketsAndBytes::has_packet_count() const {
  return _internal_has_packet_count();
}
inline void TelemetryData_PacketsAndBytes::clear_packet_count() {
  _impl_.packet_count_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TelemetryData_PacketsAndBytes::_internal_packet_count() const {
  return _impl_.packet_count_;
}
inline int64_t TelemetryData_PacketsAndBytes::packet_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.PacketsAndBytes.packet_count)
  return _internal_packet_count();
}
inline void TelemetryData_PacketsAndBytes::_internal_set_packet_count(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.packet_count_ = value;
}
inline void TelemetryData_PacketsAndBytes::set_packet_count(int64_t value) {
  _internal_set_packet_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.PacketsAndBytes.packet_count)
}

// optional int64 byte_count = 2;
inline bool TelemetryData_PacketsAndBytes::_internal_has_byte_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_PacketsAndBytes::has_byte_count() const {
  return _internal_has_byte_count();
}
inline void TelemetryData_PacketsAndBytes::clear_byte_count() {
  _impl_.byte_count_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TelemetryData_PacketsAndBytes::_internal_byte_count() const {
  return _impl_.byte_count_;
}
inline int64_t TelemetryData_PacketsAndBytes::byte_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.PacketsAndBytes.byte_count)
  return _internal_byte_count();
}
inline void TelemetryData_PacketsAndBytes::_internal_set_byte_count(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.byte_count_ = value;
}
inline void TelemetryData_PacketsAndBytes::set_byte_count(int64_t value) {
  _internal_set_byte_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.PacketsAndBytes.byte_count)
}

// -------------------------------------------------------------------

// TelemetryData_Nat64TrafficCounters

// optional int64 ipv4_to_ipv6_packets = 1;
inline bool TelemetryData_Nat64TrafficCounters::_internal_has_ipv4_to_ipv6_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_Nat64TrafficCounters::has_ipv4_to_ipv6_packets() const {
  return _internal_has_ipv4_to_ipv6_packets();
}
inline void TelemetryData_Nat64TrafficCounters::clear_ipv4_to_ipv6_packets() {
  _impl_.ipv4_to_ipv6_packets_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TelemetryData_Nat64TrafficCounters::_internal_ipv4_to_ipv6_packets() const {
  return _impl_.ipv4_to_ipv6_packets_;
}
inline int64_t TelemetryData_Nat64TrafficCounters::ipv4_to_ipv6_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv4_to_ipv6_packets)
  return _internal_ipv4_to_ipv6_packets();
}
inline void TelemetryData_Nat64TrafficCounters::_internal_set_ipv4_to_ipv6_packets(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ipv4_to_ipv6_packets_ = value;
}
inline void TelemetryData_Nat64TrafficCounters::set_ipv4_to_ipv6_packets(int64_t value) {
  _internal_set_ipv4_to_ipv6_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv4_to_ipv6_packets)
}

// optional int64 ipv4_to_ipv6_bytes = 2;
inline bool TelemetryData_Nat64TrafficCounters::_internal_has_ipv4_to_ipv6_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_Nat64TrafficCounters::has_ipv4_to_ipv6_bytes() const {
  return _internal_has_ipv4_to_ipv6_bytes();
}
inline void TelemetryData_Nat64TrafficCounters::clear_ipv4_to_ipv6_bytes() {
  _impl_.ipv4_to_ipv6_bytes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TelemetryData_Nat64TrafficCounters::_internal_ipv4_to_ipv6_bytes() const {
  return _impl_.ipv4_to_ipv6_bytes_;
}
inline int64_t TelemetryData_Nat64TrafficCounters::ipv4_to_ipv6_bytes() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv4_to_ipv6_bytes)
  return _internal_ipv4_to_ipv6_bytes();
}
inline void TelemetryData_Nat64TrafficCounters::_internal_set_ipv4_to_ipv6_bytes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ipv4_to_ipv6_bytes_ = value;
}
inline void TelemetryData_Nat64TrafficCounters::set_ipv4_to_ipv6_bytes(int64_t value) {
  _internal_set_ipv4_to_ipv6_bytes(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv4_to_ipv6_bytes)
}

// optional int64 ipv6_to_ipv4_packets = 3;
inline bool TelemetryData_Nat64TrafficCounters::_internal_has_ipv6_to_ipv4_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_Nat64TrafficCounters::has_ipv6_to_ipv4_packets() const {
  return _internal_has_ipv6_to_ipv4_packets();
}
inline void TelemetryData_Nat64TrafficCounters::clear_ipv6_to_ipv4_packets() {
  _impl_.ipv6_to_ipv4_packets_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t TelemetryData_Nat64TrafficCounters::_internal_ipv6_to_ipv4_packets() const {
  return _impl_.ipv6_to_ipv4_packets_;
}
inline int64_t TelemetryData_Nat64TrafficCounters::ipv6_to_ipv4_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv6_to_ipv4_packets)
  return _internal_ipv6_to_ipv4_packets();
}
inline void TelemetryData_Nat64TrafficCounters::_internal_set_ipv6_to_ipv4_packets(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ipv6_to_ipv4_packets_ = value;
}
inline void TelemetryData_Nat64TrafficCounters::set_ipv6_to_ipv4_packets(int64_t value) {
  _internal_set_ipv6_to_ipv4_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv6_to_ipv4_packets)
}

// optional int64 ipv6_to_ipv4_bytes = 4;
inline bool TelemetryData_Nat64TrafficCounters::_internal_has_ipv6_to_ipv4_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_Nat64TrafficCounters::has_ipv6_to_ipv4_bytes() const {
  return _internal_has_ipv6_to_ipv4_bytes();
}
inline void TelemetryData_Nat64TrafficCounters::clear_ipv6_to_ipv4_bytes() {
  _impl_.ipv6_to_ipv4_bytes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t TelemetryData_Nat64TrafficCounters::_internal_ipv6_to_ipv4_bytes() const {
  return _impl_.ipv6_to_ipv4_bytes_;
}
inline int64_t TelemetryData_Nat64TrafficCounters::ipv6_to_ipv4_bytes() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv6_to_ipv4_bytes)
  return _internal_ipv6_to_ipv4_bytes();
}
inline void TelemetryData_Nat64TrafficCounters::_internal_set_ipv6_to_ipv4_bytes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ipv6_to_ipv4_bytes_ = value;
}
inline void TelemetryData_Nat64TrafficCounters::set_ipv6_to_ipv4_bytes(int64_t value) {
  _internal_set_ipv6_to_ipv4_bytes(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64TrafficCounters.ipv6_to_ipv4_bytes)
}

// -------------------------------------------------------------------

// TelemetryData_Nat64ProtocolCounters

// optional .threadnetwork.TelemetryData.Nat64TrafficCounters tcp = 1;
inline bool TelemetryData_Nat64ProtocolCounters::_internal_has_tcp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tcp_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ProtocolCounters::has_tcp() const {
  return _internal_has_tcp();
}
inline void TelemetryData_Nat64ProtocolCounters::clear_tcp() {
  if (_impl_.tcp_ != nullptr) _impl_.tcp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::_internal_tcp() const {
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters* p = _impl_.tcp_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64TrafficCounters&>(
      ::threadnetwork::_TelemetryData_Nat64TrafficCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::tcp() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ProtocolCounters.tcp)
  return _internal_tcp();
}
inline void TelemetryData_Nat64ProtocolCounters::unsafe_arena_set_allocated_tcp(
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* tcp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tcp_);
  }
  _impl_.tcp_ = tcp;
  if (tcp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.tcp)
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::release_tcp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ProtocolCounters.tcp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::_internal_mutable_tcp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64TrafficCounters>(GetArenaForAllocation());
    _impl_.tcp_ = p;
  }
  return _impl_.tcp_;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::mutable_tcp() {
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ProtocolCounters.tcp)
  return _msg;
}
inline void TelemetryData_Nat64ProtocolCounters::set_allocated_tcp(::threadnetwork::TelemetryData_Nat64TrafficCounters* tcp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tcp_;
  }
  if (tcp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.tcp)
}

// optional .threadnetwork.TelemetryData.Nat64TrafficCounters udp = 2;
inline bool TelemetryData_Nat64ProtocolCounters::_internal_has_udp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.udp_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ProtocolCounters::has_udp() const {
  return _internal_has_udp();
}
inline void TelemetryData_Nat64ProtocolCounters::clear_udp() {
  if (_impl_.udp_ != nullptr) _impl_.udp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::_internal_udp() const {
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters* p = _impl_.udp_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64TrafficCounters&>(
      ::threadnetwork::_TelemetryData_Nat64TrafficCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::udp() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ProtocolCounters.udp)
  return _internal_udp();
}
inline void TelemetryData_Nat64ProtocolCounters::unsafe_arena_set_allocated_udp(
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* udp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.udp_);
  }
  _impl_.udp_ = udp;
  if (udp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.udp)
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::release_udp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.udp_;
  _impl_.udp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::unsafe_arena_release_udp() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ProtocolCounters.udp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.udp_;
  _impl_.udp_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::_internal_mutable_udp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.udp_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64TrafficCounters>(GetArenaForAllocation());
    _impl_.udp_ = p;
  }
  return _impl_.udp_;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::mutable_udp() {
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _msg = _internal_mutable_udp();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ProtocolCounters.udp)
  return _msg;
}
inline void TelemetryData_Nat64ProtocolCounters::set_allocated_udp(::threadnetwork::TelemetryData_Nat64TrafficCounters* udp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.udp_;
  }
  if (udp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(udp);
    if (message_arena != submessage_arena) {
      udp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, udp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.udp_ = udp;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.udp)
}

// optional .threadnetwork.TelemetryData.Nat64TrafficCounters icmp = 3;
inline bool TelemetryData_Nat64ProtocolCounters::_internal_has_icmp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.icmp_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ProtocolCounters::has_icmp() const {
  return _internal_has_icmp();
}
inline void TelemetryData_Nat64ProtocolCounters::clear_icmp() {
  if (_impl_.icmp_ != nullptr) _impl_.icmp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::_internal_icmp() const {
  const ::threadnetwork::TelemetryData_Nat64TrafficCounters* p = _impl_.icmp_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64TrafficCounters&>(
      ::threadnetwork::_TelemetryData_Nat64TrafficCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64TrafficCounters& TelemetryData_Nat64ProtocolCounters::icmp() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ProtocolCounters.icmp)
  return _internal_icmp();
}
inline void TelemetryData_Nat64ProtocolCounters::unsafe_arena_set_allocated_icmp(
    ::threadnetwork::TelemetryData_Nat64TrafficCounters* icmp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.icmp_);
  }
  _impl_.icmp_ = icmp;
  if (icmp) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.icmp)
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::release_icmp() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.icmp_;
  _impl_.icmp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::unsafe_arena_release_icmp() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ProtocolCounters.icmp)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* temp = _impl_.icmp_;
  _impl_.icmp_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::_internal_mutable_icmp() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.icmp_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64TrafficCounters>(GetArenaForAllocation());
    _impl_.icmp_ = p;
  }
  return _impl_.icmp_;
}
inline ::threadnetwork::TelemetryData_Nat64TrafficCounters* TelemetryData_Nat64ProtocolCounters::mutable_icmp() {
  ::threadnetwork::TelemetryData_Nat64TrafficCounters* _msg = _internal_mutable_icmp();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ProtocolCounters.icmp)
  return _msg;
}
inline void TelemetryData_Nat64ProtocolCounters::set_allocated_icmp(::threadnetwork::TelemetryData_Nat64TrafficCounters* icmp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.icmp_;
  }
  if (icmp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(icmp);
    if (message_arena != submessage_arena) {
      icmp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, icmp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.icmp_ = icmp;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ProtocolCounters.icmp)
}

// -------------------------------------------------------------------

// TelemetryData_Nat64PacketCounters

// optional int64 ipv4_to_ipv6_packets = 1;
inline bool TelemetryData_Nat64PacketCounters::_internal_has_ipv4_to_ipv6_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_Nat64PacketCounters::has_ipv4_to_ipv6_packets() const {
  return _internal_has_ipv4_to_ipv6_packets();
}
inline void TelemetryData_Nat64PacketCounters::clear_ipv4_to_ipv6_packets() {
  _impl_.ipv4_to_ipv6_packets_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TelemetryData_Nat64PacketCounters::_internal_ipv4_to_ipv6_packets() const {
  return _impl_.ipv4_to_ipv6_packets_;
}
inline int64_t TelemetryData_Nat64PacketCounters::ipv4_to_ipv6_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64PacketCounters.ipv4_to_ipv6_packets)
  return _internal_ipv4_to_ipv6_packets();
}
inline void TelemetryData_Nat64PacketCounters::_internal_set_ipv4_to_ipv6_packets(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ipv4_to_ipv6_packets_ = value;
}
inline void TelemetryData_Nat64PacketCounters::set_ipv4_to_ipv6_packets(int64_t value) {
  _internal_set_ipv4_to_ipv6_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64PacketCounters.ipv4_to_ipv6_packets)
}

// optional int64 ipv6_to_ipv4_packets = 2;
inline bool TelemetryData_Nat64PacketCounters::_internal_has_ipv6_to_ipv4_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_Nat64PacketCounters::has_ipv6_to_ipv4_packets() const {
  return _internal_has_ipv6_to_ipv4_packets();
}
inline void TelemetryData_Nat64PacketCounters::clear_ipv6_to_ipv4_packets() {
  _impl_.ipv6_to_ipv4_packets_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TelemetryData_Nat64PacketCounters::_internal_ipv6_to_ipv4_packets() const {
  return _impl_.ipv6_to_ipv4_packets_;
}
inline int64_t TelemetryData_Nat64PacketCounters::ipv6_to_ipv4_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64PacketCounters.ipv6_to_ipv4_packets)
  return _internal_ipv6_to_ipv4_packets();
}
inline void TelemetryData_Nat64PacketCounters::_internal_set_ipv6_to_ipv4_packets(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ipv6_to_ipv4_packets_ = value;
}
inline void TelemetryData_Nat64PacketCounters::set_ipv6_to_ipv4_packets(int64_t value) {
  _internal_set_ipv6_to_ipv4_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64PacketCounters.ipv6_to_ipv4_packets)
}

// -------------------------------------------------------------------

// TelemetryData_Nat64ErrorCounters

// optional .threadnetwork.TelemetryData.Nat64PacketCounters unknown = 1;
inline bool TelemetryData_Nat64ErrorCounters::_internal_has_unknown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unknown_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ErrorCounters::has_unknown() const {
  return _internal_has_unknown();
}
inline void TelemetryData_Nat64ErrorCounters::clear_unknown() {
  if (_impl_.unknown_ != nullptr) _impl_.unknown_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::_internal_unknown() const {
  const ::threadnetwork::TelemetryData_Nat64PacketCounters* p = _impl_.unknown_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64PacketCounters&>(
      ::threadnetwork::_TelemetryData_Nat64PacketCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::unknown() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ErrorCounters.unknown)
  return _internal_unknown();
}
inline void TelemetryData_Nat64ErrorCounters::unsafe_arena_set_allocated_unknown(
    ::threadnetwork::TelemetryData_Nat64PacketCounters* unknown) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unknown_);
  }
  _impl_.unknown_ = unknown;
  if (unknown) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.unknown)
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::release_unknown() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.unknown_;
  _impl_.unknown_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::unsafe_arena_release_unknown() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ErrorCounters.unknown)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.unknown_;
  _impl_.unknown_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::_internal_mutable_unknown() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.unknown_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64PacketCounters>(GetArenaForAllocation());
    _impl_.unknown_ = p;
  }
  return _impl_.unknown_;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::mutable_unknown() {
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _msg = _internal_mutable_unknown();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ErrorCounters.unknown)
  return _msg;
}
inline void TelemetryData_Nat64ErrorCounters::set_allocated_unknown(::threadnetwork::TelemetryData_Nat64PacketCounters* unknown) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unknown_;
  }
  if (unknown) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unknown);
    if (message_arena != submessage_arena) {
      unknown = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unknown, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unknown_ = unknown;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.unknown)
}

// optional .threadnetwork.TelemetryData.Nat64PacketCounters illegal_packet = 2;
inline bool TelemetryData_Nat64ErrorCounters::_internal_has_illegal_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.illegal_packet_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ErrorCounters::has_illegal_packet() const {
  return _internal_has_illegal_packet();
}
inline void TelemetryData_Nat64ErrorCounters::clear_illegal_packet() {
  if (_impl_.illegal_packet_ != nullptr) _impl_.illegal_packet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::_internal_illegal_packet() const {
  const ::threadnetwork::TelemetryData_Nat64PacketCounters* p = _impl_.illegal_packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64PacketCounters&>(
      ::threadnetwork::_TelemetryData_Nat64PacketCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::illegal_packet() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ErrorCounters.illegal_packet)
  return _internal_illegal_packet();
}
inline void TelemetryData_Nat64ErrorCounters::unsafe_arena_set_allocated_illegal_packet(
    ::threadnetwork::TelemetryData_Nat64PacketCounters* illegal_packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.illegal_packet_);
  }
  _impl_.illegal_packet_ = illegal_packet;
  if (illegal_packet) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.illegal_packet)
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::release_illegal_packet() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.illegal_packet_;
  _impl_.illegal_packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::unsafe_arena_release_illegal_packet() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ErrorCounters.illegal_packet)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.illegal_packet_;
  _impl_.illegal_packet_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::_internal_mutable_illegal_packet() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.illegal_packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64PacketCounters>(GetArenaForAllocation());
    _impl_.illegal_packet_ = p;
  }
  return _impl_.illegal_packet_;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::mutable_illegal_packet() {
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _msg = _internal_mutable_illegal_packet();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ErrorCounters.illegal_packet)
  return _msg;
}
inline void TelemetryData_Nat64ErrorCounters::set_allocated_illegal_packet(::threadnetwork::TelemetryData_Nat64PacketCounters* illegal_packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.illegal_packet_;
  }
  if (illegal_packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(illegal_packet);
    if (message_arena != submessage_arena) {
      illegal_packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, illegal_packet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.illegal_packet_ = illegal_packet;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.illegal_packet)
}

// optional .threadnetwork.TelemetryData.Nat64PacketCounters unsupported_protocol = 3;
inline bool TelemetryData_Nat64ErrorCounters::_internal_has_unsupported_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unsupported_protocol_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ErrorCounters::has_unsupported_protocol() const {
  return _internal_has_unsupported_protocol();
}
inline void TelemetryData_Nat64ErrorCounters::clear_unsupported_protocol() {
  if (_impl_.unsupported_protocol_ != nullptr) _impl_.unsupported_protocol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::_internal_unsupported_protocol() const {
  const ::threadnetwork::TelemetryData_Nat64PacketCounters* p = _impl_.unsupported_protocol_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64PacketCounters&>(
      ::threadnetwork::_TelemetryData_Nat64PacketCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::unsupported_protocol() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ErrorCounters.unsupported_protocol)
  return _internal_unsupported_protocol();
}
inline void TelemetryData_Nat64ErrorCounters::unsafe_arena_set_allocated_unsupported_protocol(
    ::threadnetwork::TelemetryData_Nat64PacketCounters* unsupported_protocol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unsupported_protocol_);
  }
  _impl_.unsupported_protocol_ = unsupported_protocol;
  if (unsupported_protocol) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.unsupported_protocol)
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::release_unsupported_protocol() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.unsupported_protocol_;
  _impl_.unsupported_protocol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::unsafe_arena_release_unsupported_protocol() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ErrorCounters.unsupported_protocol)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.unsupported_protocol_;
  _impl_.unsupported_protocol_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::_internal_mutable_unsupported_protocol() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.unsupported_protocol_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64PacketCounters>(GetArenaForAllocation());
    _impl_.unsupported_protocol_ = p;
  }
  return _impl_.unsupported_protocol_;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::mutable_unsupported_protocol() {
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _msg = _internal_mutable_unsupported_protocol();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ErrorCounters.unsupported_protocol)
  return _msg;
}
inline void TelemetryData_Nat64ErrorCounters::set_allocated_unsupported_protocol(::threadnetwork::TelemetryData_Nat64PacketCounters* unsupported_protocol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unsupported_protocol_;
  }
  if (unsupported_protocol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unsupported_protocol);
    if (message_arena != submessage_arena) {
      unsupported_protocol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unsupported_protocol, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unsupported_protocol_ = unsupported_protocol;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.unsupported_protocol)
}

// optional .threadnetwork.TelemetryData.Nat64PacketCounters no_mapping = 4;
inline bool TelemetryData_Nat64ErrorCounters::_internal_has_no_mapping() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.no_mapping_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64ErrorCounters::has_no_mapping() const {
  return _internal_has_no_mapping();
}
inline void TelemetryData_Nat64ErrorCounters::clear_no_mapping() {
  if (_impl_.no_mapping_ != nullptr) _impl_.no_mapping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::_internal_no_mapping() const {
  const ::threadnetwork::TelemetryData_Nat64PacketCounters* p = _impl_.no_mapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64PacketCounters&>(
      ::threadnetwork::_TelemetryData_Nat64PacketCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64PacketCounters& TelemetryData_Nat64ErrorCounters::no_mapping() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64ErrorCounters.no_mapping)
  return _internal_no_mapping();
}
inline void TelemetryData_Nat64ErrorCounters::unsafe_arena_set_allocated_no_mapping(
    ::threadnetwork::TelemetryData_Nat64PacketCounters* no_mapping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.no_mapping_);
  }
  _impl_.no_mapping_ = no_mapping;
  if (no_mapping) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.no_mapping)
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::release_no_mapping() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.no_mapping_;
  _impl_.no_mapping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::unsafe_arena_release_no_mapping() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64ErrorCounters.no_mapping)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_Nat64PacketCounters* temp = _impl_.no_mapping_;
  _impl_.no_mapping_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::_internal_mutable_no_mapping() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.no_mapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64PacketCounters>(GetArenaForAllocation());
    _impl_.no_mapping_ = p;
  }
  return _impl_.no_mapping_;
}
inline ::threadnetwork::TelemetryData_Nat64PacketCounters* TelemetryData_Nat64ErrorCounters::mutable_no_mapping() {
  ::threadnetwork::TelemetryData_Nat64PacketCounters* _msg = _internal_mutable_no_mapping();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64ErrorCounters.no_mapping)
  return _msg;
}
inline void TelemetryData_Nat64ErrorCounters::set_allocated_no_mapping(::threadnetwork::TelemetryData_Nat64PacketCounters* no_mapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.no_mapping_;
  }
  if (no_mapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(no_mapping);
    if (message_arena != submessage_arena) {
      no_mapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, no_mapping, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.no_mapping_ = no_mapping;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64ErrorCounters.no_mapping)
}

// -------------------------------------------------------------------

// TelemetryData_BorderRoutingCounters

// optional int64 ra_rx = 9;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_ra_rx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_ra_rx() const {
  return _internal_has_ra_rx();
}
inline void TelemetryData_BorderRoutingCounters::clear_ra_rx() {
  _impl_.ra_rx_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_ra_rx() const {
  return _impl_.ra_rx_;
}
inline int64_t TelemetryData_BorderRoutingCounters::ra_rx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.ra_rx)
  return _internal_ra_rx();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_ra_rx(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.ra_rx_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_ra_rx(int64_t value) {
  _internal_set_ra_rx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.ra_rx)
}

// optional int64 ra_tx_success = 10;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_ra_tx_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_ra_tx_success() const {
  return _internal_has_ra_tx_success();
}
inline void TelemetryData_BorderRoutingCounters::clear_ra_tx_success() {
  _impl_.ra_tx_success_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_ra_tx_success() const {
  return _impl_.ra_tx_success_;
}
inline int64_t TelemetryData_BorderRoutingCounters::ra_tx_success() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.ra_tx_success)
  return _internal_ra_tx_success();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_ra_tx_success(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ra_tx_success_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_ra_tx_success(int64_t value) {
  _internal_set_ra_tx_success(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.ra_tx_success)
}

// optional int64 ra_tx_failure = 11;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_ra_tx_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_ra_tx_failure() const {
  return _internal_has_ra_tx_failure();
}
inline void TelemetryData_BorderRoutingCounters::clear_ra_tx_failure() {
  _impl_.ra_tx_failure_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_ra_tx_failure() const {
  return _impl_.ra_tx_failure_;
}
inline int64_t TelemetryData_BorderRoutingCounters::ra_tx_failure() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.ra_tx_failure)
  return _internal_ra_tx_failure();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_ra_tx_failure(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ra_tx_failure_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_ra_tx_failure(int64_t value) {
  _internal_set_ra_tx_failure(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.ra_tx_failure)
}

// optional int64 rs_rx = 12;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_rs_rx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_rs_rx() const {
  return _internal_has_rs_rx();
}
inline void TelemetryData_BorderRoutingCounters::clear_rs_rx() {
  _impl_.rs_rx_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_rs_rx() const {
  return _impl_.rs_rx_;
}
inline int64_t TelemetryData_BorderRoutingCounters::rs_rx() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.rs_rx)
  return _internal_rs_rx();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_rs_rx(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.rs_rx_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_rs_rx(int64_t value) {
  _internal_set_rs_rx(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.rs_rx)
}

// optional int64 rs_tx_success = 13;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_rs_tx_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_rs_tx_success() const {
  return _internal_has_rs_tx_success();
}
inline void TelemetryData_BorderRoutingCounters::clear_rs_tx_success() {
  _impl_.rs_tx_success_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_rs_tx_success() const {
  return _impl_.rs_tx_success_;
}
inline int64_t TelemetryData_BorderRoutingCounters::rs_tx_success() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.rs_tx_success)
  return _internal_rs_tx_success();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_rs_tx_success(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.rs_tx_success_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_rs_tx_success(int64_t value) {
  _internal_set_rs_tx_success(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.rs_tx_success)
}

// optional int64 rs_tx_failure = 14;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_rs_tx_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_rs_tx_failure() const {
  return _internal_has_rs_tx_failure();
}
inline void TelemetryData_BorderRoutingCounters::clear_rs_tx_failure() {
  _impl_.rs_tx_failure_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t TelemetryData_BorderRoutingCounters::_internal_rs_tx_failure() const {
  return _impl_.rs_tx_failure_;
}
inline int64_t TelemetryData_BorderRoutingCounters::rs_tx_failure() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.rs_tx_failure)
  return _internal_rs_tx_failure();
}
inline void TelemetryData_BorderRoutingCounters::_internal_set_rs_tx_failure(int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.rs_tx_failure_ = value;
}
inline void TelemetryData_BorderRoutingCounters::set_rs_tx_failure(int64_t value) {
  _internal_set_rs_tx_failure(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingCounters.rs_tx_failure)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_unicast = 15;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_inbound_unicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inbound_unicast_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_inbound_unicast() const {
  return _internal_has_inbound_unicast();
}
inline void TelemetryData_BorderRoutingCounters::clear_inbound_unicast() {
  if (_impl_.inbound_unicast_ != nullptr) _impl_.inbound_unicast_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_inbound_unicast() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.inbound_unicast_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::inbound_unicast() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_unicast)
  return _internal_inbound_unicast();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_inbound_unicast(
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_unicast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inbound_unicast_);
  }
  _impl_.inbound_unicast_ = inbound_unicast;
  if (inbound_unicast) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_unicast)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_inbound_unicast() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_unicast_;
  _impl_.inbound_unicast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_inbound_unicast() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_unicast)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_unicast_;
  _impl_.inbound_unicast_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_inbound_unicast() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inbound_unicast_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.inbound_unicast_ = p;
  }
  return _impl_.inbound_unicast_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_inbound_unicast() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_inbound_unicast();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_unicast)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_inbound_unicast(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_unicast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inbound_unicast_;
  }
  if (inbound_unicast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inbound_unicast);
    if (message_arena != submessage_arena) {
      inbound_unicast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inbound_unicast, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.inbound_unicast_ = inbound_unicast;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_unicast)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_multicast = 16;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_inbound_multicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inbound_multicast_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_inbound_multicast() const {
  return _internal_has_inbound_multicast();
}
inline void TelemetryData_BorderRoutingCounters::clear_inbound_multicast() {
  if (_impl_.inbound_multicast_ != nullptr) _impl_.inbound_multicast_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_inbound_multicast() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.inbound_multicast_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::inbound_multicast() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_multicast)
  return _internal_inbound_multicast();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_inbound_multicast(
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_multicast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inbound_multicast_);
  }
  _impl_.inbound_multicast_ = inbound_multicast;
  if (inbound_multicast) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_multicast)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_inbound_multicast() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_multicast_;
  _impl_.inbound_multicast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_inbound_multicast() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_multicast)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_multicast_;
  _impl_.inbound_multicast_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_inbound_multicast() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.inbound_multicast_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.inbound_multicast_ = p;
  }
  return _impl_.inbound_multicast_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_inbound_multicast() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_inbound_multicast();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_multicast)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_inbound_multicast(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_multicast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inbound_multicast_;
  }
  if (inbound_multicast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inbound_multicast);
    if (message_arena != submessage_arena) {
      inbound_multicast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inbound_multicast, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.inbound_multicast_ = inbound_multicast;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_multicast)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_unicast = 17;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_outbound_unicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outbound_unicast_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_outbound_unicast() const {
  return _internal_has_outbound_unicast();
}
inline void TelemetryData_BorderRoutingCounters::clear_outbound_unicast() {
  if (_impl_.outbound_unicast_ != nullptr) _impl_.outbound_unicast_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_outbound_unicast() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.outbound_unicast_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::outbound_unicast() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_unicast)
  return _internal_outbound_unicast();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_outbound_unicast(
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_unicast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outbound_unicast_);
  }
  _impl_.outbound_unicast_ = outbound_unicast;
  if (outbound_unicast) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_unicast)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_outbound_unicast() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_unicast_;
  _impl_.outbound_unicast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_outbound_unicast() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_unicast)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_unicast_;
  _impl_.outbound_unicast_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_outbound_unicast() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.outbound_unicast_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.outbound_unicast_ = p;
  }
  return _impl_.outbound_unicast_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_outbound_unicast() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_outbound_unicast();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_unicast)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_outbound_unicast(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_unicast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outbound_unicast_;
  }
  if (outbound_unicast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outbound_unicast);
    if (message_arena != submessage_arena) {
      outbound_unicast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outbound_unicast, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.outbound_unicast_ = outbound_unicast;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_unicast)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_multicast = 18;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_outbound_multicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outbound_multicast_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_outbound_multicast() const {
  return _internal_has_outbound_multicast();
}
inline void TelemetryData_BorderRoutingCounters::clear_outbound_multicast() {
  if (_impl_.outbound_multicast_ != nullptr) _impl_.outbound_multicast_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_outbound_multicast() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.outbound_multicast_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::outbound_multicast() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_multicast)
  return _internal_outbound_multicast();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_outbound_multicast(
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_multicast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outbound_multicast_);
  }
  _impl_.outbound_multicast_ = outbound_multicast;
  if (outbound_multicast) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_multicast)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_outbound_multicast() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_multicast_;
  _impl_.outbound_multicast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_outbound_multicast() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_multicast)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_multicast_;
  _impl_.outbound_multicast_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_outbound_multicast() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.outbound_multicast_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.outbound_multicast_ = p;
  }
  return _impl_.outbound_multicast_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_outbound_multicast() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_outbound_multicast();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_multicast)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_outbound_multicast(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_multicast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outbound_multicast_;
  }
  if (outbound_multicast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outbound_multicast);
    if (message_arena != submessage_arena) {
      outbound_multicast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outbound_multicast, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.outbound_multicast_ = outbound_multicast;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_multicast)
}

// optional .threadnetwork.TelemetryData.Nat64ProtocolCounters nat64_protocol_counters = 19;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_nat64_protocol_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nat64_protocol_counters_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_nat64_protocol_counters() const {
  return _internal_has_nat64_protocol_counters();
}
inline void TelemetryData_BorderRoutingCounters::clear_nat64_protocol_counters() {
  if (_impl_.nat64_protocol_counters_ != nullptr) _impl_.nat64_protocol_counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& TelemetryData_BorderRoutingCounters::_internal_nat64_protocol_counters() const {
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters* p = _impl_.nat64_protocol_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64ProtocolCounters&>(
      ::threadnetwork::_TelemetryData_Nat64ProtocolCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& TelemetryData_BorderRoutingCounters::nat64_protocol_counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_protocol_counters)
  return _internal_nat64_protocol_counters();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_nat64_protocol_counters(
    ::threadnetwork::TelemetryData_Nat64ProtocolCounters* nat64_protocol_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nat64_protocol_counters_);
  }
  _impl_.nat64_protocol_counters_ = nat64_protocol_counters;
  if (nat64_protocol_counters) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_protocol_counters)
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_BorderRoutingCounters::release_nat64_protocol_counters() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* temp = _impl_.nat64_protocol_counters_;
  _impl_.nat64_protocol_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_BorderRoutingCounters::unsafe_arena_release_nat64_protocol_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_protocol_counters)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* temp = _impl_.nat64_protocol_counters_;
  _impl_.nat64_protocol_counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_BorderRoutingCounters::_internal_mutable_nat64_protocol_counters() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.nat64_protocol_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64ProtocolCounters>(GetArenaForAllocation());
    _impl_.nat64_protocol_counters_ = p;
  }
  return _impl_.nat64_protocol_counters_;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_BorderRoutingCounters::mutable_nat64_protocol_counters() {
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* _msg = _internal_mutable_nat64_protocol_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_protocol_counters)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_nat64_protocol_counters(::threadnetwork::TelemetryData_Nat64ProtocolCounters* nat64_protocol_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nat64_protocol_counters_;
  }
  if (nat64_protocol_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nat64_protocol_counters);
    if (message_arena != submessage_arena) {
      nat64_protocol_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nat64_protocol_counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.nat64_protocol_counters_ = nat64_protocol_counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_protocol_counters)
}

// optional .threadnetwork.TelemetryData.Nat64ErrorCounters nat64_error_counters = 20;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_nat64_error_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nat64_error_counters_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_nat64_error_counters() const {
  return _internal_has_nat64_error_counters();
}
inline void TelemetryData_BorderRoutingCounters::clear_nat64_error_counters() {
  if (_impl_.nat64_error_counters_ != nullptr) _impl_.nat64_error_counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::threadnetwork::TelemetryData_Nat64ErrorCounters& TelemetryData_BorderRoutingCounters::_internal_nat64_error_counters() const {
  const ::threadnetwork::TelemetryData_Nat64ErrorCounters* p = _impl_.nat64_error_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64ErrorCounters&>(
      ::threadnetwork::_TelemetryData_Nat64ErrorCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64ErrorCounters& TelemetryData_BorderRoutingCounters::nat64_error_counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_error_counters)
  return _internal_nat64_error_counters();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_nat64_error_counters(
    ::threadnetwork::TelemetryData_Nat64ErrorCounters* nat64_error_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nat64_error_counters_);
  }
  _impl_.nat64_error_counters_ = nat64_error_counters;
  if (nat64_error_counters) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_error_counters)
}
inline ::threadnetwork::TelemetryData_Nat64ErrorCounters* TelemetryData_BorderRoutingCounters::release_nat64_error_counters() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* temp = _impl_.nat64_error_counters_;
  _impl_.nat64_error_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ErrorCounters* TelemetryData_BorderRoutingCounters::unsafe_arena_release_nat64_error_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_error_counters)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* temp = _impl_.nat64_error_counters_;
  _impl_.nat64_error_counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ErrorCounters* TelemetryData_BorderRoutingCounters::_internal_mutable_nat64_error_counters() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.nat64_error_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64ErrorCounters>(GetArenaForAllocation());
    _impl_.nat64_error_counters_ = p;
  }
  return _impl_.nat64_error_counters_;
}
inline ::threadnetwork::TelemetryData_Nat64ErrorCounters* TelemetryData_BorderRoutingCounters::mutable_nat64_error_counters() {
  ::threadnetwork::TelemetryData_Nat64ErrorCounters* _msg = _internal_mutable_nat64_error_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_error_counters)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_nat64_error_counters(::threadnetwork::TelemetryData_Nat64ErrorCounters* nat64_error_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nat64_error_counters_;
  }
  if (nat64_error_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nat64_error_counters);
    if (message_arena != submessage_arena) {
      nat64_error_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nat64_error_counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.nat64_error_counters_ = nat64_error_counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.nat64_error_counters)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes inbound_internet = 21;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_inbound_internet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inbound_internet_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_inbound_internet() const {
  return _internal_has_inbound_internet();
}
inline void TelemetryData_BorderRoutingCounters::clear_inbound_internet() {
  if (_impl_.inbound_internet_ != nullptr) _impl_.inbound_internet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_inbound_internet() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.inbound_internet_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::inbound_internet() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_internet)
  return _internal_inbound_internet();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_inbound_internet(
    ::threadnetwork::TelemetryData_PacketsAndBytes* inbound_internet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inbound_internet_);
  }
  _impl_.inbound_internet_ = inbound_internet;
  if (inbound_internet) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_internet)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_inbound_internet() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_internet_;
  _impl_.inbound_internet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_inbound_internet() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_internet)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.inbound_internet_;
  _impl_.inbound_internet_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_inbound_internet() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.inbound_internet_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.inbound_internet_ = p;
  }
  return _impl_.inbound_internet_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_inbound_internet() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_inbound_internet();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_internet)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_inbound_internet(::threadnetwork::TelemetryData_PacketsAndBytes* inbound_internet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inbound_internet_;
  }
  if (inbound_internet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inbound_internet);
    if (message_arena != submessage_arena) {
      inbound_internet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inbound_internet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.inbound_internet_ = inbound_internet;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.inbound_internet)
}

// optional .threadnetwork.TelemetryData.PacketsAndBytes outbound_internet = 22;
inline bool TelemetryData_BorderRoutingCounters::_internal_has_outbound_internet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outbound_internet_ != nullptr);
  return value;
}
inline bool TelemetryData_BorderRoutingCounters::has_outbound_internet() const {
  return _internal_has_outbound_internet();
}
inline void TelemetryData_BorderRoutingCounters::clear_outbound_internet() {
  if (_impl_.outbound_internet_ != nullptr) _impl_.outbound_internet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::_internal_outbound_internet() const {
  const ::threadnetwork::TelemetryData_PacketsAndBytes* p = _impl_.outbound_internet_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PacketsAndBytes&>(
      ::threadnetwork::_TelemetryData_PacketsAndBytes_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PacketsAndBytes& TelemetryData_BorderRoutingCounters::outbound_internet() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_internet)
  return _internal_outbound_internet();
}
inline void TelemetryData_BorderRoutingCounters::unsafe_arena_set_allocated_outbound_internet(
    ::threadnetwork::TelemetryData_PacketsAndBytes* outbound_internet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outbound_internet_);
  }
  _impl_.outbound_internet_ = outbound_internet;
  if (outbound_internet) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_internet)
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::release_outbound_internet() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_internet_;
  _impl_.outbound_internet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::unsafe_arena_release_outbound_internet() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_internet)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::threadnetwork::TelemetryData_PacketsAndBytes* temp = _impl_.outbound_internet_;
  _impl_.outbound_internet_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::_internal_mutable_outbound_internet() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.outbound_internet_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PacketsAndBytes>(GetArenaForAllocation());
    _impl_.outbound_internet_ = p;
  }
  return _impl_.outbound_internet_;
}
inline ::threadnetwork::TelemetryData_PacketsAndBytes* TelemetryData_BorderRoutingCounters::mutable_outbound_internet() {
  ::threadnetwork::TelemetryData_PacketsAndBytes* _msg = _internal_mutable_outbound_internet();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_internet)
  return _msg;
}
inline void TelemetryData_BorderRoutingCounters::set_allocated_outbound_internet(::threadnetwork::TelemetryData_PacketsAndBytes* outbound_internet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outbound_internet_;
  }
  if (outbound_internet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outbound_internet);
    if (message_arena != submessage_arena) {
      outbound_internet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outbound_internet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.outbound_internet_ = outbound_internet;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.BorderRoutingCounters.outbound_internet)
}

// -------------------------------------------------------------------

// TelemetryData_PdProcessedRaInfo

// optional uint32 num_platform_ra_received = 1;
inline bool TelemetryData_PdProcessedRaInfo::_internal_has_num_platform_ra_received() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_PdProcessedRaInfo::has_num_platform_ra_received() const {
  return _internal_has_num_platform_ra_received();
}
inline void TelemetryData_PdProcessedRaInfo::clear_num_platform_ra_received() {
  _impl_.num_platform_ra_received_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::_internal_num_platform_ra_received() const {
  return _impl_.num_platform_ra_received_;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::num_platform_ra_received() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.PdProcessedRaInfo.num_platform_ra_received)
  return _internal_num_platform_ra_received();
}
inline void TelemetryData_PdProcessedRaInfo::_internal_set_num_platform_ra_received(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_platform_ra_received_ = value;
}
inline void TelemetryData_PdProcessedRaInfo::set_num_platform_ra_received(uint32_t value) {
  _internal_set_num_platform_ra_received(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.PdProcessedRaInfo.num_platform_ra_received)
}

// optional uint32 num_platform_pio_processed = 2;
inline bool TelemetryData_PdProcessedRaInfo::_internal_has_num_platform_pio_processed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_PdProcessedRaInfo::has_num_platform_pio_processed() const {
  return _internal_has_num_platform_pio_processed();
}
inline void TelemetryData_PdProcessedRaInfo::clear_num_platform_pio_processed() {
  _impl_.num_platform_pio_processed_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::_internal_num_platform_pio_processed() const {
  return _impl_.num_platform_pio_processed_;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::num_platform_pio_processed() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.PdProcessedRaInfo.num_platform_pio_processed)
  return _internal_num_platform_pio_processed();
}
inline void TelemetryData_PdProcessedRaInfo::_internal_set_num_platform_pio_processed(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_platform_pio_processed_ = value;
}
inline void TelemetryData_PdProcessedRaInfo::set_num_platform_pio_processed(uint32_t value) {
  _internal_set_num_platform_pio_processed(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.PdProcessedRaInfo.num_platform_pio_processed)
}

// optional uint32 last_platform_ra_msec = 3;
inline bool TelemetryData_PdProcessedRaInfo::_internal_has_last_platform_ra_msec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_PdProcessedRaInfo::has_last_platform_ra_msec() const {
  return _internal_has_last_platform_ra_msec();
}
inline void TelemetryData_PdProcessedRaInfo::clear_last_platform_ra_msec() {
  _impl_.last_platform_ra_msec_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::_internal_last_platform_ra_msec() const {
  return _impl_.last_platform_ra_msec_;
}
inline uint32_t TelemetryData_PdProcessedRaInfo::last_platform_ra_msec() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.PdProcessedRaInfo.last_platform_ra_msec)
  return _internal_last_platform_ra_msec();
}
inline void TelemetryData_PdProcessedRaInfo::_internal_set_last_platform_ra_msec(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_platform_ra_msec_ = value;
}
inline void TelemetryData_PdProcessedRaInfo::set_last_platform_ra_msec(uint32_t value) {
  _internal_set_last_platform_ra_msec(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.PdProcessedRaInfo.last_platform_ra_msec)
}

// -------------------------------------------------------------------

// TelemetryData_SrpServerRegistrationInfo

// optional uint32 fresh_count = 1;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_fresh_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_fresh_count() const {
  return _internal_has_fresh_count();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_fresh_count() {
  _impl_.fresh_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_SrpServerRegistrationInfo::_internal_fresh_count() const {
  return _impl_.fresh_count_;
}
inline uint32_t TelemetryData_SrpServerRegistrationInfo::fresh_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.fresh_count)
  return _internal_fresh_count();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_fresh_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fresh_count_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_fresh_count(uint32_t value) {
  _internal_set_fresh_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.fresh_count)
}

// optional uint32 deleted_count = 2;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_deleted_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_deleted_count() const {
  return _internal_has_deleted_count();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_deleted_count() {
  _impl_.deleted_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_SrpServerRegistrationInfo::_internal_deleted_count() const {
  return _impl_.deleted_count_;
}
inline uint32_t TelemetryData_SrpServerRegistrationInfo::deleted_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.deleted_count)
  return _internal_deleted_count();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_deleted_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.deleted_count_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_deleted_count(uint32_t value) {
  _internal_set_deleted_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.deleted_count)
}

// optional uint64 lease_time_total_ms = 3;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_lease_time_total_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_lease_time_total_ms() const {
  return _internal_has_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_lease_time_total_ms() {
  _impl_.lease_time_total_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::_internal_lease_time_total_ms() const {
  return _impl_.lease_time_total_ms_;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::lease_time_total_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.lease_time_total_ms)
  return _internal_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_lease_time_total_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lease_time_total_ms_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_lease_time_total_ms(uint64_t value) {
  _internal_set_lease_time_total_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.lease_time_total_ms)
}

// optional uint64 key_lease_time_total_ms = 4;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_key_lease_time_total_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_key_lease_time_total_ms() const {
  return _internal_has_key_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_key_lease_time_total_ms() {
  _impl_.key_lease_time_total_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::_internal_key_lease_time_total_ms() const {
  return _impl_.key_lease_time_total_ms_;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::key_lease_time_total_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.key_lease_time_total_ms)
  return _internal_key_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_key_lease_time_total_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.key_lease_time_total_ms_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_key_lease_time_total_ms(uint64_t value) {
  _internal_set_key_lease_time_total_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.key_lease_time_total_ms)
}

// optional uint64 remaining_lease_time_total_ms = 5;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_remaining_lease_time_total_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_remaining_lease_time_total_ms() const {
  return _internal_has_remaining_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_remaining_lease_time_total_ms() {
  _impl_.remaining_lease_time_total_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::_internal_remaining_lease_time_total_ms() const {
  return _impl_.remaining_lease_time_total_ms_;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::remaining_lease_time_total_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.remaining_lease_time_total_ms)
  return _internal_remaining_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_remaining_lease_time_total_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.remaining_lease_time_total_ms_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_remaining_lease_time_total_ms(uint64_t value) {
  _internal_set_remaining_lease_time_total_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.remaining_lease_time_total_ms)
}

// optional uint64 remaining_key_lease_time_total_ms = 6;
inline bool TelemetryData_SrpServerRegistrationInfo::_internal_has_remaining_key_lease_time_total_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerRegistrationInfo::has_remaining_key_lease_time_total_ms() const {
  return _internal_has_remaining_key_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::clear_remaining_key_lease_time_total_ms() {
  _impl_.remaining_key_lease_time_total_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::_internal_remaining_key_lease_time_total_ms() const {
  return _impl_.remaining_key_lease_time_total_ms_;
}
inline uint64_t TelemetryData_SrpServerRegistrationInfo::remaining_key_lease_time_total_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerRegistrationInfo.remaining_key_lease_time_total_ms)
  return _internal_remaining_key_lease_time_total_ms();
}
inline void TelemetryData_SrpServerRegistrationInfo::_internal_set_remaining_key_lease_time_total_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.remaining_key_lease_time_total_ms_ = value;
}
inline void TelemetryData_SrpServerRegistrationInfo::set_remaining_key_lease_time_total_ms(uint64_t value) {
  _internal_set_remaining_key_lease_time_total_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerRegistrationInfo.remaining_key_lease_time_total_ms)
}

// -------------------------------------------------------------------

// TelemetryData_SrpServerResponseCounters

// optional uint32 success_count = 1;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_success_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_success_count() const {
  return _internal_has_success_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_success_count() {
  _impl_.success_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_success_count() const {
  return _impl_.success_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::success_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.success_count)
  return _internal_success_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_success_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_success_count(uint32_t value) {
  _internal_set_success_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.success_count)
}

// optional uint32 server_failure_count = 2;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_server_failure_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_server_failure_count() const {
  return _internal_has_server_failure_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_server_failure_count() {
  _impl_.server_failure_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_server_failure_count() const {
  return _impl_.server_failure_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::server_failure_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.server_failure_count)
  return _internal_server_failure_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_server_failure_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.server_failure_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_server_failure_count(uint32_t value) {
  _internal_set_server_failure_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.server_failure_count)
}

// optional uint32 format_error_count = 3;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_format_error_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_format_error_count() const {
  return _internal_has_format_error_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_format_error_count() {
  _impl_.format_error_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_format_error_count() const {
  return _impl_.format_error_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::format_error_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.format_error_count)
  return _internal_format_error_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_format_error_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.format_error_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_format_error_count(uint32_t value) {
  _internal_set_format_error_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.format_error_count)
}

// optional uint32 name_exists_count = 4;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_name_exists_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_name_exists_count() const {
  return _internal_has_name_exists_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_name_exists_count() {
  _impl_.name_exists_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_name_exists_count() const {
  return _impl_.name_exists_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::name_exists_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.name_exists_count)
  return _internal_name_exists_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_name_exists_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_exists_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_name_exists_count(uint32_t value) {
  _internal_set_name_exists_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.name_exists_count)
}

// optional uint32 refused_count = 5;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_refused_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_refused_count() const {
  return _internal_has_refused_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_refused_count() {
  _impl_.refused_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_refused_count() const {
  return _impl_.refused_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::refused_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.refused_count)
  return _internal_refused_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_refused_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.refused_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_refused_count(uint32_t value) {
  _internal_set_refused_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.refused_count)
}

// optional uint32 other_count = 6;
inline bool TelemetryData_SrpServerResponseCounters::_internal_has_other_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerResponseCounters::has_other_count() const {
  return _internal_has_other_count();
}
inline void TelemetryData_SrpServerResponseCounters::clear_other_count() {
  _impl_.other_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::_internal_other_count() const {
  return _impl_.other_count_;
}
inline uint32_t TelemetryData_SrpServerResponseCounters::other_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerResponseCounters.other_count)
  return _internal_other_count();
}
inline void TelemetryData_SrpServerResponseCounters::_internal_set_other_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.other_count_ = value;
}
inline void TelemetryData_SrpServerResponseCounters::set_other_count(uint32_t value) {
  _internal_set_other_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerResponseCounters.other_count)
}

// -------------------------------------------------------------------

// TelemetryData_SrpServerInfo

// optional .threadnetwork.TelemetryData.SrpServerState state = 1;
inline bool TelemetryData_SrpServerInfo::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_state() const {
  return _internal_has_state();
}
inline void TelemetryData_SrpServerInfo::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::threadnetwork::TelemetryData_SrpServerState TelemetryData_SrpServerInfo::_internal_state() const {
  return static_cast< ::threadnetwork::TelemetryData_SrpServerState >(_impl_.state_);
}
inline ::threadnetwork::TelemetryData_SrpServerState TelemetryData_SrpServerInfo::state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.state)
  return _internal_state();
}
inline void TelemetryData_SrpServerInfo::_internal_set_state(::threadnetwork::TelemetryData_SrpServerState value) {
  assert(::threadnetwork::TelemetryData_SrpServerState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.state_ = value;
}
inline void TelemetryData_SrpServerInfo::set_state(::threadnetwork::TelemetryData_SrpServerState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerInfo.state)
}

// optional uint32 port = 2;
inline bool TelemetryData_SrpServerInfo::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_port() const {
  return _internal_has_port();
}
inline void TelemetryData_SrpServerInfo::clear_port() {
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_SrpServerInfo::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t TelemetryData_SrpServerInfo::port() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.port)
  return _internal_port();
}
inline void TelemetryData_SrpServerInfo::_internal_set_port(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.port_ = value;
}
inline void TelemetryData_SrpServerInfo::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerInfo.port)
}

// optional .threadnetwork.TelemetryData.SrpServerAddressMode address_mode = 3;
inline bool TelemetryData_SrpServerInfo::_internal_has_address_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_address_mode() const {
  return _internal_has_address_mode();
}
inline void TelemetryData_SrpServerInfo::clear_address_mode() {
  _impl_.address_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::threadnetwork::TelemetryData_SrpServerAddressMode TelemetryData_SrpServerInfo::_internal_address_mode() const {
  return static_cast< ::threadnetwork::TelemetryData_SrpServerAddressMode >(_impl_.address_mode_);
}
inline ::threadnetwork::TelemetryData_SrpServerAddressMode TelemetryData_SrpServerInfo::address_mode() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.address_mode)
  return _internal_address_mode();
}
inline void TelemetryData_SrpServerInfo::_internal_set_address_mode(::threadnetwork::TelemetryData_SrpServerAddressMode value) {
  assert(::threadnetwork::TelemetryData_SrpServerAddressMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.address_mode_ = value;
}
inline void TelemetryData_SrpServerInfo::set_address_mode(::threadnetwork::TelemetryData_SrpServerAddressMode value) {
  _internal_set_address_mode(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.SrpServerInfo.address_mode)
}

// optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo hosts = 4;
inline bool TelemetryData_SrpServerInfo::_internal_has_hosts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hosts_ != nullptr);
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_hosts() const {
  return _internal_has_hosts();
}
inline void TelemetryData_SrpServerInfo::clear_hosts() {
  if (_impl_.hosts_ != nullptr) _impl_.hosts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& TelemetryData_SrpServerInfo::_internal_hosts() const {
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* p = _impl_.hosts_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo&>(
      ::threadnetwork::_TelemetryData_SrpServerRegistrationInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& TelemetryData_SrpServerInfo::hosts() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.hosts)
  return _internal_hosts();
}
inline void TelemetryData_SrpServerInfo::unsafe_arena_set_allocated_hosts(
    ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* hosts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hosts_);
  }
  _impl_.hosts_ = hosts;
  if (hosts) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.hosts)
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::release_hosts() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* temp = _impl_.hosts_;
  _impl_.hosts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::unsafe_arena_release_hosts() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.SrpServerInfo.hosts)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* temp = _impl_.hosts_;
  _impl_.hosts_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::_internal_mutable_hosts() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hosts_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerRegistrationInfo>(GetArenaForAllocation());
    _impl_.hosts_ = p;
  }
  return _impl_.hosts_;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::mutable_hosts() {
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* _msg = _internal_mutable_hosts();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.SrpServerInfo.hosts)
  return _msg;
}
inline void TelemetryData_SrpServerInfo::set_allocated_hosts(::threadnetwork::TelemetryData_SrpServerRegistrationInfo* hosts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hosts_;
  }
  if (hosts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hosts);
    if (message_arena != submessage_arena) {
      hosts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hosts_ = hosts;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.hosts)
}

// optional .threadnetwork.TelemetryData.SrpServerRegistrationInfo services = 5;
inline bool TelemetryData_SrpServerInfo::_internal_has_services() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.services_ != nullptr);
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_services() const {
  return _internal_has_services();
}
inline void TelemetryData_SrpServerInfo::clear_services() {
  if (_impl_.services_ != nullptr) _impl_.services_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& TelemetryData_SrpServerInfo::_internal_services() const {
  const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* p = _impl_.services_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo&>(
      ::threadnetwork::_TelemetryData_SrpServerRegistrationInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_SrpServerRegistrationInfo& TelemetryData_SrpServerInfo::services() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.services)
  return _internal_services();
}
inline void TelemetryData_SrpServerInfo::unsafe_arena_set_allocated_services(
    ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* services) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.services_);
  }
  _impl_.services_ = services;
  if (services) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.services)
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::release_services() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* temp = _impl_.services_;
  _impl_.services_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::unsafe_arena_release_services() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.SrpServerInfo.services)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* temp = _impl_.services_;
  _impl_.services_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::_internal_mutable_services() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.services_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerRegistrationInfo>(GetArenaForAllocation());
    _impl_.services_ = p;
  }
  return _impl_.services_;
}
inline ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* TelemetryData_SrpServerInfo::mutable_services() {
  ::threadnetwork::TelemetryData_SrpServerRegistrationInfo* _msg = _internal_mutable_services();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.SrpServerInfo.services)
  return _msg;
}
inline void TelemetryData_SrpServerInfo::set_allocated_services(::threadnetwork::TelemetryData_SrpServerRegistrationInfo* services) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.services_;
  }
  if (services) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(services);
    if (message_arena != submessage_arena) {
      services = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, services, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.services_ = services;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.services)
}

// optional .threadnetwork.TelemetryData.SrpServerResponseCounters response_counters = 6;
inline bool TelemetryData_SrpServerInfo::_internal_has_response_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_counters_ != nullptr);
  return value;
}
inline bool TelemetryData_SrpServerInfo::has_response_counters() const {
  return _internal_has_response_counters();
}
inline void TelemetryData_SrpServerInfo::clear_response_counters() {
  if (_impl_.response_counters_ != nullptr) _impl_.response_counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_SrpServerResponseCounters& TelemetryData_SrpServerInfo::_internal_response_counters() const {
  const ::threadnetwork::TelemetryData_SrpServerResponseCounters* p = _impl_.response_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_SrpServerResponseCounters&>(
      ::threadnetwork::_TelemetryData_SrpServerResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_SrpServerResponseCounters& TelemetryData_SrpServerInfo::response_counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.SrpServerInfo.response_counters)
  return _internal_response_counters();
}
inline void TelemetryData_SrpServerInfo::unsafe_arena_set_allocated_response_counters(
    ::threadnetwork::TelemetryData_SrpServerResponseCounters* response_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_counters_);
  }
  _impl_.response_counters_ = response_counters;
  if (response_counters) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.response_counters)
}
inline ::threadnetwork::TelemetryData_SrpServerResponseCounters* TelemetryData_SrpServerInfo::release_response_counters() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* temp = _impl_.response_counters_;
  _impl_.response_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerResponseCounters* TelemetryData_SrpServerInfo::unsafe_arena_release_response_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.SrpServerInfo.response_counters)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* temp = _impl_.response_counters_;
  _impl_.response_counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerResponseCounters* TelemetryData_SrpServerInfo::_internal_mutable_response_counters() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.response_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerResponseCounters>(GetArenaForAllocation());
    _impl_.response_counters_ = p;
  }
  return _impl_.response_counters_;
}
inline ::threadnetwork::TelemetryData_SrpServerResponseCounters* TelemetryData_SrpServerInfo::mutable_response_counters() {
  ::threadnetwork::TelemetryData_SrpServerResponseCounters* _msg = _internal_mutable_response_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.SrpServerInfo.response_counters)
  return _msg;
}
inline void TelemetryData_SrpServerInfo::set_allocated_response_counters(::threadnetwork::TelemetryData_SrpServerResponseCounters* response_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_counters_;
  }
  if (response_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_counters);
    if (message_arena != submessage_arena) {
      response_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.response_counters_ = response_counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.SrpServerInfo.response_counters)
}

// -------------------------------------------------------------------

// TelemetryData_TrelPacketCounters

// optional uint64 trel_tx_packets = 1;
inline bool TelemetryData_TrelPacketCounters::_internal_has_trel_tx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_TrelPacketCounters::has_trel_tx_packets() const {
  return _internal_has_trel_tx_packets();
}
inline void TelemetryData_TrelPacketCounters::clear_trel_tx_packets() {
  _impl_.trel_tx_packets_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TelemetryData_TrelPacketCounters::_internal_trel_tx_packets() const {
  return _impl_.trel_tx_packets_;
}
inline uint64_t TelemetryData_TrelPacketCounters::trel_tx_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_packets)
  return _internal_trel_tx_packets();
}
inline void TelemetryData_TrelPacketCounters::_internal_set_trel_tx_packets(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trel_tx_packets_ = value;
}
inline void TelemetryData_TrelPacketCounters::set_trel_tx_packets(uint64_t value) {
  _internal_set_trel_tx_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_packets)
}

// optional uint64 trel_tx_bytes = 2;
inline bool TelemetryData_TrelPacketCounters::_internal_has_trel_tx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_TrelPacketCounters::has_trel_tx_bytes() const {
  return _internal_has_trel_tx_bytes();
}
inline void TelemetryData_TrelPacketCounters::clear_trel_tx_bytes() {
  _impl_.trel_tx_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TelemetryData_TrelPacketCounters::_internal_trel_tx_bytes() const {
  return _impl_.trel_tx_bytes_;
}
inline uint64_t TelemetryData_TrelPacketCounters::trel_tx_bytes() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_bytes)
  return _internal_trel_tx_bytes();
}
inline void TelemetryData_TrelPacketCounters::_internal_set_trel_tx_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.trel_tx_bytes_ = value;
}
inline void TelemetryData_TrelPacketCounters::set_trel_tx_bytes(uint64_t value) {
  _internal_set_trel_tx_bytes(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_bytes)
}

// optional uint64 trel_tx_packets_failed = 3;
inline bool TelemetryData_TrelPacketCounters::_internal_has_trel_tx_packets_failed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_TrelPacketCounters::has_trel_tx_packets_failed() const {
  return _internal_has_trel_tx_packets_failed();
}
inline void TelemetryData_TrelPacketCounters::clear_trel_tx_packets_failed() {
  _impl_.trel_tx_packets_failed_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TelemetryData_TrelPacketCounters::_internal_trel_tx_packets_failed() const {
  return _impl_.trel_tx_packets_failed_;
}
inline uint64_t TelemetryData_TrelPacketCounters::trel_tx_packets_failed() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_packets_failed)
  return _internal_trel_tx_packets_failed();
}
inline void TelemetryData_TrelPacketCounters::_internal_set_trel_tx_packets_failed(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.trel_tx_packets_failed_ = value;
}
inline void TelemetryData_TrelPacketCounters::set_trel_tx_packets_failed(uint64_t value) {
  _internal_set_trel_tx_packets_failed(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelPacketCounters.trel_tx_packets_failed)
}

// optional uint64 tre_rx_packets = 4;
inline bool TelemetryData_TrelPacketCounters::_internal_has_tre_rx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_TrelPacketCounters::has_tre_rx_packets() const {
  return _internal_has_tre_rx_packets();
}
inline void TelemetryData_TrelPacketCounters::clear_tre_rx_packets() {
  _impl_.tre_rx_packets_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TelemetryData_TrelPacketCounters::_internal_tre_rx_packets() const {
  return _impl_.tre_rx_packets_;
}
inline uint64_t TelemetryData_TrelPacketCounters::tre_rx_packets() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelPacketCounters.tre_rx_packets)
  return _internal_tre_rx_packets();
}
inline void TelemetryData_TrelPacketCounters::_internal_set_tre_rx_packets(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tre_rx_packets_ = value;
}
inline void TelemetryData_TrelPacketCounters::set_tre_rx_packets(uint64_t value) {
  _internal_set_tre_rx_packets(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelPacketCounters.tre_rx_packets)
}

// optional uint64 trel_rx_bytes = 5;
inline bool TelemetryData_TrelPacketCounters::_internal_has_trel_rx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_TrelPacketCounters::has_trel_rx_bytes() const {
  return _internal_has_trel_rx_bytes();
}
inline void TelemetryData_TrelPacketCounters::clear_trel_rx_bytes() {
  _impl_.trel_rx_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TelemetryData_TrelPacketCounters::_internal_trel_rx_bytes() const {
  return _impl_.trel_rx_bytes_;
}
inline uint64_t TelemetryData_TrelPacketCounters::trel_rx_bytes() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelPacketCounters.trel_rx_bytes)
  return _internal_trel_rx_bytes();
}
inline void TelemetryData_TrelPacketCounters::_internal_set_trel_rx_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.trel_rx_bytes_ = value;
}
inline void TelemetryData_TrelPacketCounters::set_trel_rx_bytes(uint64_t value) {
  _internal_set_trel_rx_bytes(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelPacketCounters.trel_rx_bytes)
}

// -------------------------------------------------------------------

// TelemetryData_TrelInfo

// optional bool is_trel_enabled = 1;
inline bool TelemetryData_TrelInfo::_internal_has_is_trel_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_TrelInfo::has_is_trel_enabled() const {
  return _internal_has_is_trel_enabled();
}
inline void TelemetryData_TrelInfo::clear_is_trel_enabled() {
  _impl_.is_trel_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TelemetryData_TrelInfo::_internal_is_trel_enabled() const {
  return _impl_.is_trel_enabled_;
}
inline bool TelemetryData_TrelInfo::is_trel_enabled() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelInfo.is_trel_enabled)
  return _internal_is_trel_enabled();
}
inline void TelemetryData_TrelInfo::_internal_set_is_trel_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_trel_enabled_ = value;
}
inline void TelemetryData_TrelInfo::set_is_trel_enabled(bool value) {
  _internal_set_is_trel_enabled(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelInfo.is_trel_enabled)
}

// optional uint32 num_trel_peers = 2;
inline bool TelemetryData_TrelInfo::_internal_has_num_trel_peers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_TrelInfo::has_num_trel_peers() const {
  return _internal_has_num_trel_peers();
}
inline void TelemetryData_TrelInfo::clear_num_trel_peers() {
  _impl_.num_trel_peers_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_TrelInfo::_internal_num_trel_peers() const {
  return _impl_.num_trel_peers_;
}
inline uint32_t TelemetryData_TrelInfo::num_trel_peers() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelInfo.num_trel_peers)
  return _internal_num_trel_peers();
}
inline void TelemetryData_TrelInfo::_internal_set_num_trel_peers(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_trel_peers_ = value;
}
inline void TelemetryData_TrelInfo::set_num_trel_peers(uint32_t value) {
  _internal_set_num_trel_peers(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.TrelInfo.num_trel_peers)
}

// optional .threadnetwork.TelemetryData.TrelPacketCounters counters = 3;
inline bool TelemetryData_TrelInfo::_internal_has_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.counters_ != nullptr);
  return value;
}
inline bool TelemetryData_TrelInfo::has_counters() const {
  return _internal_has_counters();
}
inline void TelemetryData_TrelInfo::clear_counters() {
  if (_impl_.counters_ != nullptr) _impl_.counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_TrelPacketCounters& TelemetryData_TrelInfo::_internal_counters() const {
  const ::threadnetwork::TelemetryData_TrelPacketCounters* p = _impl_.counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_TrelPacketCounters&>(
      ::threadnetwork::_TelemetryData_TrelPacketCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_TrelPacketCounters& TelemetryData_TrelInfo::counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.TrelInfo.counters)
  return _internal_counters();
}
inline void TelemetryData_TrelInfo::unsafe_arena_set_allocated_counters(
    ::threadnetwork::TelemetryData_TrelPacketCounters* counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.counters_);
  }
  _impl_.counters_ = counters;
  if (counters) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.TrelInfo.counters)
}
inline ::threadnetwork::TelemetryData_TrelPacketCounters* TelemetryData_TrelInfo::release_counters() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_TrelPacketCounters* temp = _impl_.counters_;
  _impl_.counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_TrelPacketCounters* TelemetryData_TrelInfo::unsafe_arena_release_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.TrelInfo.counters)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_TrelPacketCounters* temp = _impl_.counters_;
  _impl_.counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_TrelPacketCounters* TelemetryData_TrelInfo::_internal_mutable_counters() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_TrelPacketCounters>(GetArenaForAllocation());
    _impl_.counters_ = p;
  }
  return _impl_.counters_;
}
inline ::threadnetwork::TelemetryData_TrelPacketCounters* TelemetryData_TrelInfo::mutable_counters() {
  ::threadnetwork::TelemetryData_TrelPacketCounters* _msg = _internal_mutable_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.TrelInfo.counters)
  return _msg;
}
inline void TelemetryData_TrelInfo::set_allocated_counters(::threadnetwork::TelemetryData_TrelPacketCounters* counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.counters_;
  }
  if (counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counters);
    if (message_arena != submessage_arena) {
      counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.counters_ = counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.TrelInfo.counters)
}

// -------------------------------------------------------------------

// TelemetryData_DnsServerResponseCounters

// optional uint32 success_count = 1;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_success_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_success_count() const {
  return _internal_has_success_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_success_count() {
  _impl_.success_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_success_count() const {
  return _impl_.success_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::success_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.success_count)
  return _internal_success_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_success_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_success_count(uint32_t value) {
  _internal_set_success_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.success_count)
}

// optional uint32 server_failure_count = 2;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_server_failure_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_server_failure_count() const {
  return _internal_has_server_failure_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_server_failure_count() {
  _impl_.server_failure_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_server_failure_count() const {
  return _impl_.server_failure_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::server_failure_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.server_failure_count)
  return _internal_server_failure_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_server_failure_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.server_failure_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_server_failure_count(uint32_t value) {
  _internal_set_server_failure_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.server_failure_count)
}

// optional uint32 format_error_count = 3;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_format_error_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_format_error_count() const {
  return _internal_has_format_error_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_format_error_count() {
  _impl_.format_error_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_format_error_count() const {
  return _impl_.format_error_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::format_error_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.format_error_count)
  return _internal_format_error_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_format_error_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.format_error_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_format_error_count(uint32_t value) {
  _internal_set_format_error_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.format_error_count)
}

// optional uint32 name_error_count = 4;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_name_error_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_name_error_count() const {
  return _internal_has_name_error_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_name_error_count() {
  _impl_.name_error_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_name_error_count() const {
  return _impl_.name_error_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::name_error_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.name_error_count)
  return _internal_name_error_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_name_error_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_error_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_name_error_count(uint32_t value) {
  _internal_set_name_error_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.name_error_count)
}

// optional uint32 not_implemented_count = 5;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_not_implemented_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_not_implemented_count() const {
  return _internal_has_not_implemented_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_not_implemented_count() {
  _impl_.not_implemented_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_not_implemented_count() const {
  return _impl_.not_implemented_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::not_implemented_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.not_implemented_count)
  return _internal_not_implemented_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_not_implemented_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.not_implemented_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_not_implemented_count(uint32_t value) {
  _internal_set_not_implemented_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.not_implemented_count)
}

// optional uint32 other_count = 6;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_other_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_other_count() const {
  return _internal_has_other_count();
}
inline void TelemetryData_DnsServerResponseCounters::clear_other_count() {
  _impl_.other_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_other_count() const {
  return _impl_.other_count_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::other_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.other_count)
  return _internal_other_count();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_other_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.other_count_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_other_count(uint32_t value) {
  _internal_set_other_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.other_count)
}

// optional uint32 upstream_dns_queries = 7;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_upstream_dns_queries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_upstream_dns_queries() const {
  return _internal_has_upstream_dns_queries();
}
inline void TelemetryData_DnsServerResponseCounters::clear_upstream_dns_queries() {
  _impl_.upstream_dns_queries_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_upstream_dns_queries() const {
  return _impl_.upstream_dns_queries_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::upstream_dns_queries() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_queries)
  return _internal_upstream_dns_queries();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_upstream_dns_queries(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.upstream_dns_queries_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_upstream_dns_queries(uint32_t value) {
  _internal_set_upstream_dns_queries(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_queries)
}

// optional uint32 upstream_dns_responses = 8;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_upstream_dns_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_upstream_dns_responses() const {
  return _internal_has_upstream_dns_responses();
}
inline void TelemetryData_DnsServerResponseCounters::clear_upstream_dns_responses() {
  _impl_.upstream_dns_responses_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_upstream_dns_responses() const {
  return _impl_.upstream_dns_responses_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::upstream_dns_responses() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_responses)
  return _internal_upstream_dns_responses();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_upstream_dns_responses(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.upstream_dns_responses_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_upstream_dns_responses(uint32_t value) {
  _internal_set_upstream_dns_responses(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_responses)
}

// optional uint32 upstream_dns_failures = 9;
inline bool TelemetryData_DnsServerResponseCounters::_internal_has_upstream_dns_failures() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerResponseCounters::has_upstream_dns_failures() const {
  return _internal_has_upstream_dns_failures();
}
inline void TelemetryData_DnsServerResponseCounters::clear_upstream_dns_failures() {
  _impl_.upstream_dns_failures_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::_internal_upstream_dns_failures() const {
  return _impl_.upstream_dns_failures_;
}
inline uint32_t TelemetryData_DnsServerResponseCounters::upstream_dns_failures() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_failures)
  return _internal_upstream_dns_failures();
}
inline void TelemetryData_DnsServerResponseCounters::_internal_set_upstream_dns_failures(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.upstream_dns_failures_ = value;
}
inline void TelemetryData_DnsServerResponseCounters::set_upstream_dns_failures(uint32_t value) {
  _internal_set_upstream_dns_failures(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerResponseCounters.upstream_dns_failures)
}

// -------------------------------------------------------------------

// TelemetryData_DnsServerInfo

// optional .threadnetwork.TelemetryData.DnsServerResponseCounters response_counters = 1;
inline bool TelemetryData_DnsServerInfo::_internal_has_response_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_counters_ != nullptr);
  return value;
}
inline bool TelemetryData_DnsServerInfo::has_response_counters() const {
  return _internal_has_response_counters();
}
inline void TelemetryData_DnsServerInfo::clear_response_counters() {
  if (_impl_.response_counters_ != nullptr) _impl_.response_counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_DnsServerResponseCounters& TelemetryData_DnsServerInfo::_internal_response_counters() const {
  const ::threadnetwork::TelemetryData_DnsServerResponseCounters* p = _impl_.response_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_DnsServerResponseCounters&>(
      ::threadnetwork::_TelemetryData_DnsServerResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_DnsServerResponseCounters& TelemetryData_DnsServerInfo::response_counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerInfo.response_counters)
  return _internal_response_counters();
}
inline void TelemetryData_DnsServerInfo::unsafe_arena_set_allocated_response_counters(
    ::threadnetwork::TelemetryData_DnsServerResponseCounters* response_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_counters_);
  }
  _impl_.response_counters_ = response_counters;
  if (response_counters) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.DnsServerInfo.response_counters)
}
inline ::threadnetwork::TelemetryData_DnsServerResponseCounters* TelemetryData_DnsServerInfo::release_response_counters() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* temp = _impl_.response_counters_;
  _impl_.response_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_DnsServerResponseCounters* TelemetryData_DnsServerInfo::unsafe_arena_release_response_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.DnsServerInfo.response_counters)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* temp = _impl_.response_counters_;
  _impl_.response_counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_DnsServerResponseCounters* TelemetryData_DnsServerInfo::_internal_mutable_response_counters() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_DnsServerResponseCounters>(GetArenaForAllocation());
    _impl_.response_counters_ = p;
  }
  return _impl_.response_counters_;
}
inline ::threadnetwork::TelemetryData_DnsServerResponseCounters* TelemetryData_DnsServerInfo::mutable_response_counters() {
  ::threadnetwork::TelemetryData_DnsServerResponseCounters* _msg = _internal_mutable_response_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.DnsServerInfo.response_counters)
  return _msg;
}
inline void TelemetryData_DnsServerInfo::set_allocated_response_counters(::threadnetwork::TelemetryData_DnsServerResponseCounters* response_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_counters_;
  }
  if (response_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_counters);
    if (message_arena != submessage_arena) {
      response_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.response_counters_ = response_counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.DnsServerInfo.response_counters)
}

// optional uint32 resolved_by_local_srp_count = 2;
inline bool TelemetryData_DnsServerInfo::_internal_has_resolved_by_local_srp_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerInfo::has_resolved_by_local_srp_count() const {
  return _internal_has_resolved_by_local_srp_count();
}
inline void TelemetryData_DnsServerInfo::clear_resolved_by_local_srp_count() {
  _impl_.resolved_by_local_srp_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_DnsServerInfo::_internal_resolved_by_local_srp_count() const {
  return _impl_.resolved_by_local_srp_count_;
}
inline uint32_t TelemetryData_DnsServerInfo::resolved_by_local_srp_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerInfo.resolved_by_local_srp_count)
  return _internal_resolved_by_local_srp_count();
}
inline void TelemetryData_DnsServerInfo::_internal_set_resolved_by_local_srp_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resolved_by_local_srp_count_ = value;
}
inline void TelemetryData_DnsServerInfo::set_resolved_by_local_srp_count(uint32_t value) {
  _internal_set_resolved_by_local_srp_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerInfo.resolved_by_local_srp_count)
}

// optional .threadnetwork.TelemetryData.UpstreamDnsQueryState upstream_dns_query_state = 3;
inline bool TelemetryData_DnsServerInfo::_internal_has_upstream_dns_query_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_DnsServerInfo::has_upstream_dns_query_state() const {
  return _internal_has_upstream_dns_query_state();
}
inline void TelemetryData_DnsServerInfo::clear_upstream_dns_query_state() {
  _impl_.upstream_dns_query_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::threadnetwork::TelemetryData_UpstreamDnsQueryState TelemetryData_DnsServerInfo::_internal_upstream_dns_query_state() const {
  return static_cast< ::threadnetwork::TelemetryData_UpstreamDnsQueryState >(_impl_.upstream_dns_query_state_);
}
inline ::threadnetwork::TelemetryData_UpstreamDnsQueryState TelemetryData_DnsServerInfo::upstream_dns_query_state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.DnsServerInfo.upstream_dns_query_state)
  return _internal_upstream_dns_query_state();
}
inline void TelemetryData_DnsServerInfo::_internal_set_upstream_dns_query_state(::threadnetwork::TelemetryData_UpstreamDnsQueryState value) {
  assert(::threadnetwork::TelemetryData_UpstreamDnsQueryState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.upstream_dns_query_state_ = value;
}
inline void TelemetryData_DnsServerInfo::set_upstream_dns_query_state(::threadnetwork::TelemetryData_UpstreamDnsQueryState value) {
  _internal_set_upstream_dns_query_state(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.DnsServerInfo.upstream_dns_query_state)
}

// -------------------------------------------------------------------

// TelemetryData_MdnsResponseCounters

// optional uint32 success_count = 1;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_success_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_success_count() const {
  return _internal_has_success_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_success_count() {
  _impl_.success_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_success_count() const {
  return _impl_.success_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::success_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.success_count)
  return _internal_success_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_success_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_success_count(uint32_t value) {
  _internal_set_success_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.success_count)
}

// optional uint32 not_found_count = 2;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_not_found_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_not_found_count() const {
  return _internal_has_not_found_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_not_found_count() {
  _impl_.not_found_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_not_found_count() const {
  return _impl_.not_found_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::not_found_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.not_found_count)
  return _internal_not_found_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_not_found_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.not_found_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_not_found_count(uint32_t value) {
  _internal_set_not_found_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.not_found_count)
}

// optional uint32 invalid_args_count = 3;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_invalid_args_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_invalid_args_count() const {
  return _internal_has_invalid_args_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_invalid_args_count() {
  _impl_.invalid_args_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_invalid_args_count() const {
  return _impl_.invalid_args_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::invalid_args_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.invalid_args_count)
  return _internal_invalid_args_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_invalid_args_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.invalid_args_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_invalid_args_count(uint32_t value) {
  _internal_set_invalid_args_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.invalid_args_count)
}

// optional uint32 duplicated_count = 4;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_duplicated_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_duplicated_count() const {
  return _internal_has_duplicated_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_duplicated_count() {
  _impl_.duplicated_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_duplicated_count() const {
  return _impl_.duplicated_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::duplicated_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.duplicated_count)
  return _internal_duplicated_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_duplicated_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.duplicated_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_duplicated_count(uint32_t value) {
  _internal_set_duplicated_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.duplicated_count)
}

// optional uint32 not_implemented_count = 5;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_not_implemented_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_not_implemented_count() const {
  return _internal_has_not_implemented_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_not_implemented_count() {
  _impl_.not_implemented_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_not_implemented_count() const {
  return _impl_.not_implemented_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::not_implemented_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.not_implemented_count)
  return _internal_not_implemented_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_not_implemented_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.not_implemented_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_not_implemented_count(uint32_t value) {
  _internal_set_not_implemented_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.not_implemented_count)
}

// optional uint32 unknown_error_count = 6;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_unknown_error_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_unknown_error_count() const {
  return _internal_has_unknown_error_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_unknown_error_count() {
  _impl_.unknown_error_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_unknown_error_count() const {
  return _impl_.unknown_error_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::unknown_error_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.unknown_error_count)
  return _internal_unknown_error_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_unknown_error_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.unknown_error_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_unknown_error_count(uint32_t value) {
  _internal_set_unknown_error_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.unknown_error_count)
}

// optional uint32 aborted_count = 7;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_aborted_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_aborted_count() const {
  return _internal_has_aborted_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_aborted_count() {
  _impl_.aborted_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_aborted_count() const {
  return _impl_.aborted_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::aborted_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.aborted_count)
  return _internal_aborted_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_aborted_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.aborted_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_aborted_count(uint32_t value) {
  _internal_set_aborted_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.aborted_count)
}

// optional uint32 invalid_state_count = 8;
inline bool TelemetryData_MdnsResponseCounters::_internal_has_invalid_state_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_MdnsResponseCounters::has_invalid_state_count() const {
  return _internal_has_invalid_state_count();
}
inline void TelemetryData_MdnsResponseCounters::clear_invalid_state_count() {
  _impl_.invalid_state_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_MdnsResponseCounters::_internal_invalid_state_count() const {
  return _impl_.invalid_state_count_;
}
inline uint32_t TelemetryData_MdnsResponseCounters::invalid_state_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsResponseCounters.invalid_state_count)
  return _internal_invalid_state_count();
}
inline void TelemetryData_MdnsResponseCounters::_internal_set_invalid_state_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.invalid_state_count_ = value;
}
inline void TelemetryData_MdnsResponseCounters::set_invalid_state_count(uint32_t value) {
  _internal_set_invalid_state_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsResponseCounters.invalid_state_count)
}

// -------------------------------------------------------------------

// TelemetryData_MdnsInfo

// optional .threadnetwork.TelemetryData.MdnsResponseCounters host_registration_responses = 1;
inline bool TelemetryData_MdnsInfo::_internal_has_host_registration_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.host_registration_responses_ != nullptr);
  return value;
}
inline bool TelemetryData_MdnsInfo::has_host_registration_responses() const {
  return _internal_has_host_registration_responses();
}
inline void TelemetryData_MdnsInfo::clear_host_registration_responses() {
  if (_impl_.host_registration_responses_ != nullptr) _impl_.host_registration_responses_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::_internal_host_registration_responses() const {
  const ::threadnetwork::TelemetryData_MdnsResponseCounters* p = _impl_.host_registration_responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_MdnsResponseCounters&>(
      ::threadnetwork::_TelemetryData_MdnsResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::host_registration_responses() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.host_registration_responses)
  return _internal_host_registration_responses();
}
inline void TelemetryData_MdnsInfo::unsafe_arena_set_allocated_host_registration_responses(
    ::threadnetwork::TelemetryData_MdnsResponseCounters* host_registration_responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_registration_responses_);
  }
  _impl_.host_registration_responses_ = host_registration_responses;
  if (host_registration_responses) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.MdnsInfo.host_registration_responses)
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::release_host_registration_responses() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.host_registration_responses_;
  _impl_.host_registration_responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::unsafe_arena_release_host_registration_responses() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.MdnsInfo.host_registration_responses)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.host_registration_responses_;
  _impl_.host_registration_responses_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::_internal_mutable_host_registration_responses() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.host_registration_responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsResponseCounters>(GetArenaForAllocation());
    _impl_.host_registration_responses_ = p;
  }
  return _impl_.host_registration_responses_;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::mutable_host_registration_responses() {
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _msg = _internal_mutable_host_registration_responses();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.MdnsInfo.host_registration_responses)
  return _msg;
}
inline void TelemetryData_MdnsInfo::set_allocated_host_registration_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* host_registration_responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_registration_responses_;
  }
  if (host_registration_responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_registration_responses);
    if (message_arena != submessage_arena) {
      host_registration_responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_registration_responses, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_registration_responses_ = host_registration_responses;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.MdnsInfo.host_registration_responses)
}

// optional .threadnetwork.TelemetryData.MdnsResponseCounters service_registration_responses = 2;
inline bool TelemetryData_MdnsInfo::_internal_has_service_registration_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.service_registration_responses_ != nullptr);
  return value;
}
inline bool TelemetryData_MdnsInfo::has_service_registration_responses() const {
  return _internal_has_service_registration_responses();
}
inline void TelemetryData_MdnsInfo::clear_service_registration_responses() {
  if (_impl_.service_registration_responses_ != nullptr) _impl_.service_registration_responses_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::_internal_service_registration_responses() const {
  const ::threadnetwork::TelemetryData_MdnsResponseCounters* p = _impl_.service_registration_responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_MdnsResponseCounters&>(
      ::threadnetwork::_TelemetryData_MdnsResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::service_registration_responses() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.service_registration_responses)
  return _internal_service_registration_responses();
}
inline void TelemetryData_MdnsInfo::unsafe_arena_set_allocated_service_registration_responses(
    ::threadnetwork::TelemetryData_MdnsResponseCounters* service_registration_responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_registration_responses_);
  }
  _impl_.service_registration_responses_ = service_registration_responses;
  if (service_registration_responses) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.MdnsInfo.service_registration_responses)
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::release_service_registration_responses() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.service_registration_responses_;
  _impl_.service_registration_responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::unsafe_arena_release_service_registration_responses() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.MdnsInfo.service_registration_responses)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.service_registration_responses_;
  _impl_.service_registration_responses_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::_internal_mutable_service_registration_responses() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.service_registration_responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsResponseCounters>(GetArenaForAllocation());
    _impl_.service_registration_responses_ = p;
  }
  return _impl_.service_registration_responses_;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::mutable_service_registration_responses() {
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _msg = _internal_mutable_service_registration_responses();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.MdnsInfo.service_registration_responses)
  return _msg;
}
inline void TelemetryData_MdnsInfo::set_allocated_service_registration_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* service_registration_responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_registration_responses_;
  }
  if (service_registration_responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_registration_responses);
    if (message_arena != submessage_arena) {
      service_registration_responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_registration_responses, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.service_registration_responses_ = service_registration_responses;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.MdnsInfo.service_registration_responses)
}

// optional .threadnetwork.TelemetryData.MdnsResponseCounters host_resolution_responses = 3;
inline bool TelemetryData_MdnsInfo::_internal_has_host_resolution_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.host_resolution_responses_ != nullptr);
  return value;
}
inline bool TelemetryData_MdnsInfo::has_host_resolution_responses() const {
  return _internal_has_host_resolution_responses();
}
inline void TelemetryData_MdnsInfo::clear_host_resolution_responses() {
  if (_impl_.host_resolution_responses_ != nullptr) _impl_.host_resolution_responses_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::_internal_host_resolution_responses() const {
  const ::threadnetwork::TelemetryData_MdnsResponseCounters* p = _impl_.host_resolution_responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_MdnsResponseCounters&>(
      ::threadnetwork::_TelemetryData_MdnsResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::host_resolution_responses() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.host_resolution_responses)
  return _internal_host_resolution_responses();
}
inline void TelemetryData_MdnsInfo::unsafe_arena_set_allocated_host_resolution_responses(
    ::threadnetwork::TelemetryData_MdnsResponseCounters* host_resolution_responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_resolution_responses_);
  }
  _impl_.host_resolution_responses_ = host_resolution_responses;
  if (host_resolution_responses) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.MdnsInfo.host_resolution_responses)
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::release_host_resolution_responses() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.host_resolution_responses_;
  _impl_.host_resolution_responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::unsafe_arena_release_host_resolution_responses() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.MdnsInfo.host_resolution_responses)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.host_resolution_responses_;
  _impl_.host_resolution_responses_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::_internal_mutable_host_resolution_responses() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.host_resolution_responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsResponseCounters>(GetArenaForAllocation());
    _impl_.host_resolution_responses_ = p;
  }
  return _impl_.host_resolution_responses_;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::mutable_host_resolution_responses() {
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _msg = _internal_mutable_host_resolution_responses();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.MdnsInfo.host_resolution_responses)
  return _msg;
}
inline void TelemetryData_MdnsInfo::set_allocated_host_resolution_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* host_resolution_responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_resolution_responses_;
  }
  if (host_resolution_responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_resolution_responses);
    if (message_arena != submessage_arena) {
      host_resolution_responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_resolution_responses, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.host_resolution_responses_ = host_resolution_responses;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.MdnsInfo.host_resolution_responses)
}

// optional .threadnetwork.TelemetryData.MdnsResponseCounters service_resolution_responses = 4;
inline bool TelemetryData_MdnsInfo::_internal_has_service_resolution_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.service_resolution_responses_ != nullptr);
  return value;
}
inline bool TelemetryData_MdnsInfo::has_service_resolution_responses() const {
  return _internal_has_service_resolution_responses();
}
inline void TelemetryData_MdnsInfo::clear_service_resolution_responses() {
  if (_impl_.service_resolution_responses_ != nullptr) _impl_.service_resolution_responses_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::_internal_service_resolution_responses() const {
  const ::threadnetwork::TelemetryData_MdnsResponseCounters* p = _impl_.service_resolution_responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_MdnsResponseCounters&>(
      ::threadnetwork::_TelemetryData_MdnsResponseCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_MdnsResponseCounters& TelemetryData_MdnsInfo::service_resolution_responses() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.service_resolution_responses)
  return _internal_service_resolution_responses();
}
inline void TelemetryData_MdnsInfo::unsafe_arena_set_allocated_service_resolution_responses(
    ::threadnetwork::TelemetryData_MdnsResponseCounters* service_resolution_responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_resolution_responses_);
  }
  _impl_.service_resolution_responses_ = service_resolution_responses;
  if (service_resolution_responses) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.MdnsInfo.service_resolution_responses)
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::release_service_resolution_responses() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.service_resolution_responses_;
  _impl_.service_resolution_responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::unsafe_arena_release_service_resolution_responses() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.MdnsInfo.service_resolution_responses)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_MdnsResponseCounters* temp = _impl_.service_resolution_responses_;
  _impl_.service_resolution_responses_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::_internal_mutable_service_resolution_responses() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.service_resolution_responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsResponseCounters>(GetArenaForAllocation());
    _impl_.service_resolution_responses_ = p;
  }
  return _impl_.service_resolution_responses_;
}
inline ::threadnetwork::TelemetryData_MdnsResponseCounters* TelemetryData_MdnsInfo::mutable_service_resolution_responses() {
  ::threadnetwork::TelemetryData_MdnsResponseCounters* _msg = _internal_mutable_service_resolution_responses();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.MdnsInfo.service_resolution_responses)
  return _msg;
}
inline void TelemetryData_MdnsInfo::set_allocated_service_resolution_responses(::threadnetwork::TelemetryData_MdnsResponseCounters* service_resolution_responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_resolution_responses_;
  }
  if (service_resolution_responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_resolution_responses);
    if (message_arena != submessage_arena) {
      service_resolution_responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_resolution_responses, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.service_resolution_responses_ = service_resolution_responses;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.MdnsInfo.service_resolution_responses)
}

// optional uint32 host_registration_ema_latency_ms = 5;
inline bool TelemetryData_MdnsInfo::_internal_has_host_registration_ema_latency_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_MdnsInfo::has_host_registration_ema_latency_ms() const {
  return _internal_has_host_registration_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::clear_host_registration_ema_latency_ms() {
  _impl_.host_registration_ema_latency_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_MdnsInfo::_internal_host_registration_ema_latency_ms() const {
  return _impl_.host_registration_ema_latency_ms_;
}
inline uint32_t TelemetryData_MdnsInfo::host_registration_ema_latency_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.host_registration_ema_latency_ms)
  return _internal_host_registration_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::_internal_set_host_registration_ema_latency_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.host_registration_ema_latency_ms_ = value;
}
inline void TelemetryData_MdnsInfo::set_host_registration_ema_latency_ms(uint32_t value) {
  _internal_set_host_registration_ema_latency_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsInfo.host_registration_ema_latency_ms)
}

// optional uint32 service_registration_ema_latency_ms = 6;
inline bool TelemetryData_MdnsInfo::_internal_has_service_registration_ema_latency_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_MdnsInfo::has_service_registration_ema_latency_ms() const {
  return _internal_has_service_registration_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::clear_service_registration_ema_latency_ms() {
  _impl_.service_registration_ema_latency_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_MdnsInfo::_internal_service_registration_ema_latency_ms() const {
  return _impl_.service_registration_ema_latency_ms_;
}
inline uint32_t TelemetryData_MdnsInfo::service_registration_ema_latency_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.service_registration_ema_latency_ms)
  return _internal_service_registration_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::_internal_set_service_registration_ema_latency_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.service_registration_ema_latency_ms_ = value;
}
inline void TelemetryData_MdnsInfo::set_service_registration_ema_latency_ms(uint32_t value) {
  _internal_set_service_registration_ema_latency_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsInfo.service_registration_ema_latency_ms)
}

// optional uint32 host_resolution_ema_latency_ms = 7;
inline bool TelemetryData_MdnsInfo::_internal_has_host_resolution_ema_latency_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_MdnsInfo::has_host_resolution_ema_latency_ms() const {
  return _internal_has_host_resolution_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::clear_host_resolution_ema_latency_ms() {
  _impl_.host_resolution_ema_latency_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_MdnsInfo::_internal_host_resolution_ema_latency_ms() const {
  return _impl_.host_resolution_ema_latency_ms_;
}
inline uint32_t TelemetryData_MdnsInfo::host_resolution_ema_latency_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.host_resolution_ema_latency_ms)
  return _internal_host_resolution_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::_internal_set_host_resolution_ema_latency_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.host_resolution_ema_latency_ms_ = value;
}
inline void TelemetryData_MdnsInfo::set_host_resolution_ema_latency_ms(uint32_t value) {
  _internal_set_host_resolution_ema_latency_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsInfo.host_resolution_ema_latency_ms)
}

// optional uint32 service_resolution_ema_latency_ms = 8;
inline bool TelemetryData_MdnsInfo::_internal_has_service_resolution_ema_latency_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_MdnsInfo::has_service_resolution_ema_latency_ms() const {
  return _internal_has_service_resolution_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::clear_service_resolution_ema_latency_ms() {
  _impl_.service_resolution_ema_latency_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_MdnsInfo::_internal_service_resolution_ema_latency_ms() const {
  return _impl_.service_resolution_ema_latency_ms_;
}
inline uint32_t TelemetryData_MdnsInfo::service_resolution_ema_latency_ms() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.MdnsInfo.service_resolution_ema_latency_ms)
  return _internal_service_resolution_ema_latency_ms();
}
inline void TelemetryData_MdnsInfo::_internal_set_service_resolution_ema_latency_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.service_resolution_ema_latency_ms_ = value;
}
inline void TelemetryData_MdnsInfo::set_service_resolution_ema_latency_ms(uint32_t value) {
  _internal_set_service_resolution_ema_latency_ms(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.MdnsInfo.service_resolution_ema_latency_ms)
}

// -------------------------------------------------------------------

// TelemetryData_BorderRoutingNat64State

// optional .threadnetwork.TelemetryData.Nat64State prefix_manager_state = 1;
inline bool TelemetryData_BorderRoutingNat64State::_internal_has_prefix_manager_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingNat64State::has_prefix_manager_state() const {
  return _internal_has_prefix_manager_state();
}
inline void TelemetryData_BorderRoutingNat64State::clear_prefix_manager_state() {
  _impl_.prefix_manager_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::threadnetwork::TelemetryData_Nat64State TelemetryData_BorderRoutingNat64State::_internal_prefix_manager_state() const {
  return static_cast< ::threadnetwork::TelemetryData_Nat64State >(_impl_.prefix_manager_state_);
}
inline ::threadnetwork::TelemetryData_Nat64State TelemetryData_BorderRoutingNat64State::prefix_manager_state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingNat64State.prefix_manager_state)
  return _internal_prefix_manager_state();
}
inline void TelemetryData_BorderRoutingNat64State::_internal_set_prefix_manager_state(::threadnetwork::TelemetryData_Nat64State value) {
  assert(::threadnetwork::TelemetryData_Nat64State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prefix_manager_state_ = value;
}
inline void TelemetryData_BorderRoutingNat64State::set_prefix_manager_state(::threadnetwork::TelemetryData_Nat64State value) {
  _internal_set_prefix_manager_state(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingNat64State.prefix_manager_state)
}

// optional .threadnetwork.TelemetryData.Nat64State translator_state = 2;
inline bool TelemetryData_BorderRoutingNat64State::_internal_has_translator_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_BorderRoutingNat64State::has_translator_state() const {
  return _internal_has_translator_state();
}
inline void TelemetryData_BorderRoutingNat64State::clear_translator_state() {
  _impl_.translator_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::threadnetwork::TelemetryData_Nat64State TelemetryData_BorderRoutingNat64State::_internal_translator_state() const {
  return static_cast< ::threadnetwork::TelemetryData_Nat64State >(_impl_.translator_state_);
}
inline ::threadnetwork::TelemetryData_Nat64State TelemetryData_BorderRoutingNat64State::translator_state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.BorderRoutingNat64State.translator_state)
  return _internal_translator_state();
}
inline void TelemetryData_BorderRoutingNat64State::_internal_set_translator_state(::threadnetwork::TelemetryData_Nat64State value) {
  assert(::threadnetwork::TelemetryData_Nat64State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.translator_state_ = value;
}
inline void TelemetryData_BorderRoutingNat64State::set_translator_state(::threadnetwork::TelemetryData_Nat64State value) {
  _internal_set_translator_state(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.BorderRoutingNat64State.translator_state)
}

// -------------------------------------------------------------------

// TelemetryData_Nat64Mapping

// optional uint64 mapping_id = 1;
inline bool TelemetryData_Nat64Mapping::_internal_has_mapping_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_Nat64Mapping::has_mapping_id() const {
  return _internal_has_mapping_id();
}
inline void TelemetryData_Nat64Mapping::clear_mapping_id() {
  _impl_.mapping_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TelemetryData_Nat64Mapping::_internal_mapping_id() const {
  return _impl_.mapping_id_;
}
inline uint64_t TelemetryData_Nat64Mapping::mapping_id() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64Mapping.mapping_id)
  return _internal_mapping_id();
}
inline void TelemetryData_Nat64Mapping::_internal_set_mapping_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mapping_id_ = value;
}
inline void TelemetryData_Nat64Mapping::set_mapping_id(uint64_t value) {
  _internal_set_mapping_id(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64Mapping.mapping_id)
}

// optional bytes hashed_ipv6_address = 2;
inline bool TelemetryData_Nat64Mapping::_internal_has_hashed_ipv6_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_Nat64Mapping::has_hashed_ipv6_address() const {
  return _internal_has_hashed_ipv6_address();
}
inline void TelemetryData_Nat64Mapping::clear_hashed_ipv6_address() {
  _impl_.hashed_ipv6_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryData_Nat64Mapping::hashed_ipv6_address() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64Mapping.hashed_ipv6_address)
  return _internal_hashed_ipv6_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_Nat64Mapping::set_hashed_ipv6_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hashed_ipv6_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.Nat64Mapping.hashed_ipv6_address)
}
inline std::string* TelemetryData_Nat64Mapping::mutable_hashed_ipv6_address() {
  std::string* _s = _internal_mutable_hashed_ipv6_address();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64Mapping.hashed_ipv6_address)
  return _s;
}
inline const std::string& TelemetryData_Nat64Mapping::_internal_hashed_ipv6_address() const {
  return _impl_.hashed_ipv6_address_.Get();
}
inline void TelemetryData_Nat64Mapping::_internal_set_hashed_ipv6_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hashed_ipv6_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_Nat64Mapping::_internal_mutable_hashed_ipv6_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hashed_ipv6_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_Nat64Mapping::release_hashed_ipv6_address() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64Mapping.hashed_ipv6_address)
  if (!_internal_has_hashed_ipv6_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hashed_ipv6_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_ipv6_address_.IsDefault()) {
    _impl_.hashed_ipv6_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_Nat64Mapping::set_allocated_hashed_ipv6_address(std::string* hashed_ipv6_address) {
  if (hashed_ipv6_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hashed_ipv6_address_.SetAllocated(hashed_ipv6_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_ipv6_address_.IsDefault()) {
    _impl_.hashed_ipv6_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64Mapping.hashed_ipv6_address)
}

// optional .threadnetwork.TelemetryData.Nat64ProtocolCounters counters = 3;
inline bool TelemetryData_Nat64Mapping::_internal_has_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.counters_ != nullptr);
  return value;
}
inline bool TelemetryData_Nat64Mapping::has_counters() const {
  return _internal_has_counters();
}
inline void TelemetryData_Nat64Mapping::clear_counters() {
  if (_impl_.counters_ != nullptr) _impl_.counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& TelemetryData_Nat64Mapping::_internal_counters() const {
  const ::threadnetwork::TelemetryData_Nat64ProtocolCounters* p = _impl_.counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_Nat64ProtocolCounters&>(
      ::threadnetwork::_TelemetryData_Nat64ProtocolCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_Nat64ProtocolCounters& TelemetryData_Nat64Mapping::counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.Nat64Mapping.counters)
  return _internal_counters();
}
inline void TelemetryData_Nat64Mapping::unsafe_arena_set_allocated_counters(
    ::threadnetwork::TelemetryData_Nat64ProtocolCounters* counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.counters_);
  }
  _impl_.counters_ = counters;
  if (counters) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.Nat64Mapping.counters)
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_Nat64Mapping::release_counters() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* temp = _impl_.counters_;
  _impl_.counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_Nat64Mapping::unsafe_arena_release_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.Nat64Mapping.counters)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* temp = _impl_.counters_;
  _impl_.counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_Nat64Mapping::_internal_mutable_counters() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_Nat64ProtocolCounters>(GetArenaForAllocation());
    _impl_.counters_ = p;
  }
  return _impl_.counters_;
}
inline ::threadnetwork::TelemetryData_Nat64ProtocolCounters* TelemetryData_Nat64Mapping::mutable_counters() {
  ::threadnetwork::TelemetryData_Nat64ProtocolCounters* _msg = _internal_mutable_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.Nat64Mapping.counters)
  return _msg;
}
inline void TelemetryData_Nat64Mapping::set_allocated_counters(::threadnetwork::TelemetryData_Nat64ProtocolCounters* counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.counters_;
  }
  if (counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counters);
    if (message_arena != submessage_arena) {
      counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.counters_ = counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.Nat64Mapping.counters)
}

// -------------------------------------------------------------------

// TelemetryData_InfraLinkInfo

// optional string name = 1;
inline bool TelemetryData_InfraLinkInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_name() const {
  return _internal_has_name();
}
inline void TelemetryData_InfraLinkInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryData_InfraLinkInfo::name() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_InfraLinkInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.name)
}
inline std::string* TelemetryData_InfraLinkInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.InfraLinkInfo.name)
  return _s;
}
inline const std::string& TelemetryData_InfraLinkInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_InfraLinkInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_InfraLinkInfo::release_name() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.InfraLinkInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_InfraLinkInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.InfraLinkInfo.name)
}

// optional bool is_up = 2;
inline bool TelemetryData_InfraLinkInfo::_internal_has_is_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_is_up() const {
  return _internal_has_is_up();
}
inline void TelemetryData_InfraLinkInfo::clear_is_up() {
  _impl_.is_up_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TelemetryData_InfraLinkInfo::_internal_is_up() const {
  return _impl_.is_up_;
}
inline bool TelemetryData_InfraLinkInfo::is_up() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.is_up)
  return _internal_is_up();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_is_up(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_up_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_is_up(bool value) {
  _internal_set_is_up(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.is_up)
}

// optional bool is_running = 3;
inline bool TelemetryData_InfraLinkInfo::_internal_has_is_running() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_is_running() const {
  return _internal_has_is_running();
}
inline void TelemetryData_InfraLinkInfo::clear_is_running() {
  _impl_.is_running_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TelemetryData_InfraLinkInfo::_internal_is_running() const {
  return _impl_.is_running_;
}
inline bool TelemetryData_InfraLinkInfo::is_running() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.is_running)
  return _internal_is_running();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_is_running(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_running_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_is_running(bool value) {
  _internal_set_is_running(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.is_running)
}

// optional bool is_multicast = 4;
inline bool TelemetryData_InfraLinkInfo::_internal_has_is_multicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_is_multicast() const {
  return _internal_has_is_multicast();
}
inline void TelemetryData_InfraLinkInfo::clear_is_multicast() {
  _impl_.is_multicast_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TelemetryData_InfraLinkInfo::_internal_is_multicast() const {
  return _impl_.is_multicast_;
}
inline bool TelemetryData_InfraLinkInfo::is_multicast() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.is_multicast)
  return _internal_is_multicast();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_is_multicast(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_multicast_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_is_multicast(bool value) {
  _internal_set_is_multicast(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.is_multicast)
}

// optional uint32 link_local_address_count = 5;
inline bool TelemetryData_InfraLinkInfo::_internal_has_link_local_address_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_link_local_address_count() const {
  return _internal_has_link_local_address_count();
}
inline void TelemetryData_InfraLinkInfo::clear_link_local_address_count() {
  _impl_.link_local_address_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_InfraLinkInfo::_internal_link_local_address_count() const {
  return _impl_.link_local_address_count_;
}
inline uint32_t TelemetryData_InfraLinkInfo::link_local_address_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.link_local_address_count)
  return _internal_link_local_address_count();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_link_local_address_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.link_local_address_count_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_link_local_address_count(uint32_t value) {
  _internal_set_link_local_address_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.link_local_address_count)
}

// optional uint32 unique_local_address_count = 6;
inline bool TelemetryData_InfraLinkInfo::_internal_has_unique_local_address_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_unique_local_address_count() const {
  return _internal_has_unique_local_address_count();
}
inline void TelemetryData_InfraLinkInfo::clear_unique_local_address_count() {
  _impl_.unique_local_address_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_InfraLinkInfo::_internal_unique_local_address_count() const {
  return _impl_.unique_local_address_count_;
}
inline uint32_t TelemetryData_InfraLinkInfo::unique_local_address_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.unique_local_address_count)
  return _internal_unique_local_address_count();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_unique_local_address_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.unique_local_address_count_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_unique_local_address_count(uint32_t value) {
  _internal_set_unique_local_address_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.unique_local_address_count)
}

// optional uint32 global_unicast_address_count = 7;
inline bool TelemetryData_InfraLinkInfo::_internal_has_global_unicast_address_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_InfraLinkInfo::has_global_unicast_address_count() const {
  return _internal_has_global_unicast_address_count();
}
inline void TelemetryData_InfraLinkInfo::clear_global_unicast_address_count() {
  _impl_.global_unicast_address_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_InfraLinkInfo::_internal_global_unicast_address_count() const {
  return _impl_.global_unicast_address_count_;
}
inline uint32_t TelemetryData_InfraLinkInfo::global_unicast_address_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.InfraLinkInfo.global_unicast_address_count)
  return _internal_global_unicast_address_count();
}
inline void TelemetryData_InfraLinkInfo::_internal_set_global_unicast_address_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.global_unicast_address_count_ = value;
}
inline void TelemetryData_InfraLinkInfo::set_global_unicast_address_count(uint32_t value) {
  _internal_set_global_unicast_address_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.InfraLinkInfo.global_unicast_address_count)
}

// -------------------------------------------------------------------

// TelemetryData_WpanBorderRouter

// optional .threadnetwork.TelemetryData.BorderRoutingCounters border_routing_counters = 1;
inline bool TelemetryData_WpanBorderRouter::_internal_has_border_routing_counters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.border_routing_counters_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_border_routing_counters() const {
  return _internal_has_border_routing_counters();
}
inline void TelemetryData_WpanBorderRouter::clear_border_routing_counters() {
  if (_impl_.border_routing_counters_ != nullptr) _impl_.border_routing_counters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_BorderRoutingCounters& TelemetryData_WpanBorderRouter::_internal_border_routing_counters() const {
  const ::threadnetwork::TelemetryData_BorderRoutingCounters* p = _impl_.border_routing_counters_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_BorderRoutingCounters&>(
      ::threadnetwork::_TelemetryData_BorderRoutingCounters_default_instance_);
}
inline const ::threadnetwork::TelemetryData_BorderRoutingCounters& TelemetryData_WpanBorderRouter::border_routing_counters() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.border_routing_counters)
  return _internal_border_routing_counters();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_border_routing_counters(
    ::threadnetwork::TelemetryData_BorderRoutingCounters* border_routing_counters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.border_routing_counters_);
  }
  _impl_.border_routing_counters_ = border_routing_counters;
  if (border_routing_counters) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.border_routing_counters)
}
inline ::threadnetwork::TelemetryData_BorderRoutingCounters* TelemetryData_WpanBorderRouter::release_border_routing_counters() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_BorderRoutingCounters* temp = _impl_.border_routing_counters_;
  _impl_.border_routing_counters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_BorderRoutingCounters* TelemetryData_WpanBorderRouter::unsafe_arena_release_border_routing_counters() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.border_routing_counters)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_BorderRoutingCounters* temp = _impl_.border_routing_counters_;
  _impl_.border_routing_counters_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_BorderRoutingCounters* TelemetryData_WpanBorderRouter::_internal_mutable_border_routing_counters() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.border_routing_counters_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_BorderRoutingCounters>(GetArenaForAllocation());
    _impl_.border_routing_counters_ = p;
  }
  return _impl_.border_routing_counters_;
}
inline ::threadnetwork::TelemetryData_BorderRoutingCounters* TelemetryData_WpanBorderRouter::mutable_border_routing_counters() {
  ::threadnetwork::TelemetryData_BorderRoutingCounters* _msg = _internal_mutable_border_routing_counters();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.border_routing_counters)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_border_routing_counters(::threadnetwork::TelemetryData_BorderRoutingCounters* border_routing_counters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.border_routing_counters_;
  }
  if (border_routing_counters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(border_routing_counters);
    if (message_arena != submessage_arena) {
      border_routing_counters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, border_routing_counters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.border_routing_counters_ = border_routing_counters;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.border_routing_counters)
}

// optional .threadnetwork.TelemetryData.SrpServerInfo srp_server = 2;
inline bool TelemetryData_WpanBorderRouter::_internal_has_srp_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srp_server_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_srp_server() const {
  return _internal_has_srp_server();
}
inline void TelemetryData_WpanBorderRouter::clear_srp_server() {
  if (_impl_.srp_server_ != nullptr) _impl_.srp_server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_SrpServerInfo& TelemetryData_WpanBorderRouter::_internal_srp_server() const {
  const ::threadnetwork::TelemetryData_SrpServerInfo* p = _impl_.srp_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_SrpServerInfo&>(
      ::threadnetwork::_TelemetryData_SrpServerInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_SrpServerInfo& TelemetryData_WpanBorderRouter::srp_server() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.srp_server)
  return _internal_srp_server();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_srp_server(
    ::threadnetwork::TelemetryData_SrpServerInfo* srp_server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.srp_server_);
  }
  _impl_.srp_server_ = srp_server;
  if (srp_server) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.srp_server)
}
inline ::threadnetwork::TelemetryData_SrpServerInfo* TelemetryData_WpanBorderRouter::release_srp_server() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_SrpServerInfo* temp = _impl_.srp_server_;
  _impl_.srp_server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_srp_server() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.srp_server)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_SrpServerInfo* temp = _impl_.srp_server_;
  _impl_.srp_server_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_SrpServerInfo* TelemetryData_WpanBorderRouter::_internal_mutable_srp_server() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.srp_server_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_SrpServerInfo>(GetArenaForAllocation());
    _impl_.srp_server_ = p;
  }
  return _impl_.srp_server_;
}
inline ::threadnetwork::TelemetryData_SrpServerInfo* TelemetryData_WpanBorderRouter::mutable_srp_server() {
  ::threadnetwork::TelemetryData_SrpServerInfo* _msg = _internal_mutable_srp_server();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.srp_server)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_srp_server(::threadnetwork::TelemetryData_SrpServerInfo* srp_server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.srp_server_;
  }
  if (srp_server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(srp_server);
    if (message_arena != submessage_arena) {
      srp_server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, srp_server, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.srp_server_ = srp_server;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.srp_server)
}

// optional .threadnetwork.TelemetryData.DnsServerInfo dns_server = 3;
inline bool TelemetryData_WpanBorderRouter::_internal_has_dns_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dns_server_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_dns_server() const {
  return _internal_has_dns_server();
}
inline void TelemetryData_WpanBorderRouter::clear_dns_server() {
  if (_impl_.dns_server_ != nullptr) _impl_.dns_server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::threadnetwork::TelemetryData_DnsServerInfo& TelemetryData_WpanBorderRouter::_internal_dns_server() const {
  const ::threadnetwork::TelemetryData_DnsServerInfo* p = _impl_.dns_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_DnsServerInfo&>(
      ::threadnetwork::_TelemetryData_DnsServerInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_DnsServerInfo& TelemetryData_WpanBorderRouter::dns_server() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.dns_server)
  return _internal_dns_server();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_dns_server(
    ::threadnetwork::TelemetryData_DnsServerInfo* dns_server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dns_server_);
  }
  _impl_.dns_server_ = dns_server;
  if (dns_server) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.dns_server)
}
inline ::threadnetwork::TelemetryData_DnsServerInfo* TelemetryData_WpanBorderRouter::release_dns_server() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_DnsServerInfo* temp = _impl_.dns_server_;
  _impl_.dns_server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_DnsServerInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_dns_server() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.dns_server)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_DnsServerInfo* temp = _impl_.dns_server_;
  _impl_.dns_server_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_DnsServerInfo* TelemetryData_WpanBorderRouter::_internal_mutable_dns_server() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.dns_server_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_DnsServerInfo>(GetArenaForAllocation());
    _impl_.dns_server_ = p;
  }
  return _impl_.dns_server_;
}
inline ::threadnetwork::TelemetryData_DnsServerInfo* TelemetryData_WpanBorderRouter::mutable_dns_server() {
  ::threadnetwork::TelemetryData_DnsServerInfo* _msg = _internal_mutable_dns_server();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.dns_server)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_dns_server(::threadnetwork::TelemetryData_DnsServerInfo* dns_server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dns_server_;
  }
  if (dns_server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dns_server);
    if (message_arena != submessage_arena) {
      dns_server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dns_server, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.dns_server_ = dns_server;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.dns_server)
}

// optional .threadnetwork.TelemetryData.MdnsInfo mdns = 4;
inline bool TelemetryData_WpanBorderRouter::_internal_has_mdns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mdns_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_mdns() const {
  return _internal_has_mdns();
}
inline void TelemetryData_WpanBorderRouter::clear_mdns() {
  if (_impl_.mdns_ != nullptr) _impl_.mdns_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::threadnetwork::TelemetryData_MdnsInfo& TelemetryData_WpanBorderRouter::_internal_mdns() const {
  const ::threadnetwork::TelemetryData_MdnsInfo* p = _impl_.mdns_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_MdnsInfo&>(
      ::threadnetwork::_TelemetryData_MdnsInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_MdnsInfo& TelemetryData_WpanBorderRouter::mdns() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.mdns)
  return _internal_mdns();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_mdns(
    ::threadnetwork::TelemetryData_MdnsInfo* mdns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mdns_);
  }
  _impl_.mdns_ = mdns;
  if (mdns) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.mdns)
}
inline ::threadnetwork::TelemetryData_MdnsInfo* TelemetryData_WpanBorderRouter::release_mdns() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_MdnsInfo* temp = _impl_.mdns_;
  _impl_.mdns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_mdns() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.mdns)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_MdnsInfo* temp = _impl_.mdns_;
  _impl_.mdns_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_MdnsInfo* TelemetryData_WpanBorderRouter::_internal_mutable_mdns() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.mdns_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_MdnsInfo>(GetArenaForAllocation());
    _impl_.mdns_ = p;
  }
  return _impl_.mdns_;
}
inline ::threadnetwork::TelemetryData_MdnsInfo* TelemetryData_WpanBorderRouter::mutable_mdns() {
  ::threadnetwork::TelemetryData_MdnsInfo* _msg = _internal_mutable_mdns();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.mdns)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_mdns(::threadnetwork::TelemetryData_MdnsInfo* mdns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mdns_;
  }
  if (mdns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mdns);
    if (message_arena != submessage_arena) {
      mdns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mdns, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mdns_ = mdns;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.mdns)
}

// optional .threadnetwork.TelemetryData.BorderRoutingNat64State nat64_state = 6;
inline bool TelemetryData_WpanBorderRouter::_internal_has_nat64_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nat64_state_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_nat64_state() const {
  return _internal_has_nat64_state();
}
inline void TelemetryData_WpanBorderRouter::clear_nat64_state() {
  if (_impl_.nat64_state_ != nullptr) _impl_.nat64_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::threadnetwork::TelemetryData_BorderRoutingNat64State& TelemetryData_WpanBorderRouter::_internal_nat64_state() const {
  const ::threadnetwork::TelemetryData_BorderRoutingNat64State* p = _impl_.nat64_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_BorderRoutingNat64State&>(
      ::threadnetwork::_TelemetryData_BorderRoutingNat64State_default_instance_);
}
inline const ::threadnetwork::TelemetryData_BorderRoutingNat64State& TelemetryData_WpanBorderRouter::nat64_state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.nat64_state)
  return _internal_nat64_state();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_nat64_state(
    ::threadnetwork::TelemetryData_BorderRoutingNat64State* nat64_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nat64_state_);
  }
  _impl_.nat64_state_ = nat64_state;
  if (nat64_state) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.nat64_state)
}
inline ::threadnetwork::TelemetryData_BorderRoutingNat64State* TelemetryData_WpanBorderRouter::release_nat64_state() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* temp = _impl_.nat64_state_;
  _impl_.nat64_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_BorderRoutingNat64State* TelemetryData_WpanBorderRouter::unsafe_arena_release_nat64_state() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.nat64_state)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* temp = _impl_.nat64_state_;
  _impl_.nat64_state_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_BorderRoutingNat64State* TelemetryData_WpanBorderRouter::_internal_mutable_nat64_state() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.nat64_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_BorderRoutingNat64State>(GetArenaForAllocation());
    _impl_.nat64_state_ = p;
  }
  return _impl_.nat64_state_;
}
inline ::threadnetwork::TelemetryData_BorderRoutingNat64State* TelemetryData_WpanBorderRouter::mutable_nat64_state() {
  ::threadnetwork::TelemetryData_BorderRoutingNat64State* _msg = _internal_mutable_nat64_state();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.nat64_state)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_nat64_state(::threadnetwork::TelemetryData_BorderRoutingNat64State* nat64_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nat64_state_;
  }
  if (nat64_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nat64_state);
    if (message_arena != submessage_arena) {
      nat64_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nat64_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.nat64_state_ = nat64_state;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.nat64_state)
}

// repeated .threadnetwork.TelemetryData.Nat64Mapping nat64_mappings = 7;
inline int TelemetryData_WpanBorderRouter::_internal_nat64_mappings_size() const {
  return _impl_.nat64_mappings_.size();
}
inline int TelemetryData_WpanBorderRouter::nat64_mappings_size() const {
  return _internal_nat64_mappings_size();
}
inline void TelemetryData_WpanBorderRouter::clear_nat64_mappings() {
  _impl_.nat64_mappings_.Clear();
}
inline ::threadnetwork::TelemetryData_Nat64Mapping* TelemetryData_WpanBorderRouter::mutable_nat64_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.nat64_mappings)
  return _impl_.nat64_mappings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_Nat64Mapping >*
TelemetryData_WpanBorderRouter::mutable_nat64_mappings() {
  // @@protoc_insertion_point(field_mutable_list:threadnetwork.TelemetryData.WpanBorderRouter.nat64_mappings)
  return &_impl_.nat64_mappings_;
}
inline const ::threadnetwork::TelemetryData_Nat64Mapping& TelemetryData_WpanBorderRouter::_internal_nat64_mappings(int index) const {
  return _impl_.nat64_mappings_.Get(index);
}
inline const ::threadnetwork::TelemetryData_Nat64Mapping& TelemetryData_WpanBorderRouter::nat64_mappings(int index) const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.nat64_mappings)
  return _internal_nat64_mappings(index);
}
inline ::threadnetwork::TelemetryData_Nat64Mapping* TelemetryData_WpanBorderRouter::_internal_add_nat64_mappings() {
  return _impl_.nat64_mappings_.Add();
}
inline ::threadnetwork::TelemetryData_Nat64Mapping* TelemetryData_WpanBorderRouter::add_nat64_mappings() {
  ::threadnetwork::TelemetryData_Nat64Mapping* _add = _internal_add_nat64_mappings();
  // @@protoc_insertion_point(field_add:threadnetwork.TelemetryData.WpanBorderRouter.nat64_mappings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_Nat64Mapping >&
TelemetryData_WpanBorderRouter::nat64_mappings() const {
  // @@protoc_insertion_point(field_list:threadnetwork.TelemetryData.WpanBorderRouter.nat64_mappings)
  return _impl_.nat64_mappings_;
}

// optional .threadnetwork.TelemetryData.Dhcp6PdState dhcp6_pd_state = 8;
inline bool TelemetryData_WpanBorderRouter::_internal_has_dhcp6_pd_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_dhcp6_pd_state() const {
  return _internal_has_dhcp6_pd_state();
}
inline void TelemetryData_WpanBorderRouter::clear_dhcp6_pd_state() {
  _impl_.dhcp6_pd_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::threadnetwork::TelemetryData_Dhcp6PdState TelemetryData_WpanBorderRouter::_internal_dhcp6_pd_state() const {
  return static_cast< ::threadnetwork::TelemetryData_Dhcp6PdState >(_impl_.dhcp6_pd_state_);
}
inline ::threadnetwork::TelemetryData_Dhcp6PdState TelemetryData_WpanBorderRouter::dhcp6_pd_state() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.dhcp6_pd_state)
  return _internal_dhcp6_pd_state();
}
inline void TelemetryData_WpanBorderRouter::_internal_set_dhcp6_pd_state(::threadnetwork::TelemetryData_Dhcp6PdState value) {
  assert(::threadnetwork::TelemetryData_Dhcp6PdState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.dhcp6_pd_state_ = value;
}
inline void TelemetryData_WpanBorderRouter::set_dhcp6_pd_state(::threadnetwork::TelemetryData_Dhcp6PdState value) {
  _internal_set_dhcp6_pd_state(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanBorderRouter.dhcp6_pd_state)
}

// optional bytes hashed_pd_prefix = 9;
inline bool TelemetryData_WpanBorderRouter::_internal_has_hashed_pd_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_hashed_pd_prefix() const {
  return _internal_has_hashed_pd_prefix();
}
inline void TelemetryData_WpanBorderRouter::clear_hashed_pd_prefix() {
  _impl_.hashed_pd_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryData_WpanBorderRouter::hashed_pd_prefix() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.hashed_pd_prefix)
  return _internal_hashed_pd_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TelemetryData_WpanBorderRouter::set_hashed_pd_prefix(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hashed_pd_prefix_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.WpanBorderRouter.hashed_pd_prefix)
}
inline std::string* TelemetryData_WpanBorderRouter::mutable_hashed_pd_prefix() {
  std::string* _s = _internal_mutable_hashed_pd_prefix();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.hashed_pd_prefix)
  return _s;
}
inline const std::string& TelemetryData_WpanBorderRouter::_internal_hashed_pd_prefix() const {
  return _impl_.hashed_pd_prefix_.Get();
}
inline void TelemetryData_WpanBorderRouter::_internal_set_hashed_pd_prefix(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hashed_pd_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanBorderRouter::_internal_mutable_hashed_pd_prefix() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hashed_pd_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* TelemetryData_WpanBorderRouter::release_hashed_pd_prefix() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.hashed_pd_prefix)
  if (!_internal_has_hashed_pd_prefix()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hashed_pd_prefix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_pd_prefix_.IsDefault()) {
    _impl_.hashed_pd_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_hashed_pd_prefix(std::string* hashed_pd_prefix) {
  if (hashed_pd_prefix != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hashed_pd_prefix_.SetAllocated(hashed_pd_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_pd_prefix_.IsDefault()) {
    _impl_.hashed_pd_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.hashed_pd_prefix)
}

// optional .threadnetwork.TelemetryData.PdProcessedRaInfo pd_processed_ra_info = 10;
inline bool TelemetryData_WpanBorderRouter::_internal_has_pd_processed_ra_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pd_processed_ra_info_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_pd_processed_ra_info() const {
  return _internal_has_pd_processed_ra_info();
}
inline void TelemetryData_WpanBorderRouter::clear_pd_processed_ra_info() {
  if (_impl_.pd_processed_ra_info_ != nullptr) _impl_.pd_processed_ra_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::threadnetwork::TelemetryData_PdProcessedRaInfo& TelemetryData_WpanBorderRouter::_internal_pd_processed_ra_info() const {
  const ::threadnetwork::TelemetryData_PdProcessedRaInfo* p = _impl_.pd_processed_ra_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_PdProcessedRaInfo&>(
      ::threadnetwork::_TelemetryData_PdProcessedRaInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_PdProcessedRaInfo& TelemetryData_WpanBorderRouter::pd_processed_ra_info() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.pd_processed_ra_info)
  return _internal_pd_processed_ra_info();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_pd_processed_ra_info(
    ::threadnetwork::TelemetryData_PdProcessedRaInfo* pd_processed_ra_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pd_processed_ra_info_);
  }
  _impl_.pd_processed_ra_info_ = pd_processed_ra_info;
  if (pd_processed_ra_info) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.pd_processed_ra_info)
}
inline ::threadnetwork::TelemetryData_PdProcessedRaInfo* TelemetryData_WpanBorderRouter::release_pd_processed_ra_info() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* temp = _impl_.pd_processed_ra_info_;
  _impl_.pd_processed_ra_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_PdProcessedRaInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_pd_processed_ra_info() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.pd_processed_ra_info)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* temp = _impl_.pd_processed_ra_info_;
  _impl_.pd_processed_ra_info_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_PdProcessedRaInfo* TelemetryData_WpanBorderRouter::_internal_mutable_pd_processed_ra_info() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.pd_processed_ra_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_PdProcessedRaInfo>(GetArenaForAllocation());
    _impl_.pd_processed_ra_info_ = p;
  }
  return _impl_.pd_processed_ra_info_;
}
inline ::threadnetwork::TelemetryData_PdProcessedRaInfo* TelemetryData_WpanBorderRouter::mutable_pd_processed_ra_info() {
  ::threadnetwork::TelemetryData_PdProcessedRaInfo* _msg = _internal_mutable_pd_processed_ra_info();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.pd_processed_ra_info)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_pd_processed_ra_info(::threadnetwork::TelemetryData_PdProcessedRaInfo* pd_processed_ra_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pd_processed_ra_info_;
  }
  if (pd_processed_ra_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pd_processed_ra_info);
    if (message_arena != submessage_arena) {
      pd_processed_ra_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pd_processed_ra_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.pd_processed_ra_info_ = pd_processed_ra_info;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.pd_processed_ra_info)
}

// optional .threadnetwork.TelemetryData.TrelInfo trel_info = 11;
inline bool TelemetryData_WpanBorderRouter::_internal_has_trel_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trel_info_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_trel_info() const {
  return _internal_has_trel_info();
}
inline void TelemetryData_WpanBorderRouter::clear_trel_info() {
  if (_impl_.trel_info_ != nullptr) _impl_.trel_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::threadnetwork::TelemetryData_TrelInfo& TelemetryData_WpanBorderRouter::_internal_trel_info() const {
  const ::threadnetwork::TelemetryData_TrelInfo* p = _impl_.trel_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_TrelInfo&>(
      ::threadnetwork::_TelemetryData_TrelInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_TrelInfo& TelemetryData_WpanBorderRouter::trel_info() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.trel_info)
  return _internal_trel_info();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_trel_info(
    ::threadnetwork::TelemetryData_TrelInfo* trel_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trel_info_);
  }
  _impl_.trel_info_ = trel_info;
  if (trel_info) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.trel_info)
}
inline ::threadnetwork::TelemetryData_TrelInfo* TelemetryData_WpanBorderRouter::release_trel_info() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::threadnetwork::TelemetryData_TrelInfo* temp = _impl_.trel_info_;
  _impl_.trel_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_TrelInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_trel_info() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.trel_info)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::threadnetwork::TelemetryData_TrelInfo* temp = _impl_.trel_info_;
  _impl_.trel_info_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_TrelInfo* TelemetryData_WpanBorderRouter::_internal_mutable_trel_info() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.trel_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_TrelInfo>(GetArenaForAllocation());
    _impl_.trel_info_ = p;
  }
  return _impl_.trel_info_;
}
inline ::threadnetwork::TelemetryData_TrelInfo* TelemetryData_WpanBorderRouter::mutable_trel_info() {
  ::threadnetwork::TelemetryData_TrelInfo* _msg = _internal_mutable_trel_info();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.trel_info)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_trel_info(::threadnetwork::TelemetryData_TrelInfo* trel_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trel_info_;
  }
  if (trel_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trel_info);
    if (message_arena != submessage_arena) {
      trel_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trel_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.trel_info_ = trel_info;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.trel_info)
}

// optional .threadnetwork.TelemetryData.InfraLinkInfo infra_link_info = 12;
inline bool TelemetryData_WpanBorderRouter::_internal_has_infra_link_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.infra_link_info_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanBorderRouter::has_infra_link_info() const {
  return _internal_has_infra_link_info();
}
inline void TelemetryData_WpanBorderRouter::clear_infra_link_info() {
  if (_impl_.infra_link_info_ != nullptr) _impl_.infra_link_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::threadnetwork::TelemetryData_InfraLinkInfo& TelemetryData_WpanBorderRouter::_internal_infra_link_info() const {
  const ::threadnetwork::TelemetryData_InfraLinkInfo* p = _impl_.infra_link_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_InfraLinkInfo&>(
      ::threadnetwork::_TelemetryData_InfraLinkInfo_default_instance_);
}
inline const ::threadnetwork::TelemetryData_InfraLinkInfo& TelemetryData_WpanBorderRouter::infra_link_info() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanBorderRouter.infra_link_info)
  return _internal_infra_link_info();
}
inline void TelemetryData_WpanBorderRouter::unsafe_arena_set_allocated_infra_link_info(
    ::threadnetwork::TelemetryData_InfraLinkInfo* infra_link_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.infra_link_info_);
  }
  _impl_.infra_link_info_ = infra_link_info;
  if (infra_link_info) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.infra_link_info)
}
inline ::threadnetwork::TelemetryData_InfraLinkInfo* TelemetryData_WpanBorderRouter::release_infra_link_info() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::threadnetwork::TelemetryData_InfraLinkInfo* temp = _impl_.infra_link_info_;
  _impl_.infra_link_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_InfraLinkInfo* TelemetryData_WpanBorderRouter::unsafe_arena_release_infra_link_info() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanBorderRouter.infra_link_info)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::threadnetwork::TelemetryData_InfraLinkInfo* temp = _impl_.infra_link_info_;
  _impl_.infra_link_info_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_InfraLinkInfo* TelemetryData_WpanBorderRouter::_internal_mutable_infra_link_info() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.infra_link_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_InfraLinkInfo>(GetArenaForAllocation());
    _impl_.infra_link_info_ = p;
  }
  return _impl_.infra_link_info_;
}
inline ::threadnetwork::TelemetryData_InfraLinkInfo* TelemetryData_WpanBorderRouter::mutable_infra_link_info() {
  ::threadnetwork::TelemetryData_InfraLinkInfo* _msg = _internal_mutable_infra_link_info();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanBorderRouter.infra_link_info)
  return _msg;
}
inline void TelemetryData_WpanBorderRouter::set_allocated_infra_link_info(::threadnetwork::TelemetryData_InfraLinkInfo* infra_link_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.infra_link_info_;
  }
  if (infra_link_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(infra_link_info);
    if (message_arena != submessage_arena) {
      infra_link_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, infra_link_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.infra_link_info_ = infra_link_info;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanBorderRouter.infra_link_info)
}

// -------------------------------------------------------------------

// TelemetryData_RcpStabilityStatistics

// optional uint32 rcp_timeout_count = 1;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_rcp_timeout_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_rcp_timeout_count() const {
  return _internal_has_rcp_timeout_count();
}
inline void TelemetryData_RcpStabilityStatistics::clear_rcp_timeout_count() {
  _impl_.rcp_timeout_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::_internal_rcp_timeout_count() const {
  return _impl_.rcp_timeout_count_;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::rcp_timeout_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_timeout_count)
  return _internal_rcp_timeout_count();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_rcp_timeout_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rcp_timeout_count_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_rcp_timeout_count(uint32_t value) {
  _internal_set_rcp_timeout_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_timeout_count)
}

// optional uint32 rcp_reset_count = 2;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_rcp_reset_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_rcp_reset_count() const {
  return _internal_has_rcp_reset_count();
}
inline void TelemetryData_RcpStabilityStatistics::clear_rcp_reset_count() {
  _impl_.rcp_reset_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::_internal_rcp_reset_count() const {
  return _impl_.rcp_reset_count_;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::rcp_reset_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_reset_count)
  return _internal_rcp_reset_count();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_rcp_reset_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rcp_reset_count_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_rcp_reset_count(uint32_t value) {
  _internal_set_rcp_reset_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_reset_count)
}

// optional uint32 rcp_restoration_count = 3;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_rcp_restoration_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_rcp_restoration_count() const {
  return _internal_has_rcp_restoration_count();
}
inline void TelemetryData_RcpStabilityStatistics::clear_rcp_restoration_count() {
  _impl_.rcp_restoration_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::_internal_rcp_restoration_count() const {
  return _impl_.rcp_restoration_count_;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::rcp_restoration_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_restoration_count)
  return _internal_rcp_restoration_count();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_rcp_restoration_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rcp_restoration_count_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_rcp_restoration_count(uint32_t value) {
  _internal_set_rcp_restoration_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_restoration_count)
}

// optional uint32 spinel_parse_error_count = 4;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_spinel_parse_error_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_spinel_parse_error_count() const {
  return _internal_has_spinel_parse_error_count();
}
inline void TelemetryData_RcpStabilityStatistics::clear_spinel_parse_error_count() {
  _impl_.spinel_parse_error_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::_internal_spinel_parse_error_count() const {
  return _impl_.spinel_parse_error_count_;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::spinel_parse_error_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.spinel_parse_error_count)
  return _internal_spinel_parse_error_count();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_spinel_parse_error_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.spinel_parse_error_count_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_spinel_parse_error_count(uint32_t value) {
  _internal_set_spinel_parse_error_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.spinel_parse_error_count)
}

// optional int32 rcp_firmware_update_count = 5;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_rcp_firmware_update_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_rcp_firmware_update_count() const {
  return _internal_has_rcp_firmware_update_count();
}
inline void TelemetryData_RcpStabilityStatistics::clear_rcp_firmware_update_count() {
  _impl_.rcp_firmware_update_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TelemetryData_RcpStabilityStatistics::_internal_rcp_firmware_update_count() const {
  return _impl_.rcp_firmware_update_count_;
}
inline int32_t TelemetryData_RcpStabilityStatistics::rcp_firmware_update_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_firmware_update_count)
  return _internal_rcp_firmware_update_count();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_rcp_firmware_update_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rcp_firmware_update_count_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_rcp_firmware_update_count(int32_t value) {
  _internal_set_rcp_firmware_update_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.rcp_firmware_update_count)
}

// optional uint32 thread_stack_uptime = 6;
inline bool TelemetryData_RcpStabilityStatistics::_internal_has_thread_stack_uptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_RcpStabilityStatistics::has_thread_stack_uptime() const {
  return _internal_has_thread_stack_uptime();
}
inline void TelemetryData_RcpStabilityStatistics::clear_thread_stack_uptime() {
  _impl_.thread_stack_uptime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::_internal_thread_stack_uptime() const {
  return _impl_.thread_stack_uptime_;
}
inline uint32_t TelemetryData_RcpStabilityStatistics::thread_stack_uptime() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpStabilityStatistics.thread_stack_uptime)
  return _internal_thread_stack_uptime();
}
inline void TelemetryData_RcpStabilityStatistics::_internal_set_thread_stack_uptime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.thread_stack_uptime_ = value;
}
inline void TelemetryData_RcpStabilityStatistics::set_thread_stack_uptime(uint32_t value) {
  _internal_set_thread_stack_uptime(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpStabilityStatistics.thread_stack_uptime)
}

// -------------------------------------------------------------------

// TelemetryData_RcpInterfaceStatistics

// optional uint32 rcp_interface_type = 1;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_rcp_interface_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_rcp_interface_type() const {
  return _internal_has_rcp_interface_type();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_rcp_interface_type() {
  _impl_.rcp_interface_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_RcpInterfaceStatistics::_internal_rcp_interface_type() const {
  return _impl_.rcp_interface_type_;
}
inline uint32_t TelemetryData_RcpInterfaceStatistics::rcp_interface_type() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.rcp_interface_type)
  return _internal_rcp_interface_type();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_rcp_interface_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.rcp_interface_type_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_rcp_interface_type(uint32_t value) {
  _internal_set_rcp_interface_type(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.rcp_interface_type)
}

// optional uint64 transferred_frames_count = 2;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_transferred_frames_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_transferred_frames_count() const {
  return _internal_has_transferred_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_transferred_frames_count() {
  _impl_.transferred_frames_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_transferred_frames_count() const {
  return _impl_.transferred_frames_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::transferred_frames_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_frames_count)
  return _internal_transferred_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_transferred_frames_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transferred_frames_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_transferred_frames_count(uint64_t value) {
  _internal_set_transferred_frames_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_frames_count)
}

// optional uint64 transferred_valid_frames_count = 3;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_transferred_valid_frames_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_transferred_valid_frames_count() const {
  return _internal_has_transferred_valid_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_transferred_valid_frames_count() {
  _impl_.transferred_valid_frames_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_transferred_valid_frames_count() const {
  return _impl_.transferred_valid_frames_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::transferred_valid_frames_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_valid_frames_count)
  return _internal_transferred_valid_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_transferred_valid_frames_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transferred_valid_frames_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_transferred_valid_frames_count(uint64_t value) {
  _internal_set_transferred_valid_frames_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_valid_frames_count)
}

// optional uint64 transferred_garbage_frames_count = 4;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_transferred_garbage_frames_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_transferred_garbage_frames_count() const {
  return _internal_has_transferred_garbage_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_transferred_garbage_frames_count() {
  _impl_.transferred_garbage_frames_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_transferred_garbage_frames_count() const {
  return _impl_.transferred_garbage_frames_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::transferred_garbage_frames_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_garbage_frames_count)
  return _internal_transferred_garbage_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_transferred_garbage_frames_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transferred_garbage_frames_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_transferred_garbage_frames_count(uint64_t value) {
  _internal_set_transferred_garbage_frames_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.transferred_garbage_frames_count)
}

// optional uint64 rx_frames_count = 5;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_rx_frames_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_rx_frames_count() const {
  return _internal_has_rx_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_rx_frames_count() {
  _impl_.rx_frames_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_rx_frames_count() const {
  return _impl_.rx_frames_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::rx_frames_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.rx_frames_count)
  return _internal_rx_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_rx_frames_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rx_frames_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_rx_frames_count(uint64_t value) {
  _internal_set_rx_frames_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.rx_frames_count)
}

// optional uint64 rx_bytes_count = 6;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_rx_bytes_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_rx_bytes_count() const {
  return _internal_has_rx_bytes_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_rx_bytes_count() {
  _impl_.rx_bytes_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_rx_bytes_count() const {
  return _impl_.rx_bytes_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::rx_bytes_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.rx_bytes_count)
  return _internal_rx_bytes_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_rx_bytes_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rx_bytes_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_rx_bytes_count(uint64_t value) {
  _internal_set_rx_bytes_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.rx_bytes_count)
}

// optional uint64 tx_frames_count = 7;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_tx_frames_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_tx_frames_count() const {
  return _internal_has_tx_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_tx_frames_count() {
  _impl_.tx_frames_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_tx_frames_count() const {
  return _impl_.tx_frames_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::tx_frames_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.tx_frames_count)
  return _internal_tx_frames_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_tx_frames_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tx_frames_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_tx_frames_count(uint64_t value) {
  _internal_set_tx_frames_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.tx_frames_count)
}

// optional uint64 tx_bytes_count = 8;
inline bool TelemetryData_RcpInterfaceStatistics::_internal_has_tx_bytes_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_RcpInterfaceStatistics::has_tx_bytes_count() const {
  return _internal_has_tx_bytes_count();
}
inline void TelemetryData_RcpInterfaceStatistics::clear_tx_bytes_count() {
  _impl_.tx_bytes_count_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::_internal_tx_bytes_count() const {
  return _impl_.tx_bytes_count_;
}
inline uint64_t TelemetryData_RcpInterfaceStatistics::tx_bytes_count() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.RcpInterfaceStatistics.tx_bytes_count)
  return _internal_tx_bytes_count();
}
inline void TelemetryData_RcpInterfaceStatistics::_internal_set_tx_bytes_count(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tx_bytes_count_ = value;
}
inline void TelemetryData_RcpInterfaceStatistics::set_tx_bytes_count(uint64_t value) {
  _internal_set_tx_bytes_count(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.RcpInterfaceStatistics.tx_bytes_count)
}

// -------------------------------------------------------------------

// TelemetryData_WpanRcp

// optional .threadnetwork.TelemetryData.RcpStabilityStatistics rcp_stability_statistics = 1;
inline bool TelemetryData_WpanRcp::_internal_has_rcp_stability_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rcp_stability_statistics_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanRcp::has_rcp_stability_statistics() const {
  return _internal_has_rcp_stability_statistics();
}
inline void TelemetryData_WpanRcp::clear_rcp_stability_statistics() {
  if (_impl_.rcp_stability_statistics_ != nullptr) _impl_.rcp_stability_statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_RcpStabilityStatistics& TelemetryData_WpanRcp::_internal_rcp_stability_statistics() const {
  const ::threadnetwork::TelemetryData_RcpStabilityStatistics* p = _impl_.rcp_stability_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_RcpStabilityStatistics&>(
      ::threadnetwork::_TelemetryData_RcpStabilityStatistics_default_instance_);
}
inline const ::threadnetwork::TelemetryData_RcpStabilityStatistics& TelemetryData_WpanRcp::rcp_stability_statistics() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanRcp.rcp_stability_statistics)
  return _internal_rcp_stability_statistics();
}
inline void TelemetryData_WpanRcp::unsafe_arena_set_allocated_rcp_stability_statistics(
    ::threadnetwork::TelemetryData_RcpStabilityStatistics* rcp_stability_statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rcp_stability_statistics_);
  }
  _impl_.rcp_stability_statistics_ = rcp_stability_statistics;
  if (rcp_stability_statistics) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanRcp.rcp_stability_statistics)
}
inline ::threadnetwork::TelemetryData_RcpStabilityStatistics* TelemetryData_WpanRcp::release_rcp_stability_statistics() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* temp = _impl_.rcp_stability_statistics_;
  _impl_.rcp_stability_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_RcpStabilityStatistics* TelemetryData_WpanRcp::unsafe_arena_release_rcp_stability_statistics() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanRcp.rcp_stability_statistics)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* temp = _impl_.rcp_stability_statistics_;
  _impl_.rcp_stability_statistics_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_RcpStabilityStatistics* TelemetryData_WpanRcp::_internal_mutable_rcp_stability_statistics() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rcp_stability_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_RcpStabilityStatistics>(GetArenaForAllocation());
    _impl_.rcp_stability_statistics_ = p;
  }
  return _impl_.rcp_stability_statistics_;
}
inline ::threadnetwork::TelemetryData_RcpStabilityStatistics* TelemetryData_WpanRcp::mutable_rcp_stability_statistics() {
  ::threadnetwork::TelemetryData_RcpStabilityStatistics* _msg = _internal_mutable_rcp_stability_statistics();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanRcp.rcp_stability_statistics)
  return _msg;
}
inline void TelemetryData_WpanRcp::set_allocated_rcp_stability_statistics(::threadnetwork::TelemetryData_RcpStabilityStatistics* rcp_stability_statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rcp_stability_statistics_;
  }
  if (rcp_stability_statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rcp_stability_statistics);
    if (message_arena != submessage_arena) {
      rcp_stability_statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rcp_stability_statistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rcp_stability_statistics_ = rcp_stability_statistics;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanRcp.rcp_stability_statistics)
}

// optional .threadnetwork.TelemetryData.RcpInterfaceStatistics rcp_interface_statistics = 2;
inline bool TelemetryData_WpanRcp::_internal_has_rcp_interface_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rcp_interface_statistics_ != nullptr);
  return value;
}
inline bool TelemetryData_WpanRcp::has_rcp_interface_statistics() const {
  return _internal_has_rcp_interface_statistics();
}
inline void TelemetryData_WpanRcp::clear_rcp_interface_statistics() {
  if (_impl_.rcp_interface_statistics_ != nullptr) _impl_.rcp_interface_statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_RcpInterfaceStatistics& TelemetryData_WpanRcp::_internal_rcp_interface_statistics() const {
  const ::threadnetwork::TelemetryData_RcpInterfaceStatistics* p = _impl_.rcp_interface_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_RcpInterfaceStatistics&>(
      ::threadnetwork::_TelemetryData_RcpInterfaceStatistics_default_instance_);
}
inline const ::threadnetwork::TelemetryData_RcpInterfaceStatistics& TelemetryData_WpanRcp::rcp_interface_statistics() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.WpanRcp.rcp_interface_statistics)
  return _internal_rcp_interface_statistics();
}
inline void TelemetryData_WpanRcp::unsafe_arena_set_allocated_rcp_interface_statistics(
    ::threadnetwork::TelemetryData_RcpInterfaceStatistics* rcp_interface_statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rcp_interface_statistics_);
  }
  _impl_.rcp_interface_statistics_ = rcp_interface_statistics;
  if (rcp_interface_statistics) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.WpanRcp.rcp_interface_statistics)
}
inline ::threadnetwork::TelemetryData_RcpInterfaceStatistics* TelemetryData_WpanRcp::release_rcp_interface_statistics() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* temp = _impl_.rcp_interface_statistics_;
  _impl_.rcp_interface_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_RcpInterfaceStatistics* TelemetryData_WpanRcp::unsafe_arena_release_rcp_interface_statistics() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.WpanRcp.rcp_interface_statistics)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* temp = _impl_.rcp_interface_statistics_;
  _impl_.rcp_interface_statistics_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_RcpInterfaceStatistics* TelemetryData_WpanRcp::_internal_mutable_rcp_interface_statistics() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rcp_interface_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_RcpInterfaceStatistics>(GetArenaForAllocation());
    _impl_.rcp_interface_statistics_ = p;
  }
  return _impl_.rcp_interface_statistics_;
}
inline ::threadnetwork::TelemetryData_RcpInterfaceStatistics* TelemetryData_WpanRcp::mutable_rcp_interface_statistics() {
  ::threadnetwork::TelemetryData_RcpInterfaceStatistics* _msg = _internal_mutable_rcp_interface_statistics();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.WpanRcp.rcp_interface_statistics)
  return _msg;
}
inline void TelemetryData_WpanRcp::set_allocated_rcp_interface_statistics(::threadnetwork::TelemetryData_RcpInterfaceStatistics* rcp_interface_statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rcp_interface_statistics_;
  }
  if (rcp_interface_statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rcp_interface_statistics);
    if (message_arena != submessage_arena) {
      rcp_interface_statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rcp_interface_statistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rcp_interface_statistics_ = rcp_interface_statistics;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.WpanRcp.rcp_interface_statistics)
}

// -------------------------------------------------------------------

// TelemetryData_CoexMetrics

// optional uint32 count_tx_request = 1;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_request() const {
  return _internal_has_count_tx_request();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_request() {
  _impl_.count_tx_request_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_request() const {
  return _impl_.count_tx_request_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_request() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_request)
  return _internal_count_tx_request();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_request(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.count_tx_request_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_request(uint32_t value) {
  _internal_set_count_tx_request(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_request)
}

// optional uint32 count_tx_grant_immediate = 2;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_grant_immediate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_grant_immediate() const {
  return _internal_has_count_tx_grant_immediate();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_grant_immediate() {
  _impl_.count_tx_grant_immediate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_grant_immediate() const {
  return _impl_.count_tx_grant_immediate_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_grant_immediate() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_immediate)
  return _internal_count_tx_grant_immediate();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_grant_immediate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_tx_grant_immediate_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_grant_immediate(uint32_t value) {
  _internal_set_count_tx_grant_immediate(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_immediate)
}

// optional uint32 count_tx_grant_wait = 3;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_grant_wait() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_grant_wait() const {
  return _internal_has_count_tx_grant_wait();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_grant_wait() {
  _impl_.count_tx_grant_wait_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_grant_wait() const {
  return _impl_.count_tx_grant_wait_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_grant_wait() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait)
  return _internal_count_tx_grant_wait();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_grant_wait(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_tx_grant_wait_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_grant_wait(uint32_t value) {
  _internal_set_count_tx_grant_wait(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait)
}

// optional uint32 count_tx_grant_wait_activated = 4;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_grant_wait_activated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_grant_wait_activated() const {
  return _internal_has_count_tx_grant_wait_activated();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_grant_wait_activated() {
  _impl_.count_tx_grant_wait_activated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_grant_wait_activated() const {
  return _impl_.count_tx_grant_wait_activated_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_grant_wait_activated() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait_activated)
  return _internal_count_tx_grant_wait_activated();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_grant_wait_activated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.count_tx_grant_wait_activated_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_grant_wait_activated(uint32_t value) {
  _internal_set_count_tx_grant_wait_activated(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait_activated)
}

// optional uint32 count_tx_grant_wait_timeout = 5;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_grant_wait_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_grant_wait_timeout() const {
  return _internal_has_count_tx_grant_wait_timeout();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_grant_wait_timeout() {
  _impl_.count_tx_grant_wait_timeout_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_grant_wait_timeout() const {
  return _impl_.count_tx_grant_wait_timeout_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_grant_wait_timeout() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait_timeout)
  return _internal_count_tx_grant_wait_timeout();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_grant_wait_timeout(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_tx_grant_wait_timeout_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_grant_wait_timeout(uint32_t value) {
  _internal_set_count_tx_grant_wait_timeout(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_wait_timeout)
}

// optional uint32 count_tx_grant_deactivated_during_request = 6;
inline bool TelemetryData_CoexMetrics::_internal_has_count_tx_grant_deactivated_during_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_tx_grant_deactivated_during_request() const {
  return _internal_has_count_tx_grant_deactivated_during_request();
}
inline void TelemetryData_CoexMetrics::clear_count_tx_grant_deactivated_during_request() {
  _impl_.count_tx_grant_deactivated_during_request_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_tx_grant_deactivated_during_request() const {
  return _impl_.count_tx_grant_deactivated_during_request_;
}
inline uint32_t TelemetryData_CoexMetrics::count_tx_grant_deactivated_during_request() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_deactivated_during_request)
  return _internal_count_tx_grant_deactivated_during_request();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_tx_grant_deactivated_during_request(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.count_tx_grant_deactivated_during_request_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_tx_grant_deactivated_during_request(uint32_t value) {
  _internal_set_count_tx_grant_deactivated_during_request(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_tx_grant_deactivated_during_request)
}

// optional uint32 tx_average_request_to_grant_time_us = 7;
inline bool TelemetryData_CoexMetrics::_internal_has_tx_average_request_to_grant_time_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_tx_average_request_to_grant_time_us() const {
  return _internal_has_tx_average_request_to_grant_time_us();
}
inline void TelemetryData_CoexMetrics::clear_tx_average_request_to_grant_time_us() {
  _impl_.tx_average_request_to_grant_time_us_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_tx_average_request_to_grant_time_us() const {
  return _impl_.tx_average_request_to_grant_time_us_;
}
inline uint32_t TelemetryData_CoexMetrics::tx_average_request_to_grant_time_us() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.tx_average_request_to_grant_time_us)
  return _internal_tx_average_request_to_grant_time_us();
}
inline void TelemetryData_CoexMetrics::_internal_set_tx_average_request_to_grant_time_us(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tx_average_request_to_grant_time_us_ = value;
}
inline void TelemetryData_CoexMetrics::set_tx_average_request_to_grant_time_us(uint32_t value) {
  _internal_set_tx_average_request_to_grant_time_us(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.tx_average_request_to_grant_time_us)
}

// optional uint32 count_rx_request = 8;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_request() const {
  return _internal_has_count_rx_request();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_request() {
  _impl_.count_rx_request_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_request() const {
  return _impl_.count_rx_request_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_request() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_request)
  return _internal_count_rx_request();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_request(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.count_rx_request_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_request(uint32_t value) {
  _internal_set_count_rx_request(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_request)
}

// optional uint32 count_rx_grant_immediate = 9;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_immediate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_immediate() const {
  return _internal_has_count_rx_grant_immediate();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_immediate() {
  _impl_.count_rx_grant_immediate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_immediate() const {
  return _impl_.count_rx_grant_immediate_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_immediate() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_immediate)
  return _internal_count_rx_grant_immediate();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_immediate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.count_rx_grant_immediate_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_immediate(uint32_t value) {
  _internal_set_count_rx_grant_immediate(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_immediate)
}

// optional uint32 count_rx_grant_wait = 10;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_wait() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_wait() const {
  return _internal_has_count_rx_grant_wait();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_wait() {
  _impl_.count_rx_grant_wait_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_wait() const {
  return _impl_.count_rx_grant_wait_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_wait() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait)
  return _internal_count_rx_grant_wait();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_wait(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.count_rx_grant_wait_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_wait(uint32_t value) {
  _internal_set_count_rx_grant_wait(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait)
}

// optional uint32 count_rx_grant_wait_activated = 11;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_wait_activated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_wait_activated() const {
  return _internal_has_count_rx_grant_wait_activated();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_wait_activated() {
  _impl_.count_rx_grant_wait_activated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_wait_activated() const {
  return _impl_.count_rx_grant_wait_activated_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_wait_activated() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait_activated)
  return _internal_count_rx_grant_wait_activated();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_wait_activated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.count_rx_grant_wait_activated_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_wait_activated(uint32_t value) {
  _internal_set_count_rx_grant_wait_activated(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait_activated)
}

// optional uint32 count_rx_grant_wait_timeout = 12;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_wait_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_wait_timeout() const {
  return _internal_has_count_rx_grant_wait_timeout();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_wait_timeout() {
  _impl_.count_rx_grant_wait_timeout_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_wait_timeout() const {
  return _impl_.count_rx_grant_wait_timeout_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_wait_timeout() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait_timeout)
  return _internal_count_rx_grant_wait_timeout();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_wait_timeout(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.count_rx_grant_wait_timeout_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_wait_timeout(uint32_t value) {
  _internal_set_count_rx_grant_wait_timeout(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_wait_timeout)
}

// optional uint32 count_rx_grant_deactivated_during_request = 13;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_deactivated_during_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_deactivated_during_request() const {
  return _internal_has_count_rx_grant_deactivated_during_request();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_deactivated_during_request() {
  _impl_.count_rx_grant_deactivated_during_request_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_deactivated_during_request() const {
  return _impl_.count_rx_grant_deactivated_during_request_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_deactivated_during_request() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_deactivated_during_request)
  return _internal_count_rx_grant_deactivated_during_request();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_deactivated_during_request(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.count_rx_grant_deactivated_during_request_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_deactivated_during_request(uint32_t value) {
  _internal_set_count_rx_grant_deactivated_during_request(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_deactivated_during_request)
}

// optional uint32 count_rx_grant_none = 14;
inline bool TelemetryData_CoexMetrics::_internal_has_count_rx_grant_none() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_count_rx_grant_none() const {
  return _internal_has_count_rx_grant_none();
}
inline void TelemetryData_CoexMetrics::clear_count_rx_grant_none() {
  _impl_.count_rx_grant_none_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_count_rx_grant_none() const {
  return _impl_.count_rx_grant_none_;
}
inline uint32_t TelemetryData_CoexMetrics::count_rx_grant_none() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_none)
  return _internal_count_rx_grant_none();
}
inline void TelemetryData_CoexMetrics::_internal_set_count_rx_grant_none(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.count_rx_grant_none_ = value;
}
inline void TelemetryData_CoexMetrics::set_count_rx_grant_none(uint32_t value) {
  _internal_set_count_rx_grant_none(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.count_rx_grant_none)
}

// optional uint32 rx_average_request_to_grant_time_us = 15;
inline bool TelemetryData_CoexMetrics::_internal_has_rx_average_request_to_grant_time_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TelemetryData_CoexMetrics::has_rx_average_request_to_grant_time_us() const {
  return _internal_has_rx_average_request_to_grant_time_us();
}
inline void TelemetryData_CoexMetrics::clear_rx_average_request_to_grant_time_us() {
  _impl_.rx_average_request_to_grant_time_us_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t TelemetryData_CoexMetrics::_internal_rx_average_request_to_grant_time_us() const {
  return _impl_.rx_average_request_to_grant_time_us_;
}
inline uint32_t TelemetryData_CoexMetrics::rx_average_request_to_grant_time_us() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.CoexMetrics.rx_average_request_to_grant_time_us)
  return _internal_rx_average_request_to_grant_time_us();
}
inline void TelemetryData_CoexMetrics::_internal_set_rx_average_request_to_grant_time_us(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.rx_average_request_to_grant_time_us_ = value;
}
inline void TelemetryData_CoexMetrics::set_rx_average_request_to_grant_time_us(uint32_t value) {
  _internal_set_rx_average_request_to_grant_time_us(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.CoexMetrics.rx_average_request_to_grant_time_us)
}

// -------------------------------------------------------------------

// TelemetryData_LinkMetricsEntry

// optional int32 link_margin = 1;
inline bool TelemetryData_LinkMetricsEntry::_internal_has_link_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TelemetryData_LinkMetricsEntry::has_link_margin() const {
  return _internal_has_link_margin();
}
inline void TelemetryData_LinkMetricsEntry::clear_link_margin() {
  _impl_.link_margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TelemetryData_LinkMetricsEntry::_internal_link_margin() const {
  return _impl_.link_margin_;
}
inline int32_t TelemetryData_LinkMetricsEntry::link_margin() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.LinkMetricsEntry.link_margin)
  return _internal_link_margin();
}
inline void TelemetryData_LinkMetricsEntry::_internal_set_link_margin(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.link_margin_ = value;
}
inline void TelemetryData_LinkMetricsEntry::set_link_margin(int32_t value) {
  _internal_set_link_margin(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.LinkMetricsEntry.link_margin)
}

// optional int32 rssi = 2;
inline bool TelemetryData_LinkMetricsEntry::_internal_has_rssi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TelemetryData_LinkMetricsEntry::has_rssi() const {
  return _internal_has_rssi();
}
inline void TelemetryData_LinkMetricsEntry::clear_rssi() {
  _impl_.rssi_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TelemetryData_LinkMetricsEntry::_internal_rssi() const {
  return _impl_.rssi_;
}
inline int32_t TelemetryData_LinkMetricsEntry::rssi() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.LinkMetricsEntry.rssi)
  return _internal_rssi();
}
inline void TelemetryData_LinkMetricsEntry::_internal_set_rssi(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rssi_ = value;
}
inline void TelemetryData_LinkMetricsEntry::set_rssi(int32_t value) {
  _internal_set_rssi(value);
  // @@protoc_insertion_point(field_set:threadnetwork.TelemetryData.LinkMetricsEntry.rssi)
}

// -------------------------------------------------------------------

// TelemetryData_LowPowerMetrics

// repeated .threadnetwork.TelemetryData.LinkMetricsEntry link_metrics_entries = 1;
inline int TelemetryData_LowPowerMetrics::_internal_link_metrics_entries_size() const {
  return _impl_.link_metrics_entries_.size();
}
inline int TelemetryData_LowPowerMetrics::link_metrics_entries_size() const {
  return _internal_link_metrics_entries_size();
}
inline void TelemetryData_LowPowerMetrics::clear_link_metrics_entries() {
  _impl_.link_metrics_entries_.Clear();
}
inline ::threadnetwork::TelemetryData_LinkMetricsEntry* TelemetryData_LowPowerMetrics::mutable_link_metrics_entries(int index) {
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.LowPowerMetrics.link_metrics_entries)
  return _impl_.link_metrics_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_LinkMetricsEntry >*
TelemetryData_LowPowerMetrics::mutable_link_metrics_entries() {
  // @@protoc_insertion_point(field_mutable_list:threadnetwork.TelemetryData.LowPowerMetrics.link_metrics_entries)
  return &_impl_.link_metrics_entries_;
}
inline const ::threadnetwork::TelemetryData_LinkMetricsEntry& TelemetryData_LowPowerMetrics::_internal_link_metrics_entries(int index) const {
  return _impl_.link_metrics_entries_.Get(index);
}
inline const ::threadnetwork::TelemetryData_LinkMetricsEntry& TelemetryData_LowPowerMetrics::link_metrics_entries(int index) const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.LowPowerMetrics.link_metrics_entries)
  return _internal_link_metrics_entries(index);
}
inline ::threadnetwork::TelemetryData_LinkMetricsEntry* TelemetryData_LowPowerMetrics::_internal_add_link_metrics_entries() {
  return _impl_.link_metrics_entries_.Add();
}
inline ::threadnetwork::TelemetryData_LinkMetricsEntry* TelemetryData_LowPowerMetrics::add_link_metrics_entries() {
  ::threadnetwork::TelemetryData_LinkMetricsEntry* _add = _internal_add_link_metrics_entries();
  // @@protoc_insertion_point(field_add:threadnetwork.TelemetryData.LowPowerMetrics.link_metrics_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_LinkMetricsEntry >&
TelemetryData_LowPowerMetrics::link_metrics_entries() const {
  // @@protoc_insertion_point(field_list:threadnetwork.TelemetryData.LowPowerMetrics.link_metrics_entries)
  return _impl_.link_metrics_entries_;
}

// -------------------------------------------------------------------

// TelemetryData

// optional .threadnetwork.TelemetryData.WpanStats wpan_stats = 1;
inline bool TelemetryData::_internal_has_wpan_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wpan_stats_ != nullptr);
  return value;
}
inline bool TelemetryData::has_wpan_stats() const {
  return _internal_has_wpan_stats();
}
inline void TelemetryData::clear_wpan_stats() {
  if (_impl_.wpan_stats_ != nullptr) _impl_.wpan_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::threadnetwork::TelemetryData_WpanStats& TelemetryData::_internal_wpan_stats() const {
  const ::threadnetwork::TelemetryData_WpanStats* p = _impl_.wpan_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_WpanStats&>(
      ::threadnetwork::_TelemetryData_WpanStats_default_instance_);
}
inline const ::threadnetwork::TelemetryData_WpanStats& TelemetryData::wpan_stats() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.wpan_stats)
  return _internal_wpan_stats();
}
inline void TelemetryData::unsafe_arena_set_allocated_wpan_stats(
    ::threadnetwork::TelemetryData_WpanStats* wpan_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wpan_stats_);
  }
  _impl_.wpan_stats_ = wpan_stats;
  if (wpan_stats) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.wpan_stats)
}
inline ::threadnetwork::TelemetryData_WpanStats* TelemetryData::release_wpan_stats() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_WpanStats* temp = _impl_.wpan_stats_;
  _impl_.wpan_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanStats* TelemetryData::unsafe_arena_release_wpan_stats() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.wpan_stats)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::threadnetwork::TelemetryData_WpanStats* temp = _impl_.wpan_stats_;
  _impl_.wpan_stats_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanStats* TelemetryData::_internal_mutable_wpan_stats() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.wpan_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_WpanStats>(GetArenaForAllocation());
    _impl_.wpan_stats_ = p;
  }
  return _impl_.wpan_stats_;
}
inline ::threadnetwork::TelemetryData_WpanStats* TelemetryData::mutable_wpan_stats() {
  ::threadnetwork::TelemetryData_WpanStats* _msg = _internal_mutable_wpan_stats();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.wpan_stats)
  return _msg;
}
inline void TelemetryData::set_allocated_wpan_stats(::threadnetwork::TelemetryData_WpanStats* wpan_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wpan_stats_;
  }
  if (wpan_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wpan_stats);
    if (message_arena != submessage_arena) {
      wpan_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wpan_stats, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.wpan_stats_ = wpan_stats;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.wpan_stats)
}

// optional .threadnetwork.TelemetryData.WpanTopoFull wpan_topo_full = 2;
inline bool TelemetryData::_internal_has_wpan_topo_full() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wpan_topo_full_ != nullptr);
  return value;
}
inline bool TelemetryData::has_wpan_topo_full() const {
  return _internal_has_wpan_topo_full();
}
inline void TelemetryData::clear_wpan_topo_full() {
  if (_impl_.wpan_topo_full_ != nullptr) _impl_.wpan_topo_full_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::threadnetwork::TelemetryData_WpanTopoFull& TelemetryData::_internal_wpan_topo_full() const {
  const ::threadnetwork::TelemetryData_WpanTopoFull* p = _impl_.wpan_topo_full_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_WpanTopoFull&>(
      ::threadnetwork::_TelemetryData_WpanTopoFull_default_instance_);
}
inline const ::threadnetwork::TelemetryData_WpanTopoFull& TelemetryData::wpan_topo_full() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.wpan_topo_full)
  return _internal_wpan_topo_full();
}
inline void TelemetryData::unsafe_arena_set_allocated_wpan_topo_full(
    ::threadnetwork::TelemetryData_WpanTopoFull* wpan_topo_full) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wpan_topo_full_);
  }
  _impl_.wpan_topo_full_ = wpan_topo_full;
  if (wpan_topo_full) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.wpan_topo_full)
}
inline ::threadnetwork::TelemetryData_WpanTopoFull* TelemetryData::release_wpan_topo_full() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_WpanTopoFull* temp = _impl_.wpan_topo_full_;
  _impl_.wpan_topo_full_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanTopoFull* TelemetryData::unsafe_arena_release_wpan_topo_full() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.wpan_topo_full)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::threadnetwork::TelemetryData_WpanTopoFull* temp = _impl_.wpan_topo_full_;
  _impl_.wpan_topo_full_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanTopoFull* TelemetryData::_internal_mutable_wpan_topo_full() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.wpan_topo_full_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_WpanTopoFull>(GetArenaForAllocation());
    _impl_.wpan_topo_full_ = p;
  }
  return _impl_.wpan_topo_full_;
}
inline ::threadnetwork::TelemetryData_WpanTopoFull* TelemetryData::mutable_wpan_topo_full() {
  ::threadnetwork::TelemetryData_WpanTopoFull* _msg = _internal_mutable_wpan_topo_full();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.wpan_topo_full)
  return _msg;
}
inline void TelemetryData::set_allocated_wpan_topo_full(::threadnetwork::TelemetryData_WpanTopoFull* wpan_topo_full) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wpan_topo_full_;
  }
  if (wpan_topo_full) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wpan_topo_full);
    if (message_arena != submessage_arena) {
      wpan_topo_full = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wpan_topo_full, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wpan_topo_full_ = wpan_topo_full;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.wpan_topo_full)
}

// repeated .threadnetwork.TelemetryData.TopoEntry topo_entries = 3;
inline int TelemetryData::_internal_topo_entries_size() const {
  return _impl_.topo_entries_.size();
}
inline int TelemetryData::topo_entries_size() const {
  return _internal_topo_entries_size();
}
inline void TelemetryData::clear_topo_entries() {
  _impl_.topo_entries_.Clear();
}
inline ::threadnetwork::TelemetryData_TopoEntry* TelemetryData::mutable_topo_entries(int index) {
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.topo_entries)
  return _impl_.topo_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_TopoEntry >*
TelemetryData::mutable_topo_entries() {
  // @@protoc_insertion_point(field_mutable_list:threadnetwork.TelemetryData.topo_entries)
  return &_impl_.topo_entries_;
}
inline const ::threadnetwork::TelemetryData_TopoEntry& TelemetryData::_internal_topo_entries(int index) const {
  return _impl_.topo_entries_.Get(index);
}
inline const ::threadnetwork::TelemetryData_TopoEntry& TelemetryData::topo_entries(int index) const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.topo_entries)
  return _internal_topo_entries(index);
}
inline ::threadnetwork::TelemetryData_TopoEntry* TelemetryData::_internal_add_topo_entries() {
  return _impl_.topo_entries_.Add();
}
inline ::threadnetwork::TelemetryData_TopoEntry* TelemetryData::add_topo_entries() {
  ::threadnetwork::TelemetryData_TopoEntry* _add = _internal_add_topo_entries();
  // @@protoc_insertion_point(field_add:threadnetwork.TelemetryData.topo_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::threadnetwork::TelemetryData_TopoEntry >&
TelemetryData::topo_entries() const {
  // @@protoc_insertion_point(field_list:threadnetwork.TelemetryData.topo_entries)
  return _impl_.topo_entries_;
}

// optional .threadnetwork.TelemetryData.WpanBorderRouter wpan_border_router = 4;
inline bool TelemetryData::_internal_has_wpan_border_router() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wpan_border_router_ != nullptr);
  return value;
}
inline bool TelemetryData::has_wpan_border_router() const {
  return _internal_has_wpan_border_router();
}
inline void TelemetryData::clear_wpan_border_router() {
  if (_impl_.wpan_border_router_ != nullptr) _impl_.wpan_border_router_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::threadnetwork::TelemetryData_WpanBorderRouter& TelemetryData::_internal_wpan_border_router() const {
  const ::threadnetwork::TelemetryData_WpanBorderRouter* p = _impl_.wpan_border_router_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_WpanBorderRouter&>(
      ::threadnetwork::_TelemetryData_WpanBorderRouter_default_instance_);
}
inline const ::threadnetwork::TelemetryData_WpanBorderRouter& TelemetryData::wpan_border_router() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.wpan_border_router)
  return _internal_wpan_border_router();
}
inline void TelemetryData::unsafe_arena_set_allocated_wpan_border_router(
    ::threadnetwork::TelemetryData_WpanBorderRouter* wpan_border_router) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wpan_border_router_);
  }
  _impl_.wpan_border_router_ = wpan_border_router;
  if (wpan_border_router) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.wpan_border_router)
}
inline ::threadnetwork::TelemetryData_WpanBorderRouter* TelemetryData::release_wpan_border_router() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_WpanBorderRouter* temp = _impl_.wpan_border_router_;
  _impl_.wpan_border_router_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanBorderRouter* TelemetryData::unsafe_arena_release_wpan_border_router() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.wpan_border_router)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::threadnetwork::TelemetryData_WpanBorderRouter* temp = _impl_.wpan_border_router_;
  _impl_.wpan_border_router_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanBorderRouter* TelemetryData::_internal_mutable_wpan_border_router() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.wpan_border_router_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_WpanBorderRouter>(GetArenaForAllocation());
    _impl_.wpan_border_router_ = p;
  }
  return _impl_.wpan_border_router_;
}
inline ::threadnetwork::TelemetryData_WpanBorderRouter* TelemetryData::mutable_wpan_border_router() {
  ::threadnetwork::TelemetryData_WpanBorderRouter* _msg = _internal_mutable_wpan_border_router();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.wpan_border_router)
  return _msg;
}
inline void TelemetryData::set_allocated_wpan_border_router(::threadnetwork::TelemetryData_WpanBorderRouter* wpan_border_router) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wpan_border_router_;
  }
  if (wpan_border_router) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wpan_border_router);
    if (message_arena != submessage_arena) {
      wpan_border_router = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wpan_border_router, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.wpan_border_router_ = wpan_border_router;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.wpan_border_router)
}

// optional .threadnetwork.TelemetryData.WpanRcp wpan_rcp = 5;
inline bool TelemetryData::_internal_has_wpan_rcp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wpan_rcp_ != nullptr);
  return value;
}
inline bool TelemetryData::has_wpan_rcp() const {
  return _internal_has_wpan_rcp();
}
inline void TelemetryData::clear_wpan_rcp() {
  if (_impl_.wpan_rcp_ != nullptr) _impl_.wpan_rcp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::threadnetwork::TelemetryData_WpanRcp& TelemetryData::_internal_wpan_rcp() const {
  const ::threadnetwork::TelemetryData_WpanRcp* p = _impl_.wpan_rcp_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_WpanRcp&>(
      ::threadnetwork::_TelemetryData_WpanRcp_default_instance_);
}
inline const ::threadnetwork::TelemetryData_WpanRcp& TelemetryData::wpan_rcp() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.wpan_rcp)
  return _internal_wpan_rcp();
}
inline void TelemetryData::unsafe_arena_set_allocated_wpan_rcp(
    ::threadnetwork::TelemetryData_WpanRcp* wpan_rcp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wpan_rcp_);
  }
  _impl_.wpan_rcp_ = wpan_rcp;
  if (wpan_rcp) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.wpan_rcp)
}
inline ::threadnetwork::TelemetryData_WpanRcp* TelemetryData::release_wpan_rcp() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_WpanRcp* temp = _impl_.wpan_rcp_;
  _impl_.wpan_rcp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanRcp* TelemetryData::unsafe_arena_release_wpan_rcp() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.wpan_rcp)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::threadnetwork::TelemetryData_WpanRcp* temp = _impl_.wpan_rcp_;
  _impl_.wpan_rcp_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_WpanRcp* TelemetryData::_internal_mutable_wpan_rcp() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.wpan_rcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_WpanRcp>(GetArenaForAllocation());
    _impl_.wpan_rcp_ = p;
  }
  return _impl_.wpan_rcp_;
}
inline ::threadnetwork::TelemetryData_WpanRcp* TelemetryData::mutable_wpan_rcp() {
  ::threadnetwork::TelemetryData_WpanRcp* _msg = _internal_mutable_wpan_rcp();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.wpan_rcp)
  return _msg;
}
inline void TelemetryData::set_allocated_wpan_rcp(::threadnetwork::TelemetryData_WpanRcp* wpan_rcp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wpan_rcp_;
  }
  if (wpan_rcp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wpan_rcp);
    if (message_arena != submessage_arena) {
      wpan_rcp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wpan_rcp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.wpan_rcp_ = wpan_rcp;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.wpan_rcp)
}

// optional .threadnetwork.TelemetryData.CoexMetrics coex_metrics = 7;
inline bool TelemetryData::_internal_has_coex_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coex_metrics_ != nullptr);
  return value;
}
inline bool TelemetryData::has_coex_metrics() const {
  return _internal_has_coex_metrics();
}
inline void TelemetryData::clear_coex_metrics() {
  if (_impl_.coex_metrics_ != nullptr) _impl_.coex_metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::threadnetwork::TelemetryData_CoexMetrics& TelemetryData::_internal_coex_metrics() const {
  const ::threadnetwork::TelemetryData_CoexMetrics* p = _impl_.coex_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_CoexMetrics&>(
      ::threadnetwork::_TelemetryData_CoexMetrics_default_instance_);
}
inline const ::threadnetwork::TelemetryData_CoexMetrics& TelemetryData::coex_metrics() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.coex_metrics)
  return _internal_coex_metrics();
}
inline void TelemetryData::unsafe_arena_set_allocated_coex_metrics(
    ::threadnetwork::TelemetryData_CoexMetrics* coex_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coex_metrics_);
  }
  _impl_.coex_metrics_ = coex_metrics;
  if (coex_metrics) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.coex_metrics)
}
inline ::threadnetwork::TelemetryData_CoexMetrics* TelemetryData::release_coex_metrics() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_CoexMetrics* temp = _impl_.coex_metrics_;
  _impl_.coex_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_CoexMetrics* TelemetryData::unsafe_arena_release_coex_metrics() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.coex_metrics)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::threadnetwork::TelemetryData_CoexMetrics* temp = _impl_.coex_metrics_;
  _impl_.coex_metrics_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_CoexMetrics* TelemetryData::_internal_mutable_coex_metrics() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.coex_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_CoexMetrics>(GetArenaForAllocation());
    _impl_.coex_metrics_ = p;
  }
  return _impl_.coex_metrics_;
}
inline ::threadnetwork::TelemetryData_CoexMetrics* TelemetryData::mutable_coex_metrics() {
  ::threadnetwork::TelemetryData_CoexMetrics* _msg = _internal_mutable_coex_metrics();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.coex_metrics)
  return _msg;
}
inline void TelemetryData::set_allocated_coex_metrics(::threadnetwork::TelemetryData_CoexMetrics* coex_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coex_metrics_;
  }
  if (coex_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coex_metrics);
    if (message_arena != submessage_arena) {
      coex_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coex_metrics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.coex_metrics_ = coex_metrics;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.coex_metrics)
}

// optional .threadnetwork.TelemetryData.LowPowerMetrics low_power_metrics = 8;
inline bool TelemetryData::_internal_has_low_power_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.low_power_metrics_ != nullptr);
  return value;
}
inline bool TelemetryData::has_low_power_metrics() const {
  return _internal_has_low_power_metrics();
}
inline void TelemetryData::clear_low_power_metrics() {
  if (_impl_.low_power_metrics_ != nullptr) _impl_.low_power_metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::threadnetwork::TelemetryData_LowPowerMetrics& TelemetryData::_internal_low_power_metrics() const {
  const ::threadnetwork::TelemetryData_LowPowerMetrics* p = _impl_.low_power_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::threadnetwork::TelemetryData_LowPowerMetrics&>(
      ::threadnetwork::_TelemetryData_LowPowerMetrics_default_instance_);
}
inline const ::threadnetwork::TelemetryData_LowPowerMetrics& TelemetryData::low_power_metrics() const {
  // @@protoc_insertion_point(field_get:threadnetwork.TelemetryData.low_power_metrics)
  return _internal_low_power_metrics();
}
inline void TelemetryData::unsafe_arena_set_allocated_low_power_metrics(
    ::threadnetwork::TelemetryData_LowPowerMetrics* low_power_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.low_power_metrics_);
  }
  _impl_.low_power_metrics_ = low_power_metrics;
  if (low_power_metrics) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:threadnetwork.TelemetryData.low_power_metrics)
}
inline ::threadnetwork::TelemetryData_LowPowerMetrics* TelemetryData::release_low_power_metrics() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_LowPowerMetrics* temp = _impl_.low_power_metrics_;
  _impl_.low_power_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::threadnetwork::TelemetryData_LowPowerMetrics* TelemetryData::unsafe_arena_release_low_power_metrics() {
  // @@protoc_insertion_point(field_release:threadnetwork.TelemetryData.low_power_metrics)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::threadnetwork::TelemetryData_LowPowerMetrics* temp = _impl_.low_power_metrics_;
  _impl_.low_power_metrics_ = nullptr;
  return temp;
}
inline ::threadnetwork::TelemetryData_LowPowerMetrics* TelemetryData::_internal_mutable_low_power_metrics() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.low_power_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::threadnetwork::TelemetryData_LowPowerMetrics>(GetArenaForAllocation());
    _impl_.low_power_metrics_ = p;
  }
  return _impl_.low_power_metrics_;
}
inline ::threadnetwork::TelemetryData_LowPowerMetrics* TelemetryData::mutable_low_power_metrics() {
  ::threadnetwork::TelemetryData_LowPowerMetrics* _msg = _internal_mutable_low_power_metrics();
  // @@protoc_insertion_point(field_mutable:threadnetwork.TelemetryData.low_power_metrics)
  return _msg;
}
inline void TelemetryData::set_allocated_low_power_metrics(::threadnetwork::TelemetryData_LowPowerMetrics* low_power_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.low_power_metrics_;
  }
  if (low_power_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(low_power_metrics);
    if (message_arena != submessage_arena) {
      low_power_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_power_metrics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.low_power_metrics_ = low_power_metrics;
  // @@protoc_insertion_point(field_set_allocated:threadnetwork.TelemetryData.low_power_metrics)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace threadnetwork

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::threadnetwork::TelemetryData_NodeType> : ::std::true_type {};
template <> struct is_proto_enum< ::threadnetwork::TelemetryData_Dhcp6PdState> : ::std::true_type {};
template <> struct is_proto_enum< ::threadnetwork::TelemetryData_SrpServerState> : ::std::true_type {};
template <> struct is_proto_enum< ::threadnetwork::TelemetryData_SrpServerAddressMode> : ::std::true_type {};
template <> struct is_proto_enum< ::threadnetwork::TelemetryData_UpstreamDnsQueryState> : ::std::true_type {};
template <> struct is_proto_enum< ::threadnetwork::TelemetryData_Nat64State> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_thread_5ftelemetry_2eproto
